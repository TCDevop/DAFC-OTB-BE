
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model GroupBrand
 * 
 */
export type GroupBrand = $Result.DefaultSelection<Prisma.$GroupBrandPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model Collection
 * 
 */
export type Collection = $Result.DefaultSelection<Prisma.$CollectionPayload>
/**
 * Model Gender
 * 
 */
export type Gender = $Result.DefaultSelection<Prisma.$GenderPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model SubCategory
 * 
 */
export type SubCategory = $Result.DefaultSelection<Prisma.$SubCategoryPayload>
/**
 * Model SkuCatalog
 * 
 */
export type SkuCatalog = $Result.DefaultSelection<Prisma.$SkuCatalogPayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model BudgetDetail
 * 
 */
export type BudgetDetail = $Result.DefaultSelection<Prisma.$BudgetDetailPayload>
/**
 * Model PlanningVersion
 * 
 */
export type PlanningVersion = $Result.DefaultSelection<Prisma.$PlanningVersionPayload>
/**
 * Model PlanningDetail
 * 
 */
export type PlanningDetail = $Result.DefaultSelection<Prisma.$PlanningDetailPayload>
/**
 * Model Proposal
 * 
 */
export type Proposal = $Result.DefaultSelection<Prisma.$ProposalPayload>
/**
 * Model ProposalProduct
 * 
 */
export type ProposalProduct = $Result.DefaultSelection<Prisma.$ProposalProductPayload>
/**
 * Model ProductAllocation
 * 
 */
export type ProductAllocation = $Result.DefaultSelection<Prisma.$ProductAllocationPayload>
/**
 * Model Approval
 * 
 */
export type Approval = $Result.DefaultSelection<Prisma.$ApprovalPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SalesHistory
 * 
 */
export type SalesHistory = $Result.DefaultSelection<Prisma.$SalesHistoryPayload>
/**
 * Model SizeCurveRecommendation
 * 
 */
export type SizeCurveRecommendation = $Result.DefaultSelection<Prisma.$SizeCurveRecommendationPayload>
/**
 * Model BudgetAlert
 * 
 */
export type BudgetAlert = $Result.DefaultSelection<Prisma.$BudgetAlertPayload>
/**
 * Model BudgetSnapshot
 * 
 */
export type BudgetSnapshot = $Result.DefaultSelection<Prisma.$BudgetSnapshotPayload>
/**
 * Model AllocationHistory
 * 
 */
export type AllocationHistory = $Result.DefaultSelection<Prisma.$AllocationHistoryPayload>
/**
 * Model AllocationRecommendation
 * 
 */
export type AllocationRecommendation = $Result.DefaultSelection<Prisma.$AllocationRecommendationPayload>
/**
 * Model RiskAssessment
 * 
 */
export type RiskAssessment = $Result.DefaultSelection<Prisma.$RiskAssessmentPayload>
/**
 * Model RiskThreshold
 * 
 */
export type RiskThreshold = $Result.DefaultSelection<Prisma.$RiskThresholdPayload>
/**
 * Model SkuPerformance
 * 
 */
export type SkuPerformance = $Result.DefaultSelection<Prisma.$SkuPerformancePayload>
/**
 * Model AttributeTrend
 * 
 */
export type AttributeTrend = $Result.DefaultSelection<Prisma.$AttributeTrendPayload>
/**
 * Model SkuRecommendation
 * 
 */
export type SkuRecommendation = $Result.DefaultSelection<Prisma.$SkuRecommendationPayload>
/**
 * Model ApprovalWorkflowStep
 * 
 */
export type ApprovalWorkflowStep = $Result.DefaultSelection<Prisma.$ApprovalWorkflowStepPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BudgetStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  LEVEL1_APPROVED: 'LEVEL1_APPROVED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type BudgetStatus = (typeof BudgetStatus)[keyof typeof BudgetStatus]


export const PlanningStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  LEVEL1_APPROVED: 'LEVEL1_APPROVED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type PlanningStatus = (typeof PlanningStatus)[keyof typeof PlanningStatus]


export const ProposalStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  LEVEL1_APPROVED: 'LEVEL1_APPROVED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ProposalStatus = (typeof ProposalStatus)[keyof typeof ProposalStatus]


export const ApprovalAction: {
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalAction = (typeof ApprovalAction)[keyof typeof ApprovalAction]

}

export type BudgetStatus = $Enums.BudgetStatus

export const BudgetStatus: typeof $Enums.BudgetStatus

export type PlanningStatus = $Enums.PlanningStatus

export const PlanningStatus: typeof $Enums.PlanningStatus

export type ProposalStatus = $Enums.ProposalStatus

export const ProposalStatus: typeof $Enums.ProposalStatus

export type ApprovalAction = $Enums.ApprovalAction

export const ApprovalAction: typeof $Enums.ApprovalAction

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.groupBrand`: Exposes CRUD operations for the **GroupBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupBrands
    * const groupBrands = await prisma.groupBrand.findMany()
    * ```
    */
  get groupBrand(): Prisma.GroupBrandDelegate<ExtArgs>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **Collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collection.findMany()
    * ```
    */
  get collection(): Prisma.CollectionDelegate<ExtArgs>;

  /**
   * `prisma.gender`: Exposes CRUD operations for the **Gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genders
    * const genders = await prisma.gender.findMany()
    * ```
    */
  get gender(): Prisma.GenderDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<ExtArgs>;

  /**
   * `prisma.skuCatalog`: Exposes CRUD operations for the **SkuCatalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuCatalogs
    * const skuCatalogs = await prisma.skuCatalog.findMany()
    * ```
    */
  get skuCatalog(): Prisma.SkuCatalogDelegate<ExtArgs>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs>;

  /**
   * `prisma.budgetDetail`: Exposes CRUD operations for the **BudgetDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetDetails
    * const budgetDetails = await prisma.budgetDetail.findMany()
    * ```
    */
  get budgetDetail(): Prisma.BudgetDetailDelegate<ExtArgs>;

  /**
   * `prisma.planningVersion`: Exposes CRUD operations for the **PlanningVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanningVersions
    * const planningVersions = await prisma.planningVersion.findMany()
    * ```
    */
  get planningVersion(): Prisma.PlanningVersionDelegate<ExtArgs>;

  /**
   * `prisma.planningDetail`: Exposes CRUD operations for the **PlanningDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanningDetails
    * const planningDetails = await prisma.planningDetail.findMany()
    * ```
    */
  get planningDetail(): Prisma.PlanningDetailDelegate<ExtArgs>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<ExtArgs>;

  /**
   * `prisma.proposalProduct`: Exposes CRUD operations for the **ProposalProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalProducts
    * const proposalProducts = await prisma.proposalProduct.findMany()
    * ```
    */
  get proposalProduct(): Prisma.ProposalProductDelegate<ExtArgs>;

  /**
   * `prisma.productAllocation`: Exposes CRUD operations for the **ProductAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductAllocations
    * const productAllocations = await prisma.productAllocation.findMany()
    * ```
    */
  get productAllocation(): Prisma.ProductAllocationDelegate<ExtArgs>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.salesHistory`: Exposes CRUD operations for the **SalesHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesHistories
    * const salesHistories = await prisma.salesHistory.findMany()
    * ```
    */
  get salesHistory(): Prisma.SalesHistoryDelegate<ExtArgs>;

  /**
   * `prisma.sizeCurveRecommendation`: Exposes CRUD operations for the **SizeCurveRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SizeCurveRecommendations
    * const sizeCurveRecommendations = await prisma.sizeCurveRecommendation.findMany()
    * ```
    */
  get sizeCurveRecommendation(): Prisma.SizeCurveRecommendationDelegate<ExtArgs>;

  /**
   * `prisma.budgetAlert`: Exposes CRUD operations for the **BudgetAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetAlerts
    * const budgetAlerts = await prisma.budgetAlert.findMany()
    * ```
    */
  get budgetAlert(): Prisma.BudgetAlertDelegate<ExtArgs>;

  /**
   * `prisma.budgetSnapshot`: Exposes CRUD operations for the **BudgetSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BudgetSnapshots
    * const budgetSnapshots = await prisma.budgetSnapshot.findMany()
    * ```
    */
  get budgetSnapshot(): Prisma.BudgetSnapshotDelegate<ExtArgs>;

  /**
   * `prisma.allocationHistory`: Exposes CRUD operations for the **AllocationHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AllocationHistories
    * const allocationHistories = await prisma.allocationHistory.findMany()
    * ```
    */
  get allocationHistory(): Prisma.AllocationHistoryDelegate<ExtArgs>;

  /**
   * `prisma.allocationRecommendation`: Exposes CRUD operations for the **AllocationRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AllocationRecommendations
    * const allocationRecommendations = await prisma.allocationRecommendation.findMany()
    * ```
    */
  get allocationRecommendation(): Prisma.AllocationRecommendationDelegate<ExtArgs>;

  /**
   * `prisma.riskAssessment`: Exposes CRUD operations for the **RiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAssessments
    * const riskAssessments = await prisma.riskAssessment.findMany()
    * ```
    */
  get riskAssessment(): Prisma.RiskAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.riskThreshold`: Exposes CRUD operations for the **RiskThreshold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskThresholds
    * const riskThresholds = await prisma.riskThreshold.findMany()
    * ```
    */
  get riskThreshold(): Prisma.RiskThresholdDelegate<ExtArgs>;

  /**
   * `prisma.skuPerformance`: Exposes CRUD operations for the **SkuPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuPerformances
    * const skuPerformances = await prisma.skuPerformance.findMany()
    * ```
    */
  get skuPerformance(): Prisma.SkuPerformanceDelegate<ExtArgs>;

  /**
   * `prisma.attributeTrend`: Exposes CRUD operations for the **AttributeTrend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttributeTrends
    * const attributeTrends = await prisma.attributeTrend.findMany()
    * ```
    */
  get attributeTrend(): Prisma.AttributeTrendDelegate<ExtArgs>;

  /**
   * `prisma.skuRecommendation`: Exposes CRUD operations for the **SkuRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkuRecommendations
    * const skuRecommendations = await prisma.skuRecommendation.findMany()
    * ```
    */
  get skuRecommendation(): Prisma.SkuRecommendationDelegate<ExtArgs>;

  /**
   * `prisma.approvalWorkflowStep`: Exposes CRUD operations for the **ApprovalWorkflowStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalWorkflowSteps
    * const approvalWorkflowSteps = await prisma.approvalWorkflowStep.findMany()
    * ```
    */
  get approvalWorkflowStep(): Prisma.ApprovalWorkflowStepDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    GroupBrand: 'GroupBrand',
    Store: 'Store',
    Collection: 'Collection',
    Gender: 'Gender',
    Category: 'Category',
    SubCategory: 'SubCategory',
    SkuCatalog: 'SkuCatalog',
    Budget: 'Budget',
    BudgetDetail: 'BudgetDetail',
    PlanningVersion: 'PlanningVersion',
    PlanningDetail: 'PlanningDetail',
    Proposal: 'Proposal',
    ProposalProduct: 'ProposalProduct',
    ProductAllocation: 'ProductAllocation',
    Approval: 'Approval',
    AuditLog: 'AuditLog',
    SalesHistory: 'SalesHistory',
    SizeCurveRecommendation: 'SizeCurveRecommendation',
    BudgetAlert: 'BudgetAlert',
    BudgetSnapshot: 'BudgetSnapshot',
    AllocationHistory: 'AllocationHistory',
    AllocationRecommendation: 'AllocationRecommendation',
    RiskAssessment: 'RiskAssessment',
    RiskThreshold: 'RiskThreshold',
    SkuPerformance: 'SkuPerformance',
    AttributeTrend: 'AttributeTrend',
    SkuRecommendation: 'SkuRecommendation',
    ApprovalWorkflowStep: 'ApprovalWorkflowStep'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "groupBrand" | "store" | "collection" | "gender" | "category" | "subCategory" | "skuCatalog" | "budget" | "budgetDetail" | "planningVersion" | "planningDetail" | "proposal" | "proposalProduct" | "productAllocation" | "approval" | "auditLog" | "salesHistory" | "sizeCurveRecommendation" | "budgetAlert" | "budgetSnapshot" | "allocationHistory" | "allocationRecommendation" | "riskAssessment" | "riskThreshold" | "skuPerformance" | "attributeTrend" | "skuRecommendation" | "approvalWorkflowStep"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      GroupBrand: {
        payload: Prisma.$GroupBrandPayload<ExtArgs>
        fields: Prisma.GroupBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>
          }
          findFirst: {
            args: Prisma.GroupBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>
          }
          findMany: {
            args: Prisma.GroupBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>[]
          }
          create: {
            args: Prisma.GroupBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>
          }
          createMany: {
            args: Prisma.GroupBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>[]
          }
          delete: {
            args: Prisma.GroupBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>
          }
          update: {
            args: Prisma.GroupBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>
          }
          deleteMany: {
            args: Prisma.GroupBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBrandPayload>
          }
          aggregate: {
            args: Prisma.GroupBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupBrand>
          }
          groupBy: {
            args: Prisma.GroupBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupBrandCountArgs<ExtArgs>
            result: $Utils.Optional<GroupBrandCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      Collection: {
        payload: Prisma.$CollectionPayload<ExtArgs>
        fields: Prisma.CollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findFirst: {
            args: Prisma.CollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findMany: {
            args: Prisma.CollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          create: {
            args: Prisma.CollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          createMany: {
            args: Prisma.CollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          delete: {
            args: Prisma.CollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          update: {
            args: Prisma.CollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          deleteMany: {
            args: Prisma.CollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          aggregate: {
            args: Prisma.CollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection>
          }
          groupBy: {
            args: Prisma.CollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCountAggregateOutputType> | number
          }
        }
      }
      Gender: {
        payload: Prisma.$GenderPayload<ExtArgs>
        fields: Prisma.GenderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          findFirst: {
            args: Prisma.GenderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          findMany: {
            args: Prisma.GenderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>[]
          }
          create: {
            args: Prisma.GenderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          createMany: {
            args: Prisma.GenderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>[]
          }
          delete: {
            args: Prisma.GenderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          update: {
            args: Prisma.GenderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          deleteMany: {
            args: Prisma.GenderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GenderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenderPayload>
          }
          aggregate: {
            args: Prisma.GenderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGender>
          }
          groupBy: {
            args: Prisma.GenderGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenderCountArgs<ExtArgs>
            result: $Utils.Optional<GenderCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      SubCategory: {
        payload: Prisma.$SubCategoryPayload<ExtArgs>
        fields: Prisma.SubCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findFirst: {
            args: Prisma.SubCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          findMany: {
            args: Prisma.SubCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>[]
          }
          create: {
            args: Prisma.SubCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          createMany: {
            args: Prisma.SubCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>[]
          }
          delete: {
            args: Prisma.SubCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          update: {
            args: Prisma.SubCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubCategoryPayload>
          }
          aggregate: {
            args: Prisma.SubCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubCategory>
          }
          groupBy: {
            args: Prisma.SubCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubCategoryCountAggregateOutputType> | number
          }
        }
      }
      SkuCatalog: {
        payload: Prisma.$SkuCatalogPayload<ExtArgs>
        fields: Prisma.SkuCatalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuCatalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuCatalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>
          }
          findFirst: {
            args: Prisma.SkuCatalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuCatalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>
          }
          findMany: {
            args: Prisma.SkuCatalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>[]
          }
          create: {
            args: Prisma.SkuCatalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>
          }
          createMany: {
            args: Prisma.SkuCatalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuCatalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>[]
          }
          delete: {
            args: Prisma.SkuCatalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>
          }
          update: {
            args: Prisma.SkuCatalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>
          }
          deleteMany: {
            args: Prisma.SkuCatalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuCatalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkuCatalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuCatalogPayload>
          }
          aggregate: {
            args: Prisma.SkuCatalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuCatalog>
          }
          groupBy: {
            args: Prisma.SkuCatalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuCatalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuCatalogCountArgs<ExtArgs>
            result: $Utils.Optional<SkuCatalogCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      BudgetDetail: {
        payload: Prisma.$BudgetDetailPayload<ExtArgs>
        fields: Prisma.BudgetDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>
          }
          findFirst: {
            args: Prisma.BudgetDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>
          }
          findMany: {
            args: Prisma.BudgetDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>[]
          }
          create: {
            args: Prisma.BudgetDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>
          }
          createMany: {
            args: Prisma.BudgetDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>[]
          }
          delete: {
            args: Prisma.BudgetDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>
          }
          update: {
            args: Prisma.BudgetDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetDetailPayload>
          }
          aggregate: {
            args: Prisma.BudgetDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetDetail>
          }
          groupBy: {
            args: Prisma.BudgetDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetDetailCountAggregateOutputType> | number
          }
        }
      }
      PlanningVersion: {
        payload: Prisma.$PlanningVersionPayload<ExtArgs>
        fields: Prisma.PlanningVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanningVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanningVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>
          }
          findFirst: {
            args: Prisma.PlanningVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanningVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>
          }
          findMany: {
            args: Prisma.PlanningVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>[]
          }
          create: {
            args: Prisma.PlanningVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>
          }
          createMany: {
            args: Prisma.PlanningVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanningVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>[]
          }
          delete: {
            args: Prisma.PlanningVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>
          }
          update: {
            args: Prisma.PlanningVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>
          }
          deleteMany: {
            args: Prisma.PlanningVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanningVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanningVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningVersionPayload>
          }
          aggregate: {
            args: Prisma.PlanningVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanningVersion>
          }
          groupBy: {
            args: Prisma.PlanningVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanningVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanningVersionCountArgs<ExtArgs>
            result: $Utils.Optional<PlanningVersionCountAggregateOutputType> | number
          }
        }
      }
      PlanningDetail: {
        payload: Prisma.$PlanningDetailPayload<ExtArgs>
        fields: Prisma.PlanningDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanningDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanningDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>
          }
          findFirst: {
            args: Prisma.PlanningDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanningDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>
          }
          findMany: {
            args: Prisma.PlanningDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>[]
          }
          create: {
            args: Prisma.PlanningDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>
          }
          createMany: {
            args: Prisma.PlanningDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanningDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>[]
          }
          delete: {
            args: Prisma.PlanningDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>
          }
          update: {
            args: Prisma.PlanningDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>
          }
          deleteMany: {
            args: Prisma.PlanningDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanningDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanningDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningDetailPayload>
          }
          aggregate: {
            args: Prisma.PlanningDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanningDetail>
          }
          groupBy: {
            args: Prisma.PlanningDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanningDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanningDetailCountArgs<ExtArgs>
            result: $Utils.Optional<PlanningDetailCountAggregateOutputType> | number
          }
        }
      }
      Proposal: {
        payload: Prisma.$ProposalPayload<ExtArgs>
        fields: Prisma.ProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findFirst: {
            args: Prisma.ProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findMany: {
            args: Prisma.ProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          create: {
            args: Prisma.ProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          createMany: {
            args: Prisma.ProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          delete: {
            args: Prisma.ProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          update: {
            args: Prisma.ProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          deleteMany: {
            args: Prisma.ProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.ProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
      ProposalProduct: {
        payload: Prisma.$ProposalProductPayload<ExtArgs>
        fields: Prisma.ProposalProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>
          }
          findFirst: {
            args: Prisma.ProposalProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>
          }
          findMany: {
            args: Prisma.ProposalProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>[]
          }
          create: {
            args: Prisma.ProposalProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>
          }
          createMany: {
            args: Prisma.ProposalProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>[]
          }
          delete: {
            args: Prisma.ProposalProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>
          }
          update: {
            args: Prisma.ProposalProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>
          }
          deleteMany: {
            args: Prisma.ProposalProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProposalProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalProductPayload>
          }
          aggregate: {
            args: Prisma.ProposalProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalProduct>
          }
          groupBy: {
            args: Prisma.ProposalProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalProductCountAggregateOutputType> | number
          }
        }
      }
      ProductAllocation: {
        payload: Prisma.$ProductAllocationPayload<ExtArgs>
        fields: Prisma.ProductAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>
          }
          findFirst: {
            args: Prisma.ProductAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>
          }
          findMany: {
            args: Prisma.ProductAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>[]
          }
          create: {
            args: Prisma.ProductAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>
          }
          createMany: {
            args: Prisma.ProductAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>[]
          }
          delete: {
            args: Prisma.ProductAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>
          }
          update: {
            args: Prisma.ProductAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>
          }
          deleteMany: {
            args: Prisma.ProductAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductAllocationPayload>
          }
          aggregate: {
            args: Prisma.ProductAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductAllocation>
          }
          groupBy: {
            args: Prisma.ProductAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductAllocationCountAggregateOutputType> | number
          }
        }
      }
      Approval: {
        payload: Prisma.$ApprovalPayload<ExtArgs>
        fields: Prisma.ApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findFirst: {
            args: Prisma.ApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findMany: {
            args: Prisma.ApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          create: {
            args: Prisma.ApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          createMany: {
            args: Prisma.ApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          delete: {
            args: Prisma.ApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          update: {
            args: Prisma.ApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          aggregate: {
            args: Prisma.ApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApproval>
          }
          groupBy: {
            args: Prisma.ApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SalesHistory: {
        payload: Prisma.$SalesHistoryPayload<ExtArgs>
        fields: Prisma.SalesHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>
          }
          findFirst: {
            args: Prisma.SalesHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>
          }
          findMany: {
            args: Prisma.SalesHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>[]
          }
          create: {
            args: Prisma.SalesHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>
          }
          createMany: {
            args: Prisma.SalesHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>[]
          }
          delete: {
            args: Prisma.SalesHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>
          }
          update: {
            args: Prisma.SalesHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SalesHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesHistoryPayload>
          }
          aggregate: {
            args: Prisma.SalesHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesHistory>
          }
          groupBy: {
            args: Prisma.SalesHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SalesHistoryCountAggregateOutputType> | number
          }
        }
      }
      SizeCurveRecommendation: {
        payload: Prisma.$SizeCurveRecommendationPayload<ExtArgs>
        fields: Prisma.SizeCurveRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SizeCurveRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SizeCurveRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>
          }
          findFirst: {
            args: Prisma.SizeCurveRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SizeCurveRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>
          }
          findMany: {
            args: Prisma.SizeCurveRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>[]
          }
          create: {
            args: Prisma.SizeCurveRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>
          }
          createMany: {
            args: Prisma.SizeCurveRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SizeCurveRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>[]
          }
          delete: {
            args: Prisma.SizeCurveRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>
          }
          update: {
            args: Prisma.SizeCurveRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.SizeCurveRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SizeCurveRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SizeCurveRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizeCurveRecommendationPayload>
          }
          aggregate: {
            args: Prisma.SizeCurveRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSizeCurveRecommendation>
          }
          groupBy: {
            args: Prisma.SizeCurveRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SizeCurveRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SizeCurveRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<SizeCurveRecommendationCountAggregateOutputType> | number
          }
        }
      }
      BudgetAlert: {
        payload: Prisma.$BudgetAlertPayload<ExtArgs>
        fields: Prisma.BudgetAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>
          }
          findFirst: {
            args: Prisma.BudgetAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>
          }
          findMany: {
            args: Prisma.BudgetAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>[]
          }
          create: {
            args: Prisma.BudgetAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>
          }
          createMany: {
            args: Prisma.BudgetAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>[]
          }
          delete: {
            args: Prisma.BudgetAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>
          }
          update: {
            args: Prisma.BudgetAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>
          }
          deleteMany: {
            args: Prisma.BudgetAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetAlertPayload>
          }
          aggregate: {
            args: Prisma.BudgetAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetAlert>
          }
          groupBy: {
            args: Prisma.BudgetAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetAlertCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetAlertCountAggregateOutputType> | number
          }
        }
      }
      BudgetSnapshot: {
        payload: Prisma.$BudgetSnapshotPayload<ExtArgs>
        fields: Prisma.BudgetSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>
          }
          findFirst: {
            args: Prisma.BudgetSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>
          }
          findMany: {
            args: Prisma.BudgetSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>[]
          }
          create: {
            args: Prisma.BudgetSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>
          }
          createMany: {
            args: Prisma.BudgetSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>[]
          }
          delete: {
            args: Prisma.BudgetSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>
          }
          update: {
            args: Prisma.BudgetSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.BudgetSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BudgetSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetSnapshotPayload>
          }
          aggregate: {
            args: Prisma.BudgetSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgetSnapshot>
          }
          groupBy: {
            args: Prisma.BudgetSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetSnapshotCountAggregateOutputType> | number
          }
        }
      }
      AllocationHistory: {
        payload: Prisma.$AllocationHistoryPayload<ExtArgs>
        fields: Prisma.AllocationHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllocationHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllocationHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>
          }
          findFirst: {
            args: Prisma.AllocationHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllocationHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>
          }
          findMany: {
            args: Prisma.AllocationHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>[]
          }
          create: {
            args: Prisma.AllocationHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>
          }
          createMany: {
            args: Prisma.AllocationHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllocationHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>[]
          }
          delete: {
            args: Prisma.AllocationHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>
          }
          update: {
            args: Prisma.AllocationHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AllocationHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllocationHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AllocationHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationHistoryPayload>
          }
          aggregate: {
            args: Prisma.AllocationHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllocationHistory>
          }
          groupBy: {
            args: Prisma.AllocationHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllocationHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllocationHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AllocationHistoryCountAggregateOutputType> | number
          }
        }
      }
      AllocationRecommendation: {
        payload: Prisma.$AllocationRecommendationPayload<ExtArgs>
        fields: Prisma.AllocationRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllocationRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllocationRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>
          }
          findFirst: {
            args: Prisma.AllocationRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllocationRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>
          }
          findMany: {
            args: Prisma.AllocationRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>[]
          }
          create: {
            args: Prisma.AllocationRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>
          }
          createMany: {
            args: Prisma.AllocationRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllocationRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>[]
          }
          delete: {
            args: Prisma.AllocationRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>
          }
          update: {
            args: Prisma.AllocationRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.AllocationRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllocationRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AllocationRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllocationRecommendationPayload>
          }
          aggregate: {
            args: Prisma.AllocationRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllocationRecommendation>
          }
          groupBy: {
            args: Prisma.AllocationRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllocationRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllocationRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<AllocationRecommendationCountAggregateOutputType> | number
          }
        }
      }
      RiskAssessment: {
        payload: Prisma.$RiskAssessmentPayload<ExtArgs>
        fields: Prisma.RiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.RiskAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.RiskAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.RiskAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.RiskAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          delete: {
            args: Prisma.RiskAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          update: {
            args: Prisma.RiskAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.RiskAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.RiskAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAssessment>
          }
          groupBy: {
            args: Prisma.RiskAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
      RiskThreshold: {
        payload: Prisma.$RiskThresholdPayload<ExtArgs>
        fields: Prisma.RiskThresholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskThresholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskThresholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>
          }
          findFirst: {
            args: Prisma.RiskThresholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskThresholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>
          }
          findMany: {
            args: Prisma.RiskThresholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>[]
          }
          create: {
            args: Prisma.RiskThresholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>
          }
          createMany: {
            args: Prisma.RiskThresholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskThresholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>[]
          }
          delete: {
            args: Prisma.RiskThresholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>
          }
          update: {
            args: Prisma.RiskThresholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>
          }
          deleteMany: {
            args: Prisma.RiskThresholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskThresholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskThresholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskThresholdPayload>
          }
          aggregate: {
            args: Prisma.RiskThresholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskThreshold>
          }
          groupBy: {
            args: Prisma.RiskThresholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskThresholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskThresholdCountArgs<ExtArgs>
            result: $Utils.Optional<RiskThresholdCountAggregateOutputType> | number
          }
        }
      }
      SkuPerformance: {
        payload: Prisma.$SkuPerformancePayload<ExtArgs>
        fields: Prisma.SkuPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>
          }
          findFirst: {
            args: Prisma.SkuPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>
          }
          findMany: {
            args: Prisma.SkuPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>[]
          }
          create: {
            args: Prisma.SkuPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>
          }
          createMany: {
            args: Prisma.SkuPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>[]
          }
          delete: {
            args: Prisma.SkuPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>
          }
          update: {
            args: Prisma.SkuPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>
          }
          deleteMany: {
            args: Prisma.SkuPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkuPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuPerformancePayload>
          }
          aggregate: {
            args: Prisma.SkuPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuPerformance>
          }
          groupBy: {
            args: Prisma.SkuPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<SkuPerformanceCountAggregateOutputType> | number
          }
        }
      }
      AttributeTrend: {
        payload: Prisma.$AttributeTrendPayload<ExtArgs>
        fields: Prisma.AttributeTrendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttributeTrendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttributeTrendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>
          }
          findFirst: {
            args: Prisma.AttributeTrendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttributeTrendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>
          }
          findMany: {
            args: Prisma.AttributeTrendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>[]
          }
          create: {
            args: Prisma.AttributeTrendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>
          }
          createMany: {
            args: Prisma.AttributeTrendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttributeTrendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>[]
          }
          delete: {
            args: Prisma.AttributeTrendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>
          }
          update: {
            args: Prisma.AttributeTrendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>
          }
          deleteMany: {
            args: Prisma.AttributeTrendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttributeTrendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttributeTrendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttributeTrendPayload>
          }
          aggregate: {
            args: Prisma.AttributeTrendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttributeTrend>
          }
          groupBy: {
            args: Prisma.AttributeTrendGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttributeTrendGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttributeTrendCountArgs<ExtArgs>
            result: $Utils.Optional<AttributeTrendCountAggregateOutputType> | number
          }
        }
      }
      SkuRecommendation: {
        payload: Prisma.$SkuRecommendationPayload<ExtArgs>
        fields: Prisma.SkuRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkuRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkuRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>
          }
          findFirst: {
            args: Prisma.SkuRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkuRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>
          }
          findMany: {
            args: Prisma.SkuRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>[]
          }
          create: {
            args: Prisma.SkuRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>
          }
          createMany: {
            args: Prisma.SkuRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkuRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>[]
          }
          delete: {
            args: Prisma.SkuRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>
          }
          update: {
            args: Prisma.SkuRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.SkuRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkuRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkuRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkuRecommendationPayload>
          }
          aggregate: {
            args: Prisma.SkuRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkuRecommendation>
          }
          groupBy: {
            args: Prisma.SkuRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkuRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkuRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<SkuRecommendationCountAggregateOutputType> | number
          }
        }
      }
      ApprovalWorkflowStep: {
        payload: Prisma.$ApprovalWorkflowStepPayload<ExtArgs>
        fields: Prisma.ApprovalWorkflowStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalWorkflowStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalWorkflowStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>
          }
          findFirst: {
            args: Prisma.ApprovalWorkflowStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalWorkflowStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>
          }
          findMany: {
            args: Prisma.ApprovalWorkflowStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>[]
          }
          create: {
            args: Prisma.ApprovalWorkflowStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>
          }
          createMany: {
            args: Prisma.ApprovalWorkflowStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalWorkflowStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>[]
          }
          delete: {
            args: Prisma.ApprovalWorkflowStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>
          }
          update: {
            args: Prisma.ApprovalWorkflowStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalWorkflowStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalWorkflowStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalWorkflowStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowStepPayload>
          }
          aggregate: {
            args: Prisma.ApprovalWorkflowStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalWorkflowStep>
          }
          groupBy: {
            args: Prisma.ApprovalWorkflowStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalWorkflowStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalWorkflowStepCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalWorkflowStepCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdBudgets: number
    createdPlannings: number
    createdProposals: number
    approvalDecisions: number
    auditLogs: number
    workflowSteps: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBudgets?: boolean | UserCountOutputTypeCountCreatedBudgetsArgs
    createdPlannings?: boolean | UserCountOutputTypeCountCreatedPlanningsArgs
    createdProposals?: boolean | UserCountOutputTypeCountCreatedProposalsArgs
    approvalDecisions?: boolean | UserCountOutputTypeCountApprovalDecisionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    workflowSteps?: boolean | UserCountOutputTypeCountWorkflowStepsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWorkflowStepWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type GroupBrandCountOutputType
   */

  export type GroupBrandCountOutputType = {
    budgets: number
    skuCatalog: number
    workflowSteps: number
  }

  export type GroupBrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgets?: boolean | GroupBrandCountOutputTypeCountBudgetsArgs
    skuCatalog?: boolean | GroupBrandCountOutputTypeCountSkuCatalogArgs
    workflowSteps?: boolean | GroupBrandCountOutputTypeCountWorkflowStepsArgs
  }

  // Custom InputTypes
  /**
   * GroupBrandCountOutputType without action
   */
  export type GroupBrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrandCountOutputType
     */
    select?: GroupBrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupBrandCountOutputType without action
   */
  export type GroupBrandCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }

  /**
   * GroupBrandCountOutputType without action
   */
  export type GroupBrandCountOutputTypeCountSkuCatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuCatalogWhereInput
  }

  /**
   * GroupBrandCountOutputType without action
   */
  export type GroupBrandCountOutputTypeCountWorkflowStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWorkflowStepWhereInput
  }


  /**
   * Count Type StoreCountOutputType
   */

  export type StoreCountOutputType = {
    budgetDetails: number
    productAllocations: number
    salesHistory: number
    sizeCurveRecommendations: number
    skuPerformance: number
  }

  export type StoreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetails?: boolean | StoreCountOutputTypeCountBudgetDetailsArgs
    productAllocations?: boolean | StoreCountOutputTypeCountProductAllocationsArgs
    salesHistory?: boolean | StoreCountOutputTypeCountSalesHistoryArgs
    sizeCurveRecommendations?: boolean | StoreCountOutputTypeCountSizeCurveRecommendationsArgs
    skuPerformance?: boolean | StoreCountOutputTypeCountSkuPerformanceArgs
  }

  // Custom InputTypes
  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountBudgetDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetDetailWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountProductAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAllocationWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSalesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesHistoryWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSizeCurveRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeCurveRecommendationWhereInput
  }

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeCountSkuPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuPerformanceWhereInput
  }


  /**
   * Count Type CollectionCountOutputType
   */

  export type CollectionCountOutputType = {
    planningDetails: number
  }

  export type CollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planningDetails?: boolean | CollectionCountOutputTypeCountPlanningDetailsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountPlanningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningDetailWhereInput
  }


  /**
   * Count Type GenderCountOutputType
   */

  export type GenderCountOutputType = {
    categories: number
    planningDetails: number
  }

  export type GenderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | GenderCountOutputTypeCountCategoriesArgs
    planningDetails?: boolean | GenderCountOutputTypeCountPlanningDetailsArgs
  }

  // Custom InputTypes
  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenderCountOutputType
     */
    select?: GenderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeCountPlanningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningDetailWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    subCategories: number
    planningDetails: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subCategories?: boolean | CategoryCountOutputTypeCountSubCategoriesArgs
    planningDetails?: boolean | CategoryCountOutputTypeCountPlanningDetailsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPlanningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningDetailWhereInput
  }


  /**
   * Count Type SubCategoryCountOutputType
   */

  export type SubCategoryCountOutputType = {
    planningDetails: number
  }

  export type SubCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planningDetails?: boolean | SubCategoryCountOutputTypeCountPlanningDetailsArgs
  }

  // Custom InputTypes
  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     */
    select?: SubCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeCountPlanningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningDetailWhereInput
  }


  /**
   * Count Type SkuCatalogCountOutputType
   */

  export type SkuCatalogCountOutputType = {
    products: number
    sizeCurveRecommendations: number
    skuPerformance: number
    skuRecommendations: number
  }

  export type SkuCatalogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SkuCatalogCountOutputTypeCountProductsArgs
    sizeCurveRecommendations?: boolean | SkuCatalogCountOutputTypeCountSizeCurveRecommendationsArgs
    skuPerformance?: boolean | SkuCatalogCountOutputTypeCountSkuPerformanceArgs
    skuRecommendations?: boolean | SkuCatalogCountOutputTypeCountSkuRecommendationsArgs
  }

  // Custom InputTypes
  /**
   * SkuCatalogCountOutputType without action
   */
  export type SkuCatalogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalogCountOutputType
     */
    select?: SkuCatalogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkuCatalogCountOutputType without action
   */
  export type SkuCatalogCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalProductWhereInput
  }

  /**
   * SkuCatalogCountOutputType without action
   */
  export type SkuCatalogCountOutputTypeCountSizeCurveRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeCurveRecommendationWhereInput
  }

  /**
   * SkuCatalogCountOutputType without action
   */
  export type SkuCatalogCountOutputTypeCountSkuPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuPerformanceWhereInput
  }

  /**
   * SkuCatalogCountOutputType without action
   */
  export type SkuCatalogCountOutputTypeCountSkuRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuRecommendationWhereInput
  }


  /**
   * Count Type BudgetCountOutputType
   */

  export type BudgetCountOutputType = {
    details: number
    proposals: number
    budgetAlerts: number
    budgetSnapshots: number
  }

  export type BudgetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | BudgetCountOutputTypeCountDetailsArgs
    proposals?: boolean | BudgetCountOutputTypeCountProposalsArgs
    budgetAlerts?: boolean | BudgetCountOutputTypeCountBudgetAlertsArgs
    budgetSnapshots?: boolean | BudgetCountOutputTypeCountBudgetSnapshotsArgs
  }

  // Custom InputTypes
  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetCountOutputType
     */
    select?: BudgetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetDetailWhereInput
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountBudgetAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetAlertWhereInput
  }

  /**
   * BudgetCountOutputType without action
   */
  export type BudgetCountOutputTypeCountBudgetSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetSnapshotWhereInput
  }


  /**
   * Count Type BudgetDetailCountOutputType
   */

  export type BudgetDetailCountOutputType = {
    planningVersions: number
    allocationRecommendations: number
    skuRecommendations: number
  }

  export type BudgetDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planningVersions?: boolean | BudgetDetailCountOutputTypeCountPlanningVersionsArgs
    allocationRecommendations?: boolean | BudgetDetailCountOutputTypeCountAllocationRecommendationsArgs
    skuRecommendations?: boolean | BudgetDetailCountOutputTypeCountSkuRecommendationsArgs
  }

  // Custom InputTypes
  /**
   * BudgetDetailCountOutputType without action
   */
  export type BudgetDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetailCountOutputType
     */
    select?: BudgetDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetDetailCountOutputType without action
   */
  export type BudgetDetailCountOutputTypeCountPlanningVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningVersionWhereInput
  }

  /**
   * BudgetDetailCountOutputType without action
   */
  export type BudgetDetailCountOutputTypeCountAllocationRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationRecommendationWhereInput
  }

  /**
   * BudgetDetailCountOutputType without action
   */
  export type BudgetDetailCountOutputTypeCountSkuRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuRecommendationWhereInput
  }


  /**
   * Count Type PlanningVersionCountOutputType
   */

  export type PlanningVersionCountOutputType = {
    details: number
    proposals: number
  }

  export type PlanningVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | PlanningVersionCountOutputTypeCountDetailsArgs
    proposals?: boolean | PlanningVersionCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * PlanningVersionCountOutputType without action
   */
  export type PlanningVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersionCountOutputType
     */
    select?: PlanningVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanningVersionCountOutputType without action
   */
  export type PlanningVersionCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningDetailWhereInput
  }

  /**
   * PlanningVersionCountOutputType without action
   */
  export type PlanningVersionCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type ProposalCountOutputType
   */

  export type ProposalCountOutputType = {
    products: number
  }

  export type ProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProposalCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalCountOutputType
     */
    select?: ProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalCountOutputType without action
   */
  export type ProposalCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalProductWhereInput
  }


  /**
   * Count Type ProposalProductCountOutputType
   */

  export type ProposalProductCountOutputType = {
    allocations: number
  }

  export type ProposalProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    allocations?: boolean | ProposalProductCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * ProposalProductCountOutputType without action
   */
  export type ProposalProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProductCountOutputType
     */
    select?: ProposalProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProposalProductCountOutputType without action
   */
  export type ProposalProductCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAllocationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    roleId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    roleId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    roleId: number
    storeAccess: number
    brandAccess: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    roleId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    roleId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    roleId?: true
    storeAccess?: true
    brandAccess?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess: string[]
    brandAccess: string[]
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roleId?: boolean
    storeAccess?: boolean
    brandAccess?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    createdBudgets?: boolean | User$createdBudgetsArgs<ExtArgs>
    createdPlannings?: boolean | User$createdPlanningsArgs<ExtArgs>
    createdProposals?: boolean | User$createdProposalsArgs<ExtArgs>
    approvalDecisions?: boolean | User$approvalDecisionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    workflowSteps?: boolean | User$workflowStepsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roleId?: boolean
    storeAccess?: boolean
    brandAccess?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    roleId?: boolean
    storeAccess?: boolean
    brandAccess?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    createdBudgets?: boolean | User$createdBudgetsArgs<ExtArgs>
    createdPlannings?: boolean | User$createdPlanningsArgs<ExtArgs>
    createdProposals?: boolean | User$createdProposalsArgs<ExtArgs>
    approvalDecisions?: boolean | User$approvalDecisionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    workflowSteps?: boolean | User$workflowStepsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      createdBudgets: Prisma.$BudgetPayload<ExtArgs>[]
      createdPlannings: Prisma.$PlanningVersionPayload<ExtArgs>[]
      createdProposals: Prisma.$ProposalPayload<ExtArgs>[]
      approvalDecisions: Prisma.$ApprovalPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      workflowSteps: Prisma.$ApprovalWorkflowStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      passwordHash: string
      roleId: string
      storeAccess: string[]
      brandAccess: string[]
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBudgets<T extends User$createdBudgetsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBudgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    createdPlannings<T extends User$createdPlanningsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPlanningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findMany"> | Null>
    createdProposals<T extends User$createdProposalsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdProposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany"> | Null>
    approvalDecisions<T extends User$approvalDecisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalDecisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    workflowSteps<T extends User$workflowStepsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly storeAccess: FieldRef<"User", 'String[]'>
    readonly brandAccess: FieldRef<"User", 'String[]'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.createdBudgets
   */
  export type User$createdBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * User.createdPlannings
   */
  export type User$createdPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    where?: PlanningVersionWhereInput
    orderBy?: PlanningVersionOrderByWithRelationInput | PlanningVersionOrderByWithRelationInput[]
    cursor?: PlanningVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningVersionScalarFieldEnum | PlanningVersionScalarFieldEnum[]
  }

  /**
   * User.createdProposals
   */
  export type User$createdProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * User.approvalDecisions
   */
  export type User$approvalDecisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.workflowSteps
   */
  export type User$workflowStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    where?: ApprovalWorkflowStepWhereInput
    orderBy?: ApprovalWorkflowStepOrderByWithRelationInput | ApprovalWorkflowStepOrderByWithRelationInput[]
    cursor?: ApprovalWorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalWorkflowStepScalarFieldEnum | ApprovalWorkflowStepScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: JsonValue
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: Prisma.JsonValue
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model GroupBrand
   */

  export type AggregateGroupBrand = {
    _count: GroupBrandCountAggregateOutputType | null
    _avg: GroupBrandAvgAggregateOutputType | null
    _sum: GroupBrandSumAggregateOutputType | null
    _min: GroupBrandMinAggregateOutputType | null
    _max: GroupBrandMaxAggregateOutputType | null
  }

  export type GroupBrandAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type GroupBrandSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type GroupBrandMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    groupId: string | null
    isActive: boolean | null
    sortOrder: number | null
  }

  export type GroupBrandMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    groupId: string | null
    isActive: boolean | null
    sortOrder: number | null
  }

  export type GroupBrandCountAggregateOutputType = {
    id: number
    code: number
    name: number
    groupId: number
    colorConfig: number
    isActive: number
    sortOrder: number
    _all: number
  }


  export type GroupBrandAvgAggregateInputType = {
    sortOrder?: true
  }

  export type GroupBrandSumAggregateInputType = {
    sortOrder?: true
  }

  export type GroupBrandMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    groupId?: true
    isActive?: true
    sortOrder?: true
  }

  export type GroupBrandMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    groupId?: true
    isActive?: true
    sortOrder?: true
  }

  export type GroupBrandCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    groupId?: true
    colorConfig?: true
    isActive?: true
    sortOrder?: true
    _all?: true
  }

  export type GroupBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupBrand to aggregate.
     */
    where?: GroupBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBrands to fetch.
     */
    orderBy?: GroupBrandOrderByWithRelationInput | GroupBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupBrands
    **/
    _count?: true | GroupBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupBrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupBrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupBrandMaxAggregateInputType
  }

  export type GetGroupBrandAggregateType<T extends GroupBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupBrand[P]>
      : GetScalarType<T[P], AggregateGroupBrand[P]>
  }




  export type GroupBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupBrandWhereInput
    orderBy?: GroupBrandOrderByWithAggregationInput | GroupBrandOrderByWithAggregationInput[]
    by: GroupBrandScalarFieldEnum[] | GroupBrandScalarFieldEnum
    having?: GroupBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupBrandCountAggregateInputType | true
    _avg?: GroupBrandAvgAggregateInputType
    _sum?: GroupBrandSumAggregateInputType
    _min?: GroupBrandMinAggregateInputType
    _max?: GroupBrandMaxAggregateInputType
  }

  export type GroupBrandGroupByOutputType = {
    id: string
    code: string
    name: string
    groupId: string
    colorConfig: JsonValue | null
    isActive: boolean
    sortOrder: number
    _count: GroupBrandCountAggregateOutputType | null
    _avg: GroupBrandAvgAggregateOutputType | null
    _sum: GroupBrandSumAggregateOutputType | null
    _min: GroupBrandMinAggregateOutputType | null
    _max: GroupBrandMaxAggregateOutputType | null
  }

  type GetGroupBrandGroupByPayload<T extends GroupBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupBrandGroupByOutputType[P]>
            : GetScalarType<T[P], GroupBrandGroupByOutputType[P]>
        }
      >
    >


  export type GroupBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    groupId?: boolean
    colorConfig?: boolean
    isActive?: boolean
    sortOrder?: boolean
    budgets?: boolean | GroupBrand$budgetsArgs<ExtArgs>
    skuCatalog?: boolean | GroupBrand$skuCatalogArgs<ExtArgs>
    workflowSteps?: boolean | GroupBrand$workflowStepsArgs<ExtArgs>
    _count?: boolean | GroupBrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupBrand"]>

  export type GroupBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    groupId?: boolean
    colorConfig?: boolean
    isActive?: boolean
    sortOrder?: boolean
  }, ExtArgs["result"]["groupBrand"]>

  export type GroupBrandSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    groupId?: boolean
    colorConfig?: boolean
    isActive?: boolean
    sortOrder?: boolean
  }

  export type GroupBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgets?: boolean | GroupBrand$budgetsArgs<ExtArgs>
    skuCatalog?: boolean | GroupBrand$skuCatalogArgs<ExtArgs>
    workflowSteps?: boolean | GroupBrand$workflowStepsArgs<ExtArgs>
    _count?: boolean | GroupBrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupBrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GroupBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupBrand"
    objects: {
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
      skuCatalog: Prisma.$SkuCatalogPayload<ExtArgs>[]
      workflowSteps: Prisma.$ApprovalWorkflowStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      groupId: string
      colorConfig: Prisma.JsonValue | null
      isActive: boolean
      sortOrder: number
    }, ExtArgs["result"]["groupBrand"]>
    composites: {}
  }

  type GroupBrandGetPayload<S extends boolean | null | undefined | GroupBrandDefaultArgs> = $Result.GetResult<Prisma.$GroupBrandPayload, S>

  type GroupBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupBrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupBrandCountAggregateInputType | true
    }

  export interface GroupBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupBrand'], meta: { name: 'GroupBrand' } }
    /**
     * Find zero or one GroupBrand that matches the filter.
     * @param {GroupBrandFindUniqueArgs} args - Arguments to find a GroupBrand
     * @example
     * // Get one GroupBrand
     * const groupBrand = await prisma.groupBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupBrandFindUniqueArgs>(args: SelectSubset<T, GroupBrandFindUniqueArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupBrand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupBrandFindUniqueOrThrowArgs} args - Arguments to find a GroupBrand
     * @example
     * // Get one GroupBrand
     * const groupBrand = await prisma.groupBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandFindFirstArgs} args - Arguments to find a GroupBrand
     * @example
     * // Get one GroupBrand
     * const groupBrand = await prisma.groupBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupBrandFindFirstArgs>(args?: SelectSubset<T, GroupBrandFindFirstArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandFindFirstOrThrowArgs} args - Arguments to find a GroupBrand
     * @example
     * // Get one GroupBrand
     * const groupBrand = await prisma.groupBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupBrands
     * const groupBrands = await prisma.groupBrand.findMany()
     * 
     * // Get first 10 GroupBrands
     * const groupBrands = await prisma.groupBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupBrandWithIdOnly = await prisma.groupBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupBrandFindManyArgs>(args?: SelectSubset<T, GroupBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupBrand.
     * @param {GroupBrandCreateArgs} args - Arguments to create a GroupBrand.
     * @example
     * // Create one GroupBrand
     * const GroupBrand = await prisma.groupBrand.create({
     *   data: {
     *     // ... data to create a GroupBrand
     *   }
     * })
     * 
     */
    create<T extends GroupBrandCreateArgs>(args: SelectSubset<T, GroupBrandCreateArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupBrands.
     * @param {GroupBrandCreateManyArgs} args - Arguments to create many GroupBrands.
     * @example
     * // Create many GroupBrands
     * const groupBrand = await prisma.groupBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupBrandCreateManyArgs>(args?: SelectSubset<T, GroupBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupBrands and returns the data saved in the database.
     * @param {GroupBrandCreateManyAndReturnArgs} args - Arguments to create many GroupBrands.
     * @example
     * // Create many GroupBrands
     * const groupBrand = await prisma.groupBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupBrands and only return the `id`
     * const groupBrandWithIdOnly = await prisma.groupBrand.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupBrand.
     * @param {GroupBrandDeleteArgs} args - Arguments to delete one GroupBrand.
     * @example
     * // Delete one GroupBrand
     * const GroupBrand = await prisma.groupBrand.delete({
     *   where: {
     *     // ... filter to delete one GroupBrand
     *   }
     * })
     * 
     */
    delete<T extends GroupBrandDeleteArgs>(args: SelectSubset<T, GroupBrandDeleteArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupBrand.
     * @param {GroupBrandUpdateArgs} args - Arguments to update one GroupBrand.
     * @example
     * // Update one GroupBrand
     * const groupBrand = await prisma.groupBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupBrandUpdateArgs>(args: SelectSubset<T, GroupBrandUpdateArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupBrands.
     * @param {GroupBrandDeleteManyArgs} args - Arguments to filter GroupBrands to delete.
     * @example
     * // Delete a few GroupBrands
     * const { count } = await prisma.groupBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupBrandDeleteManyArgs>(args?: SelectSubset<T, GroupBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupBrands
     * const groupBrand = await prisma.groupBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupBrandUpdateManyArgs>(args: SelectSubset<T, GroupBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupBrand.
     * @param {GroupBrandUpsertArgs} args - Arguments to update or create a GroupBrand.
     * @example
     * // Update or create a GroupBrand
     * const groupBrand = await prisma.groupBrand.upsert({
     *   create: {
     *     // ... data to create a GroupBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupBrand we want to update
     *   }
     * })
     */
    upsert<T extends GroupBrandUpsertArgs>(args: SelectSubset<T, GroupBrandUpsertArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandCountArgs} args - Arguments to filter GroupBrands to count.
     * @example
     * // Count the number of GroupBrands
     * const count = await prisma.groupBrand.count({
     *   where: {
     *     // ... the filter for the GroupBrands we want to count
     *   }
     * })
    **/
    count<T extends GroupBrandCountArgs>(
      args?: Subset<T, GroupBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupBrandAggregateArgs>(args: Subset<T, GroupBrandAggregateArgs>): Prisma.PrismaPromise<GetGroupBrandAggregateType<T>>

    /**
     * Group by GroupBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupBrandGroupByArgs['orderBy'] }
        : { orderBy?: GroupBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupBrand model
   */
  readonly fields: GroupBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budgets<T extends GroupBrand$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, GroupBrand$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany"> | Null>
    skuCatalog<T extends GroupBrand$skuCatalogArgs<ExtArgs> = {}>(args?: Subset<T, GroupBrand$skuCatalogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findMany"> | Null>
    workflowSteps<T extends GroupBrand$workflowStepsArgs<ExtArgs> = {}>(args?: Subset<T, GroupBrand$workflowStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupBrand model
   */ 
  interface GroupBrandFieldRefs {
    readonly id: FieldRef<"GroupBrand", 'String'>
    readonly code: FieldRef<"GroupBrand", 'String'>
    readonly name: FieldRef<"GroupBrand", 'String'>
    readonly groupId: FieldRef<"GroupBrand", 'String'>
    readonly colorConfig: FieldRef<"GroupBrand", 'Json'>
    readonly isActive: FieldRef<"GroupBrand", 'Boolean'>
    readonly sortOrder: FieldRef<"GroupBrand", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GroupBrand findUnique
   */
  export type GroupBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * Filter, which GroupBrand to fetch.
     */
    where: GroupBrandWhereUniqueInput
  }

  /**
   * GroupBrand findUniqueOrThrow
   */
  export type GroupBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * Filter, which GroupBrand to fetch.
     */
    where: GroupBrandWhereUniqueInput
  }

  /**
   * GroupBrand findFirst
   */
  export type GroupBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * Filter, which GroupBrand to fetch.
     */
    where?: GroupBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBrands to fetch.
     */
    orderBy?: GroupBrandOrderByWithRelationInput | GroupBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupBrands.
     */
    cursor?: GroupBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupBrands.
     */
    distinct?: GroupBrandScalarFieldEnum | GroupBrandScalarFieldEnum[]
  }

  /**
   * GroupBrand findFirstOrThrow
   */
  export type GroupBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * Filter, which GroupBrand to fetch.
     */
    where?: GroupBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBrands to fetch.
     */
    orderBy?: GroupBrandOrderByWithRelationInput | GroupBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupBrands.
     */
    cursor?: GroupBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupBrands.
     */
    distinct?: GroupBrandScalarFieldEnum | GroupBrandScalarFieldEnum[]
  }

  /**
   * GroupBrand findMany
   */
  export type GroupBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * Filter, which GroupBrands to fetch.
     */
    where?: GroupBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBrands to fetch.
     */
    orderBy?: GroupBrandOrderByWithRelationInput | GroupBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupBrands.
     */
    cursor?: GroupBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBrands.
     */
    skip?: number
    distinct?: GroupBrandScalarFieldEnum | GroupBrandScalarFieldEnum[]
  }

  /**
   * GroupBrand create
   */
  export type GroupBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupBrand.
     */
    data: XOR<GroupBrandCreateInput, GroupBrandUncheckedCreateInput>
  }

  /**
   * GroupBrand createMany
   */
  export type GroupBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupBrands.
     */
    data: GroupBrandCreateManyInput | GroupBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupBrand createManyAndReturn
   */
  export type GroupBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupBrands.
     */
    data: GroupBrandCreateManyInput | GroupBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupBrand update
   */
  export type GroupBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupBrand.
     */
    data: XOR<GroupBrandUpdateInput, GroupBrandUncheckedUpdateInput>
    /**
     * Choose, which GroupBrand to update.
     */
    where: GroupBrandWhereUniqueInput
  }

  /**
   * GroupBrand updateMany
   */
  export type GroupBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupBrands.
     */
    data: XOR<GroupBrandUpdateManyMutationInput, GroupBrandUncheckedUpdateManyInput>
    /**
     * Filter which GroupBrands to update
     */
    where?: GroupBrandWhereInput
  }

  /**
   * GroupBrand upsert
   */
  export type GroupBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupBrand to update in case it exists.
     */
    where: GroupBrandWhereUniqueInput
    /**
     * In case the GroupBrand found by the `where` argument doesn't exist, create a new GroupBrand with this data.
     */
    create: XOR<GroupBrandCreateInput, GroupBrandUncheckedCreateInput>
    /**
     * In case the GroupBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupBrandUpdateInput, GroupBrandUncheckedUpdateInput>
  }

  /**
   * GroupBrand delete
   */
  export type GroupBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    /**
     * Filter which GroupBrand to delete.
     */
    where: GroupBrandWhereUniqueInput
  }

  /**
   * GroupBrand deleteMany
   */
  export type GroupBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupBrands to delete
     */
    where?: GroupBrandWhereInput
  }

  /**
   * GroupBrand.budgets
   */
  export type GroupBrand$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * GroupBrand.skuCatalog
   */
  export type GroupBrand$skuCatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    where?: SkuCatalogWhereInput
    orderBy?: SkuCatalogOrderByWithRelationInput | SkuCatalogOrderByWithRelationInput[]
    cursor?: SkuCatalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuCatalogScalarFieldEnum | SkuCatalogScalarFieldEnum[]
  }

  /**
   * GroupBrand.workflowSteps
   */
  export type GroupBrand$workflowStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    where?: ApprovalWorkflowStepWhereInput
    orderBy?: ApprovalWorkflowStepOrderByWithRelationInput | ApprovalWorkflowStepOrderByWithRelationInput[]
    cursor?: ApprovalWorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalWorkflowStepScalarFieldEnum | ApprovalWorkflowStepScalarFieldEnum[]
  }

  /**
   * GroupBrand without action
   */
  export type GroupBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    region: string | null
    isActive: boolean | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    region: string | null
    isActive: boolean | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    code: number
    name: number
    region: number
    isActive: number
    _all: number
  }


  export type StoreMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    region?: true
    isActive?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    region?: true
    isActive?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    region?: true
    isActive?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    code: string
    name: string
    region: string | null
    isActive: boolean
    _count: StoreCountAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
    budgetDetails?: boolean | Store$budgetDetailsArgs<ExtArgs>
    productAllocations?: boolean | Store$productAllocationsArgs<ExtArgs>
    salesHistory?: boolean | Store$salesHistoryArgs<ExtArgs>
    sizeCurveRecommendations?: boolean | Store$sizeCurveRecommendationsArgs<ExtArgs>
    skuPerformance?: boolean | Store$skuPerformanceArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    region?: boolean
    isActive?: boolean
  }

  export type StoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetails?: boolean | Store$budgetDetailsArgs<ExtArgs>
    productAllocations?: boolean | Store$productAllocationsArgs<ExtArgs>
    salesHistory?: boolean | Store$salesHistoryArgs<ExtArgs>
    sizeCurveRecommendations?: boolean | Store$sizeCurveRecommendationsArgs<ExtArgs>
    skuPerformance?: boolean | Store$skuPerformanceArgs<ExtArgs>
    _count?: boolean | StoreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {
      budgetDetails: Prisma.$BudgetDetailPayload<ExtArgs>[]
      productAllocations: Prisma.$ProductAllocationPayload<ExtArgs>[]
      salesHistory: Prisma.$SalesHistoryPayload<ExtArgs>[]
      sizeCurveRecommendations: Prisma.$SizeCurveRecommendationPayload<ExtArgs>[]
      skuPerformance: Prisma.$SkuPerformancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      region: string | null
      isActive: boolean
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budgetDetails<T extends Store$budgetDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Store$budgetDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findMany"> | Null>
    productAllocations<T extends Store$productAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Store$productAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findMany"> | Null>
    salesHistory<T extends Store$salesHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Store$salesHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    sizeCurveRecommendations<T extends Store$sizeCurveRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, Store$sizeCurveRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    skuPerformance<T extends Store$skuPerformanceArgs<ExtArgs> = {}>(args?: Subset<T, Store$skuPerformanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */ 
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly code: FieldRef<"Store", 'String'>
    readonly name: FieldRef<"Store", 'String'>
    readonly region: FieldRef<"Store", 'String'>
    readonly isActive: FieldRef<"Store", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
  }

  /**
   * Store.budgetDetails
   */
  export type Store$budgetDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    where?: BudgetDetailWhereInput
    orderBy?: BudgetDetailOrderByWithRelationInput | BudgetDetailOrderByWithRelationInput[]
    cursor?: BudgetDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetDetailScalarFieldEnum | BudgetDetailScalarFieldEnum[]
  }

  /**
   * Store.productAllocations
   */
  export type Store$productAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    where?: ProductAllocationWhereInput
    orderBy?: ProductAllocationOrderByWithRelationInput | ProductAllocationOrderByWithRelationInput[]
    cursor?: ProductAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAllocationScalarFieldEnum | ProductAllocationScalarFieldEnum[]
  }

  /**
   * Store.salesHistory
   */
  export type Store$salesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    where?: SalesHistoryWhereInput
    orderBy?: SalesHistoryOrderByWithRelationInput | SalesHistoryOrderByWithRelationInput[]
    cursor?: SalesHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesHistoryScalarFieldEnum | SalesHistoryScalarFieldEnum[]
  }

  /**
   * Store.sizeCurveRecommendations
   */
  export type Store$sizeCurveRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    where?: SizeCurveRecommendationWhereInput
    orderBy?: SizeCurveRecommendationOrderByWithRelationInput | SizeCurveRecommendationOrderByWithRelationInput[]
    cursor?: SizeCurveRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SizeCurveRecommendationScalarFieldEnum | SizeCurveRecommendationScalarFieldEnum[]
  }

  /**
   * Store.skuPerformance
   */
  export type Store$skuPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    where?: SkuPerformanceWhereInput
    orderBy?: SkuPerformanceOrderByWithRelationInput | SkuPerformanceOrderByWithRelationInput[]
    cursor?: SkuPerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuPerformanceScalarFieldEnum | SkuPerformanceScalarFieldEnum[]
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
  }


  /**
   * Model Collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    _all: number
  }


  export type CollectionMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    _all?: true
  }

  export type CollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collection to aggregate.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type CollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithAggregationInput | CollectionOrderByWithAggregationInput[]
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum
    having?: CollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }

  export type CollectionGroupByOutputType = {
    id: string
    name: string
    isActive: boolean
    _count: CollectionCountAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type CollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    planningDetails?: boolean | Collection$planningDetailsArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
  }

  export type CollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planningDetails?: boolean | Collection$planningDetailsArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Collection"
    objects: {
      planningDetails: Prisma.$PlanningDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isActive: boolean
    }, ExtArgs["result"]["collection"]>
    composites: {}
  }

  type CollectionGetPayload<S extends boolean | null | undefined | CollectionDefaultArgs> = $Result.GetResult<Prisma.$CollectionPayload, S>

  type CollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CollectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface CollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collection'], meta: { name: 'Collection' } }
    /**
     * Find zero or one Collection that matches the filter.
     * @param {CollectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionFindUniqueArgs>(args: SelectSubset<T, CollectionFindUniqueArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CollectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionFindFirstArgs>(args?: SelectSubset<T, CollectionFindFirstArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionFindManyArgs>(args?: SelectSubset<T, CollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Collection.
     * @param {CollectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
     */
    create<T extends CollectionCreateArgs>(args: SelectSubset<T, CollectionCreateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Collections.
     * @param {CollectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCreateManyArgs>(args?: SelectSubset<T, CollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {CollectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Collection.
     * @param {CollectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
     */
    delete<T extends CollectionDeleteArgs>(args: SelectSubset<T, CollectionDeleteArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Collection.
     * @param {CollectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionUpdateArgs>(args: SelectSubset<T, CollectionUpdateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Collections.
     * @param {CollectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionDeleteManyArgs>(args?: SelectSubset<T, CollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionUpdateManyArgs>(args: SelectSubset<T, CollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection.
     * @param {CollectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends CollectionUpsertArgs>(args: SelectSubset<T, CollectionUpsertArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends CollectionCountArgs>(
      args?: Subset<T, CollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Collection model
   */
  readonly fields: CollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planningDetails<T extends Collection$planningDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Collection$planningDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Collection model
   */ 
  interface CollectionFieldRefs {
    readonly id: FieldRef<"Collection", 'String'>
    readonly name: FieldRef<"Collection", 'String'>
    readonly isActive: FieldRef<"Collection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Collection findUnique
   */
  export type CollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findUniqueOrThrow
   */
  export type CollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findFirst
   */
  export type CollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findFirstOrThrow
   */
  export type CollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findMany
   */
  export type CollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collections to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection create
   */
  export type CollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Collection.
     */
    data: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
  }

  /**
   * Collection createMany
   */
  export type CollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collection createManyAndReturn
   */
  export type CollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collection update
   */
  export type CollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Collection.
     */
    data: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
    /**
     * Choose, which Collection to update.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection updateMany
   */
  export type CollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
  }

  /**
   * Collection upsert
   */
  export type CollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Collection to update in case it exists.
     */
    where: CollectionWhereUniqueInput
    /**
     * In case the Collection found by the `where` argument doesn't exist, create a new Collection with this data.
     */
    create: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
    /**
     * In case the Collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
  }

  /**
   * Collection delete
   */
  export type CollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter which Collection to delete.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection deleteMany
   */
  export type CollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collections to delete
     */
    where?: CollectionWhereInput
  }

  /**
   * Collection.planningDetails
   */
  export type Collection$planningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    where?: PlanningDetailWhereInput
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    cursor?: PlanningDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * Collection without action
   */
  export type CollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
  }


  /**
   * Model Gender
   */

  export type AggregateGender = {
    _count: GenderCountAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  export type GenderMinAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
  }

  export type GenderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
  }

  export type GenderCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    _all: number
  }


  export type GenderMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type GenderMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
  }

  export type GenderCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    _all?: true
  }

  export type GenderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gender to aggregate.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genders
    **/
    _count?: true | GenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenderMaxAggregateInputType
  }

  export type GetGenderAggregateType<T extends GenderAggregateArgs> = {
        [P in keyof T & keyof AggregateGender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGender[P]>
      : GetScalarType<T[P], AggregateGender[P]>
  }




  export type GenderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenderWhereInput
    orderBy?: GenderOrderByWithAggregationInput | GenderOrderByWithAggregationInput[]
    by: GenderScalarFieldEnum[] | GenderScalarFieldEnum
    having?: GenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenderCountAggregateInputType | true
    _min?: GenderMinAggregateInputType
    _max?: GenderMaxAggregateInputType
  }

  export type GenderGroupByOutputType = {
    id: string
    name: string
    isActive: boolean
    _count: GenderCountAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  type GetGenderGroupByPayload<T extends GenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenderGroupByOutputType[P]>
            : GetScalarType<T[P], GenderGroupByOutputType[P]>
        }
      >
    >


  export type GenderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    categories?: boolean | Gender$categoriesArgs<ExtArgs>
    planningDetails?: boolean | Gender$planningDetailsArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gender"]>

  export type GenderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["gender"]>

  export type GenderSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
  }

  export type GenderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Gender$categoriesArgs<ExtArgs>
    planningDetails?: boolean | Gender$planningDetailsArgs<ExtArgs>
    _count?: boolean | GenderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gender"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      planningDetails: Prisma.$PlanningDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isActive: boolean
    }, ExtArgs["result"]["gender"]>
    composites: {}
  }

  type GenderGetPayload<S extends boolean | null | undefined | GenderDefaultArgs> = $Result.GetResult<Prisma.$GenderPayload, S>

  type GenderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GenderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GenderCountAggregateInputType | true
    }

  export interface GenderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gender'], meta: { name: 'Gender' } }
    /**
     * Find zero or one Gender that matches the filter.
     * @param {GenderFindUniqueArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenderFindUniqueArgs>(args: SelectSubset<T, GenderFindUniqueArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gender that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GenderFindUniqueOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenderFindUniqueOrThrowArgs>(args: SelectSubset<T, GenderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenderFindFirstArgs>(args?: SelectSubset<T, GenderFindFirstArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenderFindFirstOrThrowArgs>(args?: SelectSubset<T, GenderFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genders
     * const genders = await prisma.gender.findMany()
     * 
     * // Get first 10 Genders
     * const genders = await prisma.gender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genderWithIdOnly = await prisma.gender.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenderFindManyArgs>(args?: SelectSubset<T, GenderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gender.
     * @param {GenderCreateArgs} args - Arguments to create a Gender.
     * @example
     * // Create one Gender
     * const Gender = await prisma.gender.create({
     *   data: {
     *     // ... data to create a Gender
     *   }
     * })
     * 
     */
    create<T extends GenderCreateArgs>(args: SelectSubset<T, GenderCreateArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Genders.
     * @param {GenderCreateManyArgs} args - Arguments to create many Genders.
     * @example
     * // Create many Genders
     * const gender = await prisma.gender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenderCreateManyArgs>(args?: SelectSubset<T, GenderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genders and returns the data saved in the database.
     * @param {GenderCreateManyAndReturnArgs} args - Arguments to create many Genders.
     * @example
     * // Create many Genders
     * const gender = await prisma.gender.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genders and only return the `id`
     * const genderWithIdOnly = await prisma.gender.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenderCreateManyAndReturnArgs>(args?: SelectSubset<T, GenderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gender.
     * @param {GenderDeleteArgs} args - Arguments to delete one Gender.
     * @example
     * // Delete one Gender
     * const Gender = await prisma.gender.delete({
     *   where: {
     *     // ... filter to delete one Gender
     *   }
     * })
     * 
     */
    delete<T extends GenderDeleteArgs>(args: SelectSubset<T, GenderDeleteArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gender.
     * @param {GenderUpdateArgs} args - Arguments to update one Gender.
     * @example
     * // Update one Gender
     * const gender = await prisma.gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenderUpdateArgs>(args: SelectSubset<T, GenderUpdateArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Genders.
     * @param {GenderDeleteManyArgs} args - Arguments to filter Genders to delete.
     * @example
     * // Delete a few Genders
     * const { count } = await prisma.gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenderDeleteManyArgs>(args?: SelectSubset<T, GenderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenderUpdateManyArgs>(args: SelectSubset<T, GenderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gender.
     * @param {GenderUpsertArgs} args - Arguments to update or create a Gender.
     * @example
     * // Update or create a Gender
     * const gender = await prisma.gender.upsert({
     *   create: {
     *     // ... data to create a Gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gender we want to update
     *   }
     * })
     */
    upsert<T extends GenderUpsertArgs>(args: SelectSubset<T, GenderUpsertArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderCountArgs} args - Arguments to filter Genders to count.
     * @example
     * // Count the number of Genders
     * const count = await prisma.gender.count({
     *   where: {
     *     // ... the filter for the Genders we want to count
     *   }
     * })
    **/
    count<T extends GenderCountArgs>(
      args?: Subset<T, GenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenderAggregateArgs>(args: Subset<T, GenderAggregateArgs>): Prisma.PrismaPromise<GetGenderAggregateType<T>>

    /**
     * Group by Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenderGroupByArgs['orderBy'] }
        : { orderBy?: GenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gender model
   */
  readonly fields: GenderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Gender$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Gender$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    planningDetails<T extends Gender$planningDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Gender$planningDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gender model
   */ 
  interface GenderFieldRefs {
    readonly id: FieldRef<"Gender", 'String'>
    readonly name: FieldRef<"Gender", 'String'>
    readonly isActive: FieldRef<"Gender", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Gender findUnique
   */
  export type GenderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender findUniqueOrThrow
   */
  export type GenderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender findFirst
   */
  export type GenderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * Gender findFirstOrThrow
   */
  export type GenderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * Gender findMany
   */
  export type GenderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter, which Genders to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: GenderOrderByWithRelationInput | GenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    distinct?: GenderScalarFieldEnum | GenderScalarFieldEnum[]
  }

  /**
   * Gender create
   */
  export type GenderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The data needed to create a Gender.
     */
    data: XOR<GenderCreateInput, GenderUncheckedCreateInput>
  }

  /**
   * Gender createMany
   */
  export type GenderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genders.
     */
    data: GenderCreateManyInput | GenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gender createManyAndReturn
   */
  export type GenderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Genders.
     */
    data: GenderCreateManyInput | GenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gender update
   */
  export type GenderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The data needed to update a Gender.
     */
    data: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
    /**
     * Choose, which Gender to update.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender updateMany
   */
  export type GenderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genders.
     */
    data: XOR<GenderUpdateManyMutationInput, GenderUncheckedUpdateManyInput>
    /**
     * Filter which Genders to update
     */
    where?: GenderWhereInput
  }

  /**
   * Gender upsert
   */
  export type GenderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * The filter to search for the Gender to update in case it exists.
     */
    where: GenderWhereUniqueInput
    /**
     * In case the Gender found by the `where` argument doesn't exist, create a new Gender with this data.
     */
    create: XOR<GenderCreateInput, GenderUncheckedCreateInput>
    /**
     * In case the Gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
  }

  /**
   * Gender delete
   */
  export type GenderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    /**
     * Filter which Gender to delete.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender deleteMany
   */
  export type GenderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genders to delete
     */
    where?: GenderWhereInput
  }

  /**
   * Gender.categories
   */
  export type Gender$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Gender.planningDetails
   */
  export type Gender$planningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    where?: PlanningDetailWhereInput
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    cursor?: PlanningDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * Gender without action
   */
  export type GenderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    genderId: string | null
    isActive: boolean | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    genderId: string | null
    isActive: boolean | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    genderId: number
    isActive: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    genderId?: true
    isActive?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    genderId?: true
    isActive?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    genderId?: true
    isActive?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    genderId: string
    isActive: boolean
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genderId?: boolean
    isActive?: boolean
    gender?: boolean | GenderDefaultArgs<ExtArgs>
    subCategories?: boolean | Category$subCategoriesArgs<ExtArgs>
    planningDetails?: boolean | Category$planningDetailsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genderId?: boolean
    isActive?: boolean
    gender?: boolean | GenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    genderId?: boolean
    isActive?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gender?: boolean | GenderDefaultArgs<ExtArgs>
    subCategories?: boolean | Category$subCategoriesArgs<ExtArgs>
    planningDetails?: boolean | Category$planningDetailsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gender?: boolean | GenderDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      gender: Prisma.$GenderPayload<ExtArgs>
      subCategories: Prisma.$SubCategoryPayload<ExtArgs>[]
      planningDetails: Prisma.$PlanningDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      genderId: string
      isActive: boolean
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gender<T extends GenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenderDefaultArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subCategories<T extends Category$subCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    planningDetails<T extends Category$planningDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Category$planningDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly genderId: FieldRef<"Category", 'String'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.subCategories
   */
  export type Category$subCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * Category.planningDetails
   */
  export type Category$planningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    where?: PlanningDetailWhereInput
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    cursor?: PlanningDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model SubCategory
   */

  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    isActive: boolean | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    categoryId: string | null
    isActive: boolean | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    isActive: number
    _all: number
  }


  export type SubCategoryMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    isActive?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    isActive?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    isActive?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategory to aggregate.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubCategoryWhereInput
    orderBy?: SubCategoryOrderByWithAggregationInput | SubCategoryOrderByWithAggregationInput[]
    by: SubCategoryScalarFieldEnum[] | SubCategoryScalarFieldEnum
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }

  export type SubCategoryGroupByOutputType = {
    id: string
    name: string
    categoryId: string
    isActive: boolean
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    isActive?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    planningDetails?: boolean | SubCategory$planningDetailsArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategory"]>

  export type SubCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    isActive?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subCategory"]>

  export type SubCategorySelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
    isActive?: boolean
  }

  export type SubCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    planningDetails?: boolean | SubCategory$planningDetailsArgs<ExtArgs>
    _count?: boolean | SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $SubCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubCategory"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      planningDetails: Prisma.$PlanningDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      categoryId: string
      isActive: boolean
    }, ExtArgs["result"]["subCategory"]>
    composites: {}
  }

  type SubCategoryGetPayload<S extends boolean | null | undefined | SubCategoryDefaultArgs> = $Result.GetResult<Prisma.$SubCategoryPayload, S>

  type SubCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubCategoryCountAggregateInputType | true
    }

  export interface SubCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubCategory'], meta: { name: 'SubCategory' } }
    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubCategoryFindUniqueArgs>(args: SelectSubset<T, SubCategoryFindUniqueArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubCategoryFindUniqueOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubCategoryFindFirstArgs>(args?: SelectSubset<T, SubCategoryFindFirstArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubCategoryFindManyArgs>(args?: SelectSubset<T, SubCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
     */
    create<T extends SubCategoryCreateArgs>(args: SelectSubset<T, SubCategoryCreateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubCategories.
     * @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     * @example
     * // Create many SubCategories
     * const subCategory = await prisma.subCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubCategoryCreateManyArgs>(args?: SelectSubset<T, SubCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubCategories and returns the data saved in the database.
     * @param {SubCategoryCreateManyAndReturnArgs} args - Arguments to create many SubCategories.
     * @example
     * // Create many SubCategories
     * const subCategory = await prisma.subCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubCategories and only return the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
     */
    delete<T extends SubCategoryDeleteArgs>(args: SelectSubset<T, SubCategoryDeleteArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubCategoryUpdateArgs>(args: SelectSubset<T, SubCategoryUpdateArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubCategoryDeleteManyArgs>(args?: SelectSubset<T, SubCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubCategoryUpdateManyArgs>(args: SelectSubset<T, SubCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
     */
    upsert<T extends SubCategoryUpsertArgs>(args: SelectSubset<T, SubCategoryUpsertArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubCategory model
   */
  readonly fields: SubCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    planningDetails<T extends SubCategory$planningDetailsArgs<ExtArgs> = {}>(args?: Subset<T, SubCategory$planningDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubCategory model
   */ 
  interface SubCategoryFieldRefs {
    readonly id: FieldRef<"SubCategory", 'String'>
    readonly name: FieldRef<"SubCategory", 'String'>
    readonly categoryId: FieldRef<"SubCategory", 'String'>
    readonly isActive: FieldRef<"SubCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SubCategory findUnique
   */
  export type SubCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findUniqueOrThrow
   */
  export type SubCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findFirst
   */
  export type SubCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findFirstOrThrow
   */
  export type SubCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter, which SubCategories to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: SubCategoryOrderByWithRelationInput | SubCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    distinct?: SubCategoryScalarFieldEnum | SubCategoryScalarFieldEnum[]
  }

  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SubCategory.
     */
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }

  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubCategories.
     */
    data: SubCategoryCreateManyInput | SubCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubCategory createManyAndReturn
   */
  export type SubCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubCategories.
     */
    data: SubCategoryCreateManyInput | SubCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SubCategory.
     */
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubCategories.
     */
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     */
    where?: SubCategoryWhereInput
  }

  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     */
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     */
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }

  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    /**
     * Filter which SubCategory to delete.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubCategories to delete
     */
    where?: SubCategoryWhereInput
  }

  /**
   * SubCategory.planningDetails
   */
  export type SubCategory$planningDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    where?: PlanningDetailWhereInput
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    cursor?: PlanningDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * SubCategory without action
   */
  export type SubCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
  }


  /**
   * Model SkuCatalog
   */

  export type AggregateSkuCatalog = {
    _count: SkuCatalogCountAggregateOutputType | null
    _avg: SkuCatalogAvgAggregateOutputType | null
    _sum: SkuCatalogSumAggregateOutputType | null
    _min: SkuCatalogMinAggregateOutputType | null
    _max: SkuCatalogMaxAggregateOutputType | null
  }

  export type SkuCatalogAvgAggregateOutputType = {
    srp: Decimal | null
  }

  export type SkuCatalogSumAggregateOutputType = {
    srp: Decimal | null
  }

  export type SkuCatalogMinAggregateOutputType = {
    id: string | null
    skuCode: string | null
    productName: string | null
    productType: string | null
    theme: string | null
    color: string | null
    composition: string | null
    srp: Decimal | null
    brandId: string | null
    seasonGroupId: string | null
    imageUrl: string | null
    isActive: boolean | null
  }

  export type SkuCatalogMaxAggregateOutputType = {
    id: string | null
    skuCode: string | null
    productName: string | null
    productType: string | null
    theme: string | null
    color: string | null
    composition: string | null
    srp: Decimal | null
    brandId: string | null
    seasonGroupId: string | null
    imageUrl: string | null
    isActive: boolean | null
  }

  export type SkuCatalogCountAggregateOutputType = {
    id: number
    skuCode: number
    productName: number
    productType: number
    theme: number
    color: number
    composition: number
    srp: number
    brandId: number
    seasonGroupId: number
    imageUrl: number
    isActive: number
    _all: number
  }


  export type SkuCatalogAvgAggregateInputType = {
    srp?: true
  }

  export type SkuCatalogSumAggregateInputType = {
    srp?: true
  }

  export type SkuCatalogMinAggregateInputType = {
    id?: true
    skuCode?: true
    productName?: true
    productType?: true
    theme?: true
    color?: true
    composition?: true
    srp?: true
    brandId?: true
    seasonGroupId?: true
    imageUrl?: true
    isActive?: true
  }

  export type SkuCatalogMaxAggregateInputType = {
    id?: true
    skuCode?: true
    productName?: true
    productType?: true
    theme?: true
    color?: true
    composition?: true
    srp?: true
    brandId?: true
    seasonGroupId?: true
    imageUrl?: true
    isActive?: true
  }

  export type SkuCatalogCountAggregateInputType = {
    id?: true
    skuCode?: true
    productName?: true
    productType?: true
    theme?: true
    color?: true
    composition?: true
    srp?: true
    brandId?: true
    seasonGroupId?: true
    imageUrl?: true
    isActive?: true
    _all?: true
  }

  export type SkuCatalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuCatalog to aggregate.
     */
    where?: SkuCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuCatalogs to fetch.
     */
    orderBy?: SkuCatalogOrderByWithRelationInput | SkuCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuCatalogs
    **/
    _count?: true | SkuCatalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkuCatalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkuCatalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuCatalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuCatalogMaxAggregateInputType
  }

  export type GetSkuCatalogAggregateType<T extends SkuCatalogAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuCatalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuCatalog[P]>
      : GetScalarType<T[P], AggregateSkuCatalog[P]>
  }




  export type SkuCatalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuCatalogWhereInput
    orderBy?: SkuCatalogOrderByWithAggregationInput | SkuCatalogOrderByWithAggregationInput[]
    by: SkuCatalogScalarFieldEnum[] | SkuCatalogScalarFieldEnum
    having?: SkuCatalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuCatalogCountAggregateInputType | true
    _avg?: SkuCatalogAvgAggregateInputType
    _sum?: SkuCatalogSumAggregateInputType
    _min?: SkuCatalogMinAggregateInputType
    _max?: SkuCatalogMaxAggregateInputType
  }

  export type SkuCatalogGroupByOutputType = {
    id: string
    skuCode: string
    productName: string
    productType: string
    theme: string | null
    color: string | null
    composition: string | null
    srp: Decimal
    brandId: string | null
    seasonGroupId: string | null
    imageUrl: string | null
    isActive: boolean
    _count: SkuCatalogCountAggregateOutputType | null
    _avg: SkuCatalogAvgAggregateOutputType | null
    _sum: SkuCatalogSumAggregateOutputType | null
    _min: SkuCatalogMinAggregateOutputType | null
    _max: SkuCatalogMaxAggregateOutputType | null
  }

  type GetSkuCatalogGroupByPayload<T extends SkuCatalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuCatalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuCatalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuCatalogGroupByOutputType[P]>
            : GetScalarType<T[P], SkuCatalogGroupByOutputType[P]>
        }
      >
    >


  export type SkuCatalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuCode?: boolean
    productName?: boolean
    productType?: boolean
    theme?: boolean
    color?: boolean
    composition?: boolean
    srp?: boolean
    brandId?: boolean
    seasonGroupId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    brand?: boolean | SkuCatalog$brandArgs<ExtArgs>
    products?: boolean | SkuCatalog$productsArgs<ExtArgs>
    sizeCurveRecommendations?: boolean | SkuCatalog$sizeCurveRecommendationsArgs<ExtArgs>
    skuPerformance?: boolean | SkuCatalog$skuPerformanceArgs<ExtArgs>
    skuRecommendations?: boolean | SkuCatalog$skuRecommendationsArgs<ExtArgs>
    _count?: boolean | SkuCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuCatalog"]>

  export type SkuCatalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuCode?: boolean
    productName?: boolean
    productType?: boolean
    theme?: boolean
    color?: boolean
    composition?: boolean
    srp?: boolean
    brandId?: boolean
    seasonGroupId?: boolean
    imageUrl?: boolean
    isActive?: boolean
    brand?: boolean | SkuCatalog$brandArgs<ExtArgs>
  }, ExtArgs["result"]["skuCatalog"]>

  export type SkuCatalogSelectScalar = {
    id?: boolean
    skuCode?: boolean
    productName?: boolean
    productType?: boolean
    theme?: boolean
    color?: boolean
    composition?: boolean
    srp?: boolean
    brandId?: boolean
    seasonGroupId?: boolean
    imageUrl?: boolean
    isActive?: boolean
  }

  export type SkuCatalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | SkuCatalog$brandArgs<ExtArgs>
    products?: boolean | SkuCatalog$productsArgs<ExtArgs>
    sizeCurveRecommendations?: boolean | SkuCatalog$sizeCurveRecommendationsArgs<ExtArgs>
    skuPerformance?: boolean | SkuCatalog$skuPerformanceArgs<ExtArgs>
    skuRecommendations?: boolean | SkuCatalog$skuRecommendationsArgs<ExtArgs>
    _count?: boolean | SkuCatalogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkuCatalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | SkuCatalog$brandArgs<ExtArgs>
  }

  export type $SkuCatalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuCatalog"
    objects: {
      brand: Prisma.$GroupBrandPayload<ExtArgs> | null
      products: Prisma.$ProposalProductPayload<ExtArgs>[]
      sizeCurveRecommendations: Prisma.$SizeCurveRecommendationPayload<ExtArgs>[]
      skuPerformance: Prisma.$SkuPerformancePayload<ExtArgs>[]
      skuRecommendations: Prisma.$SkuRecommendationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skuCode: string
      productName: string
      productType: string
      theme: string | null
      color: string | null
      composition: string | null
      srp: Prisma.Decimal
      brandId: string | null
      seasonGroupId: string | null
      imageUrl: string | null
      isActive: boolean
    }, ExtArgs["result"]["skuCatalog"]>
    composites: {}
  }

  type SkuCatalogGetPayload<S extends boolean | null | undefined | SkuCatalogDefaultArgs> = $Result.GetResult<Prisma.$SkuCatalogPayload, S>

  type SkuCatalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkuCatalogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkuCatalogCountAggregateInputType | true
    }

  export interface SkuCatalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuCatalog'], meta: { name: 'SkuCatalog' } }
    /**
     * Find zero or one SkuCatalog that matches the filter.
     * @param {SkuCatalogFindUniqueArgs} args - Arguments to find a SkuCatalog
     * @example
     * // Get one SkuCatalog
     * const skuCatalog = await prisma.skuCatalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuCatalogFindUniqueArgs>(args: SelectSubset<T, SkuCatalogFindUniqueArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkuCatalog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkuCatalogFindUniqueOrThrowArgs} args - Arguments to find a SkuCatalog
     * @example
     * // Get one SkuCatalog
     * const skuCatalog = await prisma.skuCatalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuCatalogFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuCatalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkuCatalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogFindFirstArgs} args - Arguments to find a SkuCatalog
     * @example
     * // Get one SkuCatalog
     * const skuCatalog = await prisma.skuCatalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuCatalogFindFirstArgs>(args?: SelectSubset<T, SkuCatalogFindFirstArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkuCatalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogFindFirstOrThrowArgs} args - Arguments to find a SkuCatalog
     * @example
     * // Get one SkuCatalog
     * const skuCatalog = await prisma.skuCatalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuCatalogFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuCatalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkuCatalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuCatalogs
     * const skuCatalogs = await prisma.skuCatalog.findMany()
     * 
     * // Get first 10 SkuCatalogs
     * const skuCatalogs = await prisma.skuCatalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuCatalogWithIdOnly = await prisma.skuCatalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuCatalogFindManyArgs>(args?: SelectSubset<T, SkuCatalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkuCatalog.
     * @param {SkuCatalogCreateArgs} args - Arguments to create a SkuCatalog.
     * @example
     * // Create one SkuCatalog
     * const SkuCatalog = await prisma.skuCatalog.create({
     *   data: {
     *     // ... data to create a SkuCatalog
     *   }
     * })
     * 
     */
    create<T extends SkuCatalogCreateArgs>(args: SelectSubset<T, SkuCatalogCreateArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkuCatalogs.
     * @param {SkuCatalogCreateManyArgs} args - Arguments to create many SkuCatalogs.
     * @example
     * // Create many SkuCatalogs
     * const skuCatalog = await prisma.skuCatalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuCatalogCreateManyArgs>(args?: SelectSubset<T, SkuCatalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuCatalogs and returns the data saved in the database.
     * @param {SkuCatalogCreateManyAndReturnArgs} args - Arguments to create many SkuCatalogs.
     * @example
     * // Create many SkuCatalogs
     * const skuCatalog = await prisma.skuCatalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuCatalogs and only return the `id`
     * const skuCatalogWithIdOnly = await prisma.skuCatalog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuCatalogCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuCatalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkuCatalog.
     * @param {SkuCatalogDeleteArgs} args - Arguments to delete one SkuCatalog.
     * @example
     * // Delete one SkuCatalog
     * const SkuCatalog = await prisma.skuCatalog.delete({
     *   where: {
     *     // ... filter to delete one SkuCatalog
     *   }
     * })
     * 
     */
    delete<T extends SkuCatalogDeleteArgs>(args: SelectSubset<T, SkuCatalogDeleteArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkuCatalog.
     * @param {SkuCatalogUpdateArgs} args - Arguments to update one SkuCatalog.
     * @example
     * // Update one SkuCatalog
     * const skuCatalog = await prisma.skuCatalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuCatalogUpdateArgs>(args: SelectSubset<T, SkuCatalogUpdateArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkuCatalogs.
     * @param {SkuCatalogDeleteManyArgs} args - Arguments to filter SkuCatalogs to delete.
     * @example
     * // Delete a few SkuCatalogs
     * const { count } = await prisma.skuCatalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuCatalogDeleteManyArgs>(args?: SelectSubset<T, SkuCatalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuCatalogs
     * const skuCatalog = await prisma.skuCatalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuCatalogUpdateManyArgs>(args: SelectSubset<T, SkuCatalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkuCatalog.
     * @param {SkuCatalogUpsertArgs} args - Arguments to update or create a SkuCatalog.
     * @example
     * // Update or create a SkuCatalog
     * const skuCatalog = await prisma.skuCatalog.upsert({
     *   create: {
     *     // ... data to create a SkuCatalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuCatalog we want to update
     *   }
     * })
     */
    upsert<T extends SkuCatalogUpsertArgs>(args: SelectSubset<T, SkuCatalogUpsertArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkuCatalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogCountArgs} args - Arguments to filter SkuCatalogs to count.
     * @example
     * // Count the number of SkuCatalogs
     * const count = await prisma.skuCatalog.count({
     *   where: {
     *     // ... the filter for the SkuCatalogs we want to count
     *   }
     * })
    **/
    count<T extends SkuCatalogCountArgs>(
      args?: Subset<T, SkuCatalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuCatalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuCatalogAggregateArgs>(args: Subset<T, SkuCatalogAggregateArgs>): Prisma.PrismaPromise<GetSkuCatalogAggregateType<T>>

    /**
     * Group by SkuCatalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuCatalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuCatalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuCatalogGroupByArgs['orderBy'] }
        : { orderBy?: SkuCatalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuCatalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuCatalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuCatalog model
   */
  readonly fields: SkuCatalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuCatalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuCatalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends SkuCatalog$brandArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalog$brandArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    products<T extends SkuCatalog$productsArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalog$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findMany"> | Null>
    sizeCurveRecommendations<T extends SkuCatalog$sizeCurveRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalog$sizeCurveRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    skuPerformance<T extends SkuCatalog$skuPerformanceArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalog$skuPerformanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findMany"> | Null>
    skuRecommendations<T extends SkuCatalog$skuRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalog$skuRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuCatalog model
   */ 
  interface SkuCatalogFieldRefs {
    readonly id: FieldRef<"SkuCatalog", 'String'>
    readonly skuCode: FieldRef<"SkuCatalog", 'String'>
    readonly productName: FieldRef<"SkuCatalog", 'String'>
    readonly productType: FieldRef<"SkuCatalog", 'String'>
    readonly theme: FieldRef<"SkuCatalog", 'String'>
    readonly color: FieldRef<"SkuCatalog", 'String'>
    readonly composition: FieldRef<"SkuCatalog", 'String'>
    readonly srp: FieldRef<"SkuCatalog", 'Decimal'>
    readonly brandId: FieldRef<"SkuCatalog", 'String'>
    readonly seasonGroupId: FieldRef<"SkuCatalog", 'String'>
    readonly imageUrl: FieldRef<"SkuCatalog", 'String'>
    readonly isActive: FieldRef<"SkuCatalog", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SkuCatalog findUnique
   */
  export type SkuCatalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * Filter, which SkuCatalog to fetch.
     */
    where: SkuCatalogWhereUniqueInput
  }

  /**
   * SkuCatalog findUniqueOrThrow
   */
  export type SkuCatalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * Filter, which SkuCatalog to fetch.
     */
    where: SkuCatalogWhereUniqueInput
  }

  /**
   * SkuCatalog findFirst
   */
  export type SkuCatalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * Filter, which SkuCatalog to fetch.
     */
    where?: SkuCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuCatalogs to fetch.
     */
    orderBy?: SkuCatalogOrderByWithRelationInput | SkuCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuCatalogs.
     */
    cursor?: SkuCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuCatalogs.
     */
    distinct?: SkuCatalogScalarFieldEnum | SkuCatalogScalarFieldEnum[]
  }

  /**
   * SkuCatalog findFirstOrThrow
   */
  export type SkuCatalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * Filter, which SkuCatalog to fetch.
     */
    where?: SkuCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuCatalogs to fetch.
     */
    orderBy?: SkuCatalogOrderByWithRelationInput | SkuCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuCatalogs.
     */
    cursor?: SkuCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuCatalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuCatalogs.
     */
    distinct?: SkuCatalogScalarFieldEnum | SkuCatalogScalarFieldEnum[]
  }

  /**
   * SkuCatalog findMany
   */
  export type SkuCatalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * Filter, which SkuCatalogs to fetch.
     */
    where?: SkuCatalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuCatalogs to fetch.
     */
    orderBy?: SkuCatalogOrderByWithRelationInput | SkuCatalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuCatalogs.
     */
    cursor?: SkuCatalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuCatalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuCatalogs.
     */
    skip?: number
    distinct?: SkuCatalogScalarFieldEnum | SkuCatalogScalarFieldEnum[]
  }

  /**
   * SkuCatalog create
   */
  export type SkuCatalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuCatalog.
     */
    data: XOR<SkuCatalogCreateInput, SkuCatalogUncheckedCreateInput>
  }

  /**
   * SkuCatalog createMany
   */
  export type SkuCatalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuCatalogs.
     */
    data: SkuCatalogCreateManyInput | SkuCatalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuCatalog createManyAndReturn
   */
  export type SkuCatalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkuCatalogs.
     */
    data: SkuCatalogCreateManyInput | SkuCatalogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuCatalog update
   */
  export type SkuCatalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuCatalog.
     */
    data: XOR<SkuCatalogUpdateInput, SkuCatalogUncheckedUpdateInput>
    /**
     * Choose, which SkuCatalog to update.
     */
    where: SkuCatalogWhereUniqueInput
  }

  /**
   * SkuCatalog updateMany
   */
  export type SkuCatalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuCatalogs.
     */
    data: XOR<SkuCatalogUpdateManyMutationInput, SkuCatalogUncheckedUpdateManyInput>
    /**
     * Filter which SkuCatalogs to update
     */
    where?: SkuCatalogWhereInput
  }

  /**
   * SkuCatalog upsert
   */
  export type SkuCatalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuCatalog to update in case it exists.
     */
    where: SkuCatalogWhereUniqueInput
    /**
     * In case the SkuCatalog found by the `where` argument doesn't exist, create a new SkuCatalog with this data.
     */
    create: XOR<SkuCatalogCreateInput, SkuCatalogUncheckedCreateInput>
    /**
     * In case the SkuCatalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuCatalogUpdateInput, SkuCatalogUncheckedUpdateInput>
  }

  /**
   * SkuCatalog delete
   */
  export type SkuCatalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
    /**
     * Filter which SkuCatalog to delete.
     */
    where: SkuCatalogWhereUniqueInput
  }

  /**
   * SkuCatalog deleteMany
   */
  export type SkuCatalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuCatalogs to delete
     */
    where?: SkuCatalogWhereInput
  }

  /**
   * SkuCatalog.brand
   */
  export type SkuCatalog$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBrand
     */
    select?: GroupBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBrandInclude<ExtArgs> | null
    where?: GroupBrandWhereInput
  }

  /**
   * SkuCatalog.products
   */
  export type SkuCatalog$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    where?: ProposalProductWhereInput
    orderBy?: ProposalProductOrderByWithRelationInput | ProposalProductOrderByWithRelationInput[]
    cursor?: ProposalProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalProductScalarFieldEnum | ProposalProductScalarFieldEnum[]
  }

  /**
   * SkuCatalog.sizeCurveRecommendations
   */
  export type SkuCatalog$sizeCurveRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    where?: SizeCurveRecommendationWhereInput
    orderBy?: SizeCurveRecommendationOrderByWithRelationInput | SizeCurveRecommendationOrderByWithRelationInput[]
    cursor?: SizeCurveRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SizeCurveRecommendationScalarFieldEnum | SizeCurveRecommendationScalarFieldEnum[]
  }

  /**
   * SkuCatalog.skuPerformance
   */
  export type SkuCatalog$skuPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    where?: SkuPerformanceWhereInput
    orderBy?: SkuPerformanceOrderByWithRelationInput | SkuPerformanceOrderByWithRelationInput[]
    cursor?: SkuPerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuPerformanceScalarFieldEnum | SkuPerformanceScalarFieldEnum[]
  }

  /**
   * SkuCatalog.skuRecommendations
   */
  export type SkuCatalog$skuRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    where?: SkuRecommendationWhereInput
    orderBy?: SkuRecommendationOrderByWithRelationInput | SkuRecommendationOrderByWithRelationInput[]
    cursor?: SkuRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuRecommendationScalarFieldEnum | SkuRecommendationScalarFieldEnum[]
  }

  /**
   * SkuCatalog without action
   */
  export type SkuCatalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuCatalog
     */
    select?: SkuCatalogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuCatalogInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    fiscalYear: number | null
    totalBudget: Decimal | null
  }

  export type BudgetSumAggregateOutputType = {
    fiscalYear: number | null
    totalBudget: Decimal | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    budgetCode: string | null
    groupBrandId: string | null
    seasonGroupId: string | null
    seasonType: string | null
    fiscalYear: number | null
    totalBudget: Decimal | null
    status: $Enums.BudgetStatus | null
    comment: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    budgetCode: string | null
    groupBrandId: string | null
    seasonGroupId: string | null
    seasonType: string | null
    fiscalYear: number | null
    totalBudget: Decimal | null
    status: $Enums.BudgetStatus | null
    comment: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    budgetCode: number
    groupBrandId: number
    seasonGroupId: number
    seasonType: number
    fiscalYear: number
    totalBudget: number
    status: number
    comment: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    fiscalYear?: true
    totalBudget?: true
  }

  export type BudgetSumAggregateInputType = {
    fiscalYear?: true
    totalBudget?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    budgetCode?: true
    groupBrandId?: true
    seasonGroupId?: true
    seasonType?: true
    fiscalYear?: true
    totalBudget?: true
    status?: true
    comment?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    budgetCode?: true
    groupBrandId?: true
    seasonGroupId?: true
    seasonType?: true
    fiscalYear?: true
    totalBudget?: true
    status?: true
    comment?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    budgetCode?: true
    groupBrandId?: true
    seasonGroupId?: true
    seasonType?: true
    fiscalYear?: true
    totalBudget?: true
    status?: true
    comment?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget: Decimal
    status: $Enums.BudgetStatus
    comment: string | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetCode?: boolean
    groupBrandId?: boolean
    seasonGroupId?: boolean
    seasonType?: boolean
    fiscalYear?: boolean
    totalBudget?: boolean
    status?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupBrand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | Budget$detailsArgs<ExtArgs>
    proposals?: boolean | Budget$proposalsArgs<ExtArgs>
    budgetAlerts?: boolean | Budget$budgetAlertsArgs<ExtArgs>
    budgetSnapshots?: boolean | Budget$budgetSnapshotsArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetCode?: boolean
    groupBrandId?: boolean
    seasonGroupId?: boolean
    seasonType?: boolean
    fiscalYear?: boolean
    totalBudget?: boolean
    status?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groupBrand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    budgetCode?: boolean
    groupBrandId?: boolean
    seasonGroupId?: boolean
    seasonType?: boolean
    fiscalYear?: boolean
    totalBudget?: boolean
    status?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupBrand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | Budget$detailsArgs<ExtArgs>
    proposals?: boolean | Budget$proposalsArgs<ExtArgs>
    budgetAlerts?: boolean | Budget$budgetAlertsArgs<ExtArgs>
    budgetSnapshots?: boolean | Budget$budgetSnapshotsArgs<ExtArgs>
    _count?: boolean | BudgetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupBrand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      groupBrand: Prisma.$GroupBrandPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      details: Prisma.$BudgetDetailPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
      budgetAlerts: Prisma.$BudgetAlertPayload<ExtArgs>[]
      budgetSnapshots: Prisma.$BudgetSnapshotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetCode: string
      groupBrandId: string
      seasonGroupId: string
      seasonType: string
      fiscalYear: number
      totalBudget: Prisma.Decimal
      status: $Enums.BudgetStatus
      comment: string | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupBrand<T extends GroupBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupBrandDefaultArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    details<T extends Budget$detailsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findMany"> | Null>
    proposals<T extends Budget$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany"> | Null>
    budgetAlerts<T extends Budget$budgetAlertsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$budgetAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "findMany"> | Null>
    budgetSnapshots<T extends Budget$budgetSnapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Budget$budgetSnapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly budgetCode: FieldRef<"Budget", 'String'>
    readonly groupBrandId: FieldRef<"Budget", 'String'>
    readonly seasonGroupId: FieldRef<"Budget", 'String'>
    readonly seasonType: FieldRef<"Budget", 'String'>
    readonly fiscalYear: FieldRef<"Budget", 'Int'>
    readonly totalBudget: FieldRef<"Budget", 'Decimal'>
    readonly status: FieldRef<"Budget", 'BudgetStatus'>
    readonly comment: FieldRef<"Budget", 'String'>
    readonly createdById: FieldRef<"Budget", 'String'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
    readonly updatedAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget.details
   */
  export type Budget$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    where?: BudgetDetailWhereInput
    orderBy?: BudgetDetailOrderByWithRelationInput | BudgetDetailOrderByWithRelationInput[]
    cursor?: BudgetDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetDetailScalarFieldEnum | BudgetDetailScalarFieldEnum[]
  }

  /**
   * Budget.proposals
   */
  export type Budget$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Budget.budgetAlerts
   */
  export type Budget$budgetAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    where?: BudgetAlertWhereInput
    orderBy?: BudgetAlertOrderByWithRelationInput | BudgetAlertOrderByWithRelationInput[]
    cursor?: BudgetAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetAlertScalarFieldEnum | BudgetAlertScalarFieldEnum[]
  }

  /**
   * Budget.budgetSnapshots
   */
  export type Budget$budgetSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    where?: BudgetSnapshotWhereInput
    orderBy?: BudgetSnapshotOrderByWithRelationInput | BudgetSnapshotOrderByWithRelationInput[]
    cursor?: BudgetSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetSnapshotScalarFieldEnum | BudgetSnapshotScalarFieldEnum[]
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model BudgetDetail
   */

  export type AggregateBudgetDetail = {
    _count: BudgetDetailCountAggregateOutputType | null
    _avg: BudgetDetailAvgAggregateOutputType | null
    _sum: BudgetDetailSumAggregateOutputType | null
    _min: BudgetDetailMinAggregateOutputType | null
    _max: BudgetDetailMaxAggregateOutputType | null
  }

  export type BudgetDetailAvgAggregateOutputType = {
    budgetAmount: Decimal | null
  }

  export type BudgetDetailSumAggregateOutputType = {
    budgetAmount: Decimal | null
  }

  export type BudgetDetailMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    storeId: string | null
    budgetAmount: Decimal | null
  }

  export type BudgetDetailMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    storeId: string | null
    budgetAmount: Decimal | null
  }

  export type BudgetDetailCountAggregateOutputType = {
    id: number
    budgetId: number
    storeId: number
    budgetAmount: number
    _all: number
  }


  export type BudgetDetailAvgAggregateInputType = {
    budgetAmount?: true
  }

  export type BudgetDetailSumAggregateInputType = {
    budgetAmount?: true
  }

  export type BudgetDetailMinAggregateInputType = {
    id?: true
    budgetId?: true
    storeId?: true
    budgetAmount?: true
  }

  export type BudgetDetailMaxAggregateInputType = {
    id?: true
    budgetId?: true
    storeId?: true
    budgetAmount?: true
  }

  export type BudgetDetailCountAggregateInputType = {
    id?: true
    budgetId?: true
    storeId?: true
    budgetAmount?: true
    _all?: true
  }

  export type BudgetDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetDetail to aggregate.
     */
    where?: BudgetDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetDetails to fetch.
     */
    orderBy?: BudgetDetailOrderByWithRelationInput | BudgetDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetDetails
    **/
    _count?: true | BudgetDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetDetailMaxAggregateInputType
  }

  export type GetBudgetDetailAggregateType<T extends BudgetDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetDetail[P]>
      : GetScalarType<T[P], AggregateBudgetDetail[P]>
  }




  export type BudgetDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetDetailWhereInput
    orderBy?: BudgetDetailOrderByWithAggregationInput | BudgetDetailOrderByWithAggregationInput[]
    by: BudgetDetailScalarFieldEnum[] | BudgetDetailScalarFieldEnum
    having?: BudgetDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetDetailCountAggregateInputType | true
    _avg?: BudgetDetailAvgAggregateInputType
    _sum?: BudgetDetailSumAggregateInputType
    _min?: BudgetDetailMinAggregateInputType
    _max?: BudgetDetailMaxAggregateInputType
  }

  export type BudgetDetailGroupByOutputType = {
    id: string
    budgetId: string
    storeId: string
    budgetAmount: Decimal
    _count: BudgetDetailCountAggregateOutputType | null
    _avg: BudgetDetailAvgAggregateOutputType | null
    _sum: BudgetDetailSumAggregateOutputType | null
    _min: BudgetDetailMinAggregateOutputType | null
    _max: BudgetDetailMaxAggregateOutputType | null
  }

  type GetBudgetDetailGroupByPayload<T extends BudgetDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetDetailGroupByOutputType[P]>
        }
      >
    >


  export type BudgetDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    storeId?: boolean
    budgetAmount?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    planningVersions?: boolean | BudgetDetail$planningVersionsArgs<ExtArgs>
    allocationRecommendations?: boolean | BudgetDetail$allocationRecommendationsArgs<ExtArgs>
    skuRecommendations?: boolean | BudgetDetail$skuRecommendationsArgs<ExtArgs>
    _count?: boolean | BudgetDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetDetail"]>

  export type BudgetDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    storeId?: boolean
    budgetAmount?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetDetail"]>

  export type BudgetDetailSelectScalar = {
    id?: boolean
    budgetId?: boolean
    storeId?: boolean
    budgetAmount?: boolean
  }

  export type BudgetDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
    planningVersions?: boolean | BudgetDetail$planningVersionsArgs<ExtArgs>
    allocationRecommendations?: boolean | BudgetDetail$allocationRecommendationsArgs<ExtArgs>
    skuRecommendations?: boolean | BudgetDetail$skuRecommendationsArgs<ExtArgs>
    _count?: boolean | BudgetDetailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BudgetDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $BudgetDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetDetail"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
      planningVersions: Prisma.$PlanningVersionPayload<ExtArgs>[]
      allocationRecommendations: Prisma.$AllocationRecommendationPayload<ExtArgs>[]
      skuRecommendations: Prisma.$SkuRecommendationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      storeId: string
      budgetAmount: Prisma.Decimal
    }, ExtArgs["result"]["budgetDetail"]>
    composites: {}
  }

  type BudgetDetailGetPayload<S extends boolean | null | undefined | BudgetDetailDefaultArgs> = $Result.GetResult<Prisma.$BudgetDetailPayload, S>

  type BudgetDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetDetailCountAggregateInputType | true
    }

  export interface BudgetDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetDetail'], meta: { name: 'BudgetDetail' } }
    /**
     * Find zero or one BudgetDetail that matches the filter.
     * @param {BudgetDetailFindUniqueArgs} args - Arguments to find a BudgetDetail
     * @example
     * // Get one BudgetDetail
     * const budgetDetail = await prisma.budgetDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetDetailFindUniqueArgs>(args: SelectSubset<T, BudgetDetailFindUniqueArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BudgetDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetDetailFindUniqueOrThrowArgs} args - Arguments to find a BudgetDetail
     * @example
     * // Get one BudgetDetail
     * const budgetDetail = await prisma.budgetDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BudgetDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailFindFirstArgs} args - Arguments to find a BudgetDetail
     * @example
     * // Get one BudgetDetail
     * const budgetDetail = await prisma.budgetDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetDetailFindFirstArgs>(args?: SelectSubset<T, BudgetDetailFindFirstArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BudgetDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailFindFirstOrThrowArgs} args - Arguments to find a BudgetDetail
     * @example
     * // Get one BudgetDetail
     * const budgetDetail = await prisma.budgetDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BudgetDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetDetails
     * const budgetDetails = await prisma.budgetDetail.findMany()
     * 
     * // Get first 10 BudgetDetails
     * const budgetDetails = await prisma.budgetDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetDetailWithIdOnly = await prisma.budgetDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetDetailFindManyArgs>(args?: SelectSubset<T, BudgetDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BudgetDetail.
     * @param {BudgetDetailCreateArgs} args - Arguments to create a BudgetDetail.
     * @example
     * // Create one BudgetDetail
     * const BudgetDetail = await prisma.budgetDetail.create({
     *   data: {
     *     // ... data to create a BudgetDetail
     *   }
     * })
     * 
     */
    create<T extends BudgetDetailCreateArgs>(args: SelectSubset<T, BudgetDetailCreateArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BudgetDetails.
     * @param {BudgetDetailCreateManyArgs} args - Arguments to create many BudgetDetails.
     * @example
     * // Create many BudgetDetails
     * const budgetDetail = await prisma.budgetDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetDetailCreateManyArgs>(args?: SelectSubset<T, BudgetDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetDetails and returns the data saved in the database.
     * @param {BudgetDetailCreateManyAndReturnArgs} args - Arguments to create many BudgetDetails.
     * @example
     * // Create many BudgetDetails
     * const budgetDetail = await prisma.budgetDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetDetails and only return the `id`
     * const budgetDetailWithIdOnly = await prisma.budgetDetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BudgetDetail.
     * @param {BudgetDetailDeleteArgs} args - Arguments to delete one BudgetDetail.
     * @example
     * // Delete one BudgetDetail
     * const BudgetDetail = await prisma.budgetDetail.delete({
     *   where: {
     *     // ... filter to delete one BudgetDetail
     *   }
     * })
     * 
     */
    delete<T extends BudgetDetailDeleteArgs>(args: SelectSubset<T, BudgetDetailDeleteArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BudgetDetail.
     * @param {BudgetDetailUpdateArgs} args - Arguments to update one BudgetDetail.
     * @example
     * // Update one BudgetDetail
     * const budgetDetail = await prisma.budgetDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetDetailUpdateArgs>(args: SelectSubset<T, BudgetDetailUpdateArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BudgetDetails.
     * @param {BudgetDetailDeleteManyArgs} args - Arguments to filter BudgetDetails to delete.
     * @example
     * // Delete a few BudgetDetails
     * const { count } = await prisma.budgetDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDetailDeleteManyArgs>(args?: SelectSubset<T, BudgetDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetDetails
     * const budgetDetail = await prisma.budgetDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetDetailUpdateManyArgs>(args: SelectSubset<T, BudgetDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudgetDetail.
     * @param {BudgetDetailUpsertArgs} args - Arguments to update or create a BudgetDetail.
     * @example
     * // Update or create a BudgetDetail
     * const budgetDetail = await prisma.budgetDetail.upsert({
     *   create: {
     *     // ... data to create a BudgetDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetDetail we want to update
     *   }
     * })
     */
    upsert<T extends BudgetDetailUpsertArgs>(args: SelectSubset<T, BudgetDetailUpsertArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BudgetDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailCountArgs} args - Arguments to filter BudgetDetails to count.
     * @example
     * // Count the number of BudgetDetails
     * const count = await prisma.budgetDetail.count({
     *   where: {
     *     // ... the filter for the BudgetDetails we want to count
     *   }
     * })
    **/
    count<T extends BudgetDetailCountArgs>(
      args?: Subset<T, BudgetDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetDetailAggregateArgs>(args: Subset<T, BudgetDetailAggregateArgs>): Prisma.PrismaPromise<GetBudgetDetailAggregateType<T>>

    /**
     * Group by BudgetDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetDetailGroupByArgs['orderBy'] }
        : { orderBy?: BudgetDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetDetail model
   */
  readonly fields: BudgetDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    planningVersions<T extends BudgetDetail$planningVersionsArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDetail$planningVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findMany"> | Null>
    allocationRecommendations<T extends BudgetDetail$allocationRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDetail$allocationRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    skuRecommendations<T extends BudgetDetail$skuRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDetail$skuRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetDetail model
   */ 
  interface BudgetDetailFieldRefs {
    readonly id: FieldRef<"BudgetDetail", 'String'>
    readonly budgetId: FieldRef<"BudgetDetail", 'String'>
    readonly storeId: FieldRef<"BudgetDetail", 'String'>
    readonly budgetAmount: FieldRef<"BudgetDetail", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BudgetDetail findUnique
   */
  export type BudgetDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * Filter, which BudgetDetail to fetch.
     */
    where: BudgetDetailWhereUniqueInput
  }

  /**
   * BudgetDetail findUniqueOrThrow
   */
  export type BudgetDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * Filter, which BudgetDetail to fetch.
     */
    where: BudgetDetailWhereUniqueInput
  }

  /**
   * BudgetDetail findFirst
   */
  export type BudgetDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * Filter, which BudgetDetail to fetch.
     */
    where?: BudgetDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetDetails to fetch.
     */
    orderBy?: BudgetDetailOrderByWithRelationInput | BudgetDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetDetails.
     */
    cursor?: BudgetDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetDetails.
     */
    distinct?: BudgetDetailScalarFieldEnum | BudgetDetailScalarFieldEnum[]
  }

  /**
   * BudgetDetail findFirstOrThrow
   */
  export type BudgetDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * Filter, which BudgetDetail to fetch.
     */
    where?: BudgetDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetDetails to fetch.
     */
    orderBy?: BudgetDetailOrderByWithRelationInput | BudgetDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetDetails.
     */
    cursor?: BudgetDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetDetails.
     */
    distinct?: BudgetDetailScalarFieldEnum | BudgetDetailScalarFieldEnum[]
  }

  /**
   * BudgetDetail findMany
   */
  export type BudgetDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * Filter, which BudgetDetails to fetch.
     */
    where?: BudgetDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetDetails to fetch.
     */
    orderBy?: BudgetDetailOrderByWithRelationInput | BudgetDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetDetails.
     */
    cursor?: BudgetDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetDetails.
     */
    skip?: number
    distinct?: BudgetDetailScalarFieldEnum | BudgetDetailScalarFieldEnum[]
  }

  /**
   * BudgetDetail create
   */
  export type BudgetDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetDetail.
     */
    data: XOR<BudgetDetailCreateInput, BudgetDetailUncheckedCreateInput>
  }

  /**
   * BudgetDetail createMany
   */
  export type BudgetDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetDetails.
     */
    data: BudgetDetailCreateManyInput | BudgetDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetDetail createManyAndReturn
   */
  export type BudgetDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BudgetDetails.
     */
    data: BudgetDetailCreateManyInput | BudgetDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetDetail update
   */
  export type BudgetDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetDetail.
     */
    data: XOR<BudgetDetailUpdateInput, BudgetDetailUncheckedUpdateInput>
    /**
     * Choose, which BudgetDetail to update.
     */
    where: BudgetDetailWhereUniqueInput
  }

  /**
   * BudgetDetail updateMany
   */
  export type BudgetDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetDetails.
     */
    data: XOR<BudgetDetailUpdateManyMutationInput, BudgetDetailUncheckedUpdateManyInput>
    /**
     * Filter which BudgetDetails to update
     */
    where?: BudgetDetailWhereInput
  }

  /**
   * BudgetDetail upsert
   */
  export type BudgetDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetDetail to update in case it exists.
     */
    where: BudgetDetailWhereUniqueInput
    /**
     * In case the BudgetDetail found by the `where` argument doesn't exist, create a new BudgetDetail with this data.
     */
    create: XOR<BudgetDetailCreateInput, BudgetDetailUncheckedCreateInput>
    /**
     * In case the BudgetDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetDetailUpdateInput, BudgetDetailUncheckedUpdateInput>
  }

  /**
   * BudgetDetail delete
   */
  export type BudgetDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
    /**
     * Filter which BudgetDetail to delete.
     */
    where: BudgetDetailWhereUniqueInput
  }

  /**
   * BudgetDetail deleteMany
   */
  export type BudgetDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetDetails to delete
     */
    where?: BudgetDetailWhereInput
  }

  /**
   * BudgetDetail.planningVersions
   */
  export type BudgetDetail$planningVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    where?: PlanningVersionWhereInput
    orderBy?: PlanningVersionOrderByWithRelationInput | PlanningVersionOrderByWithRelationInput[]
    cursor?: PlanningVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningVersionScalarFieldEnum | PlanningVersionScalarFieldEnum[]
  }

  /**
   * BudgetDetail.allocationRecommendations
   */
  export type BudgetDetail$allocationRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    where?: AllocationRecommendationWhereInput
    orderBy?: AllocationRecommendationOrderByWithRelationInput | AllocationRecommendationOrderByWithRelationInput[]
    cursor?: AllocationRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllocationRecommendationScalarFieldEnum | AllocationRecommendationScalarFieldEnum[]
  }

  /**
   * BudgetDetail.skuRecommendations
   */
  export type BudgetDetail$skuRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    where?: SkuRecommendationWhereInput
    orderBy?: SkuRecommendationOrderByWithRelationInput | SkuRecommendationOrderByWithRelationInput[]
    cursor?: SkuRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkuRecommendationScalarFieldEnum | SkuRecommendationScalarFieldEnum[]
  }

  /**
   * BudgetDetail without action
   */
  export type BudgetDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetDetail
     */
    select?: BudgetDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetDetailInclude<ExtArgs> | null
  }


  /**
   * Model PlanningVersion
   */

  export type AggregatePlanningVersion = {
    _count: PlanningVersionCountAggregateOutputType | null
    _avg: PlanningVersionAvgAggregateOutputType | null
    _sum: PlanningVersionSumAggregateOutputType | null
    _min: PlanningVersionMinAggregateOutputType | null
    _max: PlanningVersionMaxAggregateOutputType | null
  }

  export type PlanningVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type PlanningVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type PlanningVersionMinAggregateOutputType = {
    id: string | null
    planningCode: string | null
    budgetDetailId: string | null
    versionNumber: number | null
    versionName: string | null
    status: $Enums.PlanningStatus | null
    isFinal: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanningVersionMaxAggregateOutputType = {
    id: string | null
    planningCode: string | null
    budgetDetailId: string | null
    versionNumber: number | null
    versionName: string | null
    status: $Enums.PlanningStatus | null
    isFinal: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanningVersionCountAggregateOutputType = {
    id: number
    planningCode: number
    budgetDetailId: number
    versionNumber: number
    versionName: number
    status: number
    isFinal: number
    snapshotData: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanningVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type PlanningVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type PlanningVersionMinAggregateInputType = {
    id?: true
    planningCode?: true
    budgetDetailId?: true
    versionNumber?: true
    versionName?: true
    status?: true
    isFinal?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanningVersionMaxAggregateInputType = {
    id?: true
    planningCode?: true
    budgetDetailId?: true
    versionNumber?: true
    versionName?: true
    status?: true
    isFinal?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanningVersionCountAggregateInputType = {
    id?: true
    planningCode?: true
    budgetDetailId?: true
    versionNumber?: true
    versionName?: true
    status?: true
    isFinal?: true
    snapshotData?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanningVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanningVersion to aggregate.
     */
    where?: PlanningVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningVersions to fetch.
     */
    orderBy?: PlanningVersionOrderByWithRelationInput | PlanningVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanningVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanningVersions
    **/
    _count?: true | PlanningVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanningVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanningVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanningVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanningVersionMaxAggregateInputType
  }

  export type GetPlanningVersionAggregateType<T extends PlanningVersionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanningVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanningVersion[P]>
      : GetScalarType<T[P], AggregatePlanningVersion[P]>
  }




  export type PlanningVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningVersionWhereInput
    orderBy?: PlanningVersionOrderByWithAggregationInput | PlanningVersionOrderByWithAggregationInput[]
    by: PlanningVersionScalarFieldEnum[] | PlanningVersionScalarFieldEnum
    having?: PlanningVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanningVersionCountAggregateInputType | true
    _avg?: PlanningVersionAvgAggregateInputType
    _sum?: PlanningVersionSumAggregateInputType
    _min?: PlanningVersionMinAggregateInputType
    _max?: PlanningVersionMaxAggregateInputType
  }

  export type PlanningVersionGroupByOutputType = {
    id: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName: string | null
    status: $Enums.PlanningStatus
    isFinal: boolean
    snapshotData: JsonValue | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: PlanningVersionCountAggregateOutputType | null
    _avg: PlanningVersionAvgAggregateOutputType | null
    _sum: PlanningVersionSumAggregateOutputType | null
    _min: PlanningVersionMinAggregateOutputType | null
    _max: PlanningVersionMaxAggregateOutputType | null
  }

  type GetPlanningVersionGroupByPayload<T extends PlanningVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanningVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanningVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanningVersionGroupByOutputType[P]>
            : GetScalarType<T[P], PlanningVersionGroupByOutputType[P]>
        }
      >
    >


  export type PlanningVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planningCode?: boolean
    budgetDetailId?: boolean
    versionNumber?: boolean
    versionName?: boolean
    status?: boolean
    isFinal?: boolean
    snapshotData?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | PlanningVersion$detailsArgs<ExtArgs>
    proposals?: boolean | PlanningVersion$proposalsArgs<ExtArgs>
    _count?: boolean | PlanningVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planningVersion"]>

  export type PlanningVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planningCode?: boolean
    budgetDetailId?: boolean
    versionNumber?: boolean
    versionName?: boolean
    status?: boolean
    isFinal?: boolean
    snapshotData?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planningVersion"]>

  export type PlanningVersionSelectScalar = {
    id?: boolean
    planningCode?: boolean
    budgetDetailId?: boolean
    versionNumber?: boolean
    versionName?: boolean
    status?: boolean
    isFinal?: boolean
    snapshotData?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanningVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    details?: boolean | PlanningVersion$detailsArgs<ExtArgs>
    proposals?: boolean | PlanningVersion$proposalsArgs<ExtArgs>
    _count?: boolean | PlanningVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanningVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlanningVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanningVersion"
    objects: {
      budgetDetail: Prisma.$BudgetDetailPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      details: Prisma.$PlanningDetailPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planningCode: string
      budgetDetailId: string
      versionNumber: number
      versionName: string | null
      status: $Enums.PlanningStatus
      isFinal: boolean
      snapshotData: Prisma.JsonValue | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planningVersion"]>
    composites: {}
  }

  type PlanningVersionGetPayload<S extends boolean | null | undefined | PlanningVersionDefaultArgs> = $Result.GetResult<Prisma.$PlanningVersionPayload, S>

  type PlanningVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanningVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanningVersionCountAggregateInputType | true
    }

  export interface PlanningVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanningVersion'], meta: { name: 'PlanningVersion' } }
    /**
     * Find zero or one PlanningVersion that matches the filter.
     * @param {PlanningVersionFindUniqueArgs} args - Arguments to find a PlanningVersion
     * @example
     * // Get one PlanningVersion
     * const planningVersion = await prisma.planningVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanningVersionFindUniqueArgs>(args: SelectSubset<T, PlanningVersionFindUniqueArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanningVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanningVersionFindUniqueOrThrowArgs} args - Arguments to find a PlanningVersion
     * @example
     * // Get one PlanningVersion
     * const planningVersion = await prisma.planningVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanningVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanningVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanningVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionFindFirstArgs} args - Arguments to find a PlanningVersion
     * @example
     * // Get one PlanningVersion
     * const planningVersion = await prisma.planningVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanningVersionFindFirstArgs>(args?: SelectSubset<T, PlanningVersionFindFirstArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanningVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionFindFirstOrThrowArgs} args - Arguments to find a PlanningVersion
     * @example
     * // Get one PlanningVersion
     * const planningVersion = await prisma.planningVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanningVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanningVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanningVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanningVersions
     * const planningVersions = await prisma.planningVersion.findMany()
     * 
     * // Get first 10 PlanningVersions
     * const planningVersions = await prisma.planningVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planningVersionWithIdOnly = await prisma.planningVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanningVersionFindManyArgs>(args?: SelectSubset<T, PlanningVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanningVersion.
     * @param {PlanningVersionCreateArgs} args - Arguments to create a PlanningVersion.
     * @example
     * // Create one PlanningVersion
     * const PlanningVersion = await prisma.planningVersion.create({
     *   data: {
     *     // ... data to create a PlanningVersion
     *   }
     * })
     * 
     */
    create<T extends PlanningVersionCreateArgs>(args: SelectSubset<T, PlanningVersionCreateArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanningVersions.
     * @param {PlanningVersionCreateManyArgs} args - Arguments to create many PlanningVersions.
     * @example
     * // Create many PlanningVersions
     * const planningVersion = await prisma.planningVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanningVersionCreateManyArgs>(args?: SelectSubset<T, PlanningVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanningVersions and returns the data saved in the database.
     * @param {PlanningVersionCreateManyAndReturnArgs} args - Arguments to create many PlanningVersions.
     * @example
     * // Create many PlanningVersions
     * const planningVersion = await prisma.planningVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanningVersions and only return the `id`
     * const planningVersionWithIdOnly = await prisma.planningVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanningVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanningVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanningVersion.
     * @param {PlanningVersionDeleteArgs} args - Arguments to delete one PlanningVersion.
     * @example
     * // Delete one PlanningVersion
     * const PlanningVersion = await prisma.planningVersion.delete({
     *   where: {
     *     // ... filter to delete one PlanningVersion
     *   }
     * })
     * 
     */
    delete<T extends PlanningVersionDeleteArgs>(args: SelectSubset<T, PlanningVersionDeleteArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanningVersion.
     * @param {PlanningVersionUpdateArgs} args - Arguments to update one PlanningVersion.
     * @example
     * // Update one PlanningVersion
     * const planningVersion = await prisma.planningVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanningVersionUpdateArgs>(args: SelectSubset<T, PlanningVersionUpdateArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanningVersions.
     * @param {PlanningVersionDeleteManyArgs} args - Arguments to filter PlanningVersions to delete.
     * @example
     * // Delete a few PlanningVersions
     * const { count } = await prisma.planningVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanningVersionDeleteManyArgs>(args?: SelectSubset<T, PlanningVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanningVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanningVersions
     * const planningVersion = await prisma.planningVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanningVersionUpdateManyArgs>(args: SelectSubset<T, PlanningVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanningVersion.
     * @param {PlanningVersionUpsertArgs} args - Arguments to update or create a PlanningVersion.
     * @example
     * // Update or create a PlanningVersion
     * const planningVersion = await prisma.planningVersion.upsert({
     *   create: {
     *     // ... data to create a PlanningVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanningVersion we want to update
     *   }
     * })
     */
    upsert<T extends PlanningVersionUpsertArgs>(args: SelectSubset<T, PlanningVersionUpsertArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanningVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionCountArgs} args - Arguments to filter PlanningVersions to count.
     * @example
     * // Count the number of PlanningVersions
     * const count = await prisma.planningVersion.count({
     *   where: {
     *     // ... the filter for the PlanningVersions we want to count
     *   }
     * })
    **/
    count<T extends PlanningVersionCountArgs>(
      args?: Subset<T, PlanningVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanningVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanningVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanningVersionAggregateArgs>(args: Subset<T, PlanningVersionAggregateArgs>): Prisma.PrismaPromise<GetPlanningVersionAggregateType<T>>

    /**
     * Group by PlanningVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanningVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanningVersionGroupByArgs['orderBy'] }
        : { orderBy?: PlanningVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanningVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanningVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanningVersion model
   */
  readonly fields: PlanningVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanningVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanningVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budgetDetail<T extends BudgetDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDetailDefaultArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    details<T extends PlanningVersion$detailsArgs<ExtArgs> = {}>(args?: Subset<T, PlanningVersion$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findMany"> | Null>
    proposals<T extends PlanningVersion$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, PlanningVersion$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanningVersion model
   */ 
  interface PlanningVersionFieldRefs {
    readonly id: FieldRef<"PlanningVersion", 'String'>
    readonly planningCode: FieldRef<"PlanningVersion", 'String'>
    readonly budgetDetailId: FieldRef<"PlanningVersion", 'String'>
    readonly versionNumber: FieldRef<"PlanningVersion", 'Int'>
    readonly versionName: FieldRef<"PlanningVersion", 'String'>
    readonly status: FieldRef<"PlanningVersion", 'PlanningStatus'>
    readonly isFinal: FieldRef<"PlanningVersion", 'Boolean'>
    readonly snapshotData: FieldRef<"PlanningVersion", 'Json'>
    readonly createdById: FieldRef<"PlanningVersion", 'String'>
    readonly createdAt: FieldRef<"PlanningVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanningVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanningVersion findUnique
   */
  export type PlanningVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * Filter, which PlanningVersion to fetch.
     */
    where: PlanningVersionWhereUniqueInput
  }

  /**
   * PlanningVersion findUniqueOrThrow
   */
  export type PlanningVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * Filter, which PlanningVersion to fetch.
     */
    where: PlanningVersionWhereUniqueInput
  }

  /**
   * PlanningVersion findFirst
   */
  export type PlanningVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * Filter, which PlanningVersion to fetch.
     */
    where?: PlanningVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningVersions to fetch.
     */
    orderBy?: PlanningVersionOrderByWithRelationInput | PlanningVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanningVersions.
     */
    cursor?: PlanningVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanningVersions.
     */
    distinct?: PlanningVersionScalarFieldEnum | PlanningVersionScalarFieldEnum[]
  }

  /**
   * PlanningVersion findFirstOrThrow
   */
  export type PlanningVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * Filter, which PlanningVersion to fetch.
     */
    where?: PlanningVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningVersions to fetch.
     */
    orderBy?: PlanningVersionOrderByWithRelationInput | PlanningVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanningVersions.
     */
    cursor?: PlanningVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanningVersions.
     */
    distinct?: PlanningVersionScalarFieldEnum | PlanningVersionScalarFieldEnum[]
  }

  /**
   * PlanningVersion findMany
   */
  export type PlanningVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * Filter, which PlanningVersions to fetch.
     */
    where?: PlanningVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningVersions to fetch.
     */
    orderBy?: PlanningVersionOrderByWithRelationInput | PlanningVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanningVersions.
     */
    cursor?: PlanningVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningVersions.
     */
    skip?: number
    distinct?: PlanningVersionScalarFieldEnum | PlanningVersionScalarFieldEnum[]
  }

  /**
   * PlanningVersion create
   */
  export type PlanningVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanningVersion.
     */
    data: XOR<PlanningVersionCreateInput, PlanningVersionUncheckedCreateInput>
  }

  /**
   * PlanningVersion createMany
   */
  export type PlanningVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanningVersions.
     */
    data: PlanningVersionCreateManyInput | PlanningVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanningVersion createManyAndReturn
   */
  export type PlanningVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanningVersions.
     */
    data: PlanningVersionCreateManyInput | PlanningVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanningVersion update
   */
  export type PlanningVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanningVersion.
     */
    data: XOR<PlanningVersionUpdateInput, PlanningVersionUncheckedUpdateInput>
    /**
     * Choose, which PlanningVersion to update.
     */
    where: PlanningVersionWhereUniqueInput
  }

  /**
   * PlanningVersion updateMany
   */
  export type PlanningVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanningVersions.
     */
    data: XOR<PlanningVersionUpdateManyMutationInput, PlanningVersionUncheckedUpdateManyInput>
    /**
     * Filter which PlanningVersions to update
     */
    where?: PlanningVersionWhereInput
  }

  /**
   * PlanningVersion upsert
   */
  export type PlanningVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanningVersion to update in case it exists.
     */
    where: PlanningVersionWhereUniqueInput
    /**
     * In case the PlanningVersion found by the `where` argument doesn't exist, create a new PlanningVersion with this data.
     */
    create: XOR<PlanningVersionCreateInput, PlanningVersionUncheckedCreateInput>
    /**
     * In case the PlanningVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanningVersionUpdateInput, PlanningVersionUncheckedUpdateInput>
  }

  /**
   * PlanningVersion delete
   */
  export type PlanningVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    /**
     * Filter which PlanningVersion to delete.
     */
    where: PlanningVersionWhereUniqueInput
  }

  /**
   * PlanningVersion deleteMany
   */
  export type PlanningVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanningVersions to delete
     */
    where?: PlanningVersionWhereInput
  }

  /**
   * PlanningVersion.details
   */
  export type PlanningVersion$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    where?: PlanningDetailWhereInput
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    cursor?: PlanningDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * PlanningVersion.proposals
   */
  export type PlanningVersion$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * PlanningVersion without action
   */
  export type PlanningVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
  }


  /**
   * Model PlanningDetail
   */

  export type AggregatePlanningDetail = {
    _count: PlanningDetailCountAggregateOutputType | null
    _avg: PlanningDetailAvgAggregateOutputType | null
    _sum: PlanningDetailSumAggregateOutputType | null
    _min: PlanningDetailMinAggregateOutputType | null
    _max: PlanningDetailMaxAggregateOutputType | null
  }

  export type PlanningDetailAvgAggregateOutputType = {
    lastSeasonSales: Decimal | null
    lastSeasonPct: Decimal | null
    systemBuyPct: Decimal | null
    userBuyPct: Decimal | null
    otbValue: Decimal | null
    variancePct: Decimal | null
  }

  export type PlanningDetailSumAggregateOutputType = {
    lastSeasonSales: Decimal | null
    lastSeasonPct: Decimal | null
    systemBuyPct: Decimal | null
    userBuyPct: Decimal | null
    otbValue: Decimal | null
    variancePct: Decimal | null
  }

  export type PlanningDetailMinAggregateOutputType = {
    id: string | null
    planningVersionId: string | null
    dimensionType: string | null
    collectionId: string | null
    genderId: string | null
    categoryId: string | null
    subCategoryId: string | null
    lastSeasonSales: Decimal | null
    lastSeasonPct: Decimal | null
    systemBuyPct: Decimal | null
    userBuyPct: Decimal | null
    otbValue: Decimal | null
    variancePct: Decimal | null
    userComment: string | null
  }

  export type PlanningDetailMaxAggregateOutputType = {
    id: string | null
    planningVersionId: string | null
    dimensionType: string | null
    collectionId: string | null
    genderId: string | null
    categoryId: string | null
    subCategoryId: string | null
    lastSeasonSales: Decimal | null
    lastSeasonPct: Decimal | null
    systemBuyPct: Decimal | null
    userBuyPct: Decimal | null
    otbValue: Decimal | null
    variancePct: Decimal | null
    userComment: string | null
  }

  export type PlanningDetailCountAggregateOutputType = {
    id: number
    planningVersionId: number
    dimensionType: number
    collectionId: number
    genderId: number
    categoryId: number
    subCategoryId: number
    lastSeasonSales: number
    lastSeasonPct: number
    systemBuyPct: number
    userBuyPct: number
    otbValue: number
    variancePct: number
    userComment: number
    _all: number
  }


  export type PlanningDetailAvgAggregateInputType = {
    lastSeasonSales?: true
    lastSeasonPct?: true
    systemBuyPct?: true
    userBuyPct?: true
    otbValue?: true
    variancePct?: true
  }

  export type PlanningDetailSumAggregateInputType = {
    lastSeasonSales?: true
    lastSeasonPct?: true
    systemBuyPct?: true
    userBuyPct?: true
    otbValue?: true
    variancePct?: true
  }

  export type PlanningDetailMinAggregateInputType = {
    id?: true
    planningVersionId?: true
    dimensionType?: true
    collectionId?: true
    genderId?: true
    categoryId?: true
    subCategoryId?: true
    lastSeasonSales?: true
    lastSeasonPct?: true
    systemBuyPct?: true
    userBuyPct?: true
    otbValue?: true
    variancePct?: true
    userComment?: true
  }

  export type PlanningDetailMaxAggregateInputType = {
    id?: true
    planningVersionId?: true
    dimensionType?: true
    collectionId?: true
    genderId?: true
    categoryId?: true
    subCategoryId?: true
    lastSeasonSales?: true
    lastSeasonPct?: true
    systemBuyPct?: true
    userBuyPct?: true
    otbValue?: true
    variancePct?: true
    userComment?: true
  }

  export type PlanningDetailCountAggregateInputType = {
    id?: true
    planningVersionId?: true
    dimensionType?: true
    collectionId?: true
    genderId?: true
    categoryId?: true
    subCategoryId?: true
    lastSeasonSales?: true
    lastSeasonPct?: true
    systemBuyPct?: true
    userBuyPct?: true
    otbValue?: true
    variancePct?: true
    userComment?: true
    _all?: true
  }

  export type PlanningDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanningDetail to aggregate.
     */
    where?: PlanningDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningDetails to fetch.
     */
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanningDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanningDetails
    **/
    _count?: true | PlanningDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanningDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanningDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanningDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanningDetailMaxAggregateInputType
  }

  export type GetPlanningDetailAggregateType<T extends PlanningDetailAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanningDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanningDetail[P]>
      : GetScalarType<T[P], AggregatePlanningDetail[P]>
  }




  export type PlanningDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningDetailWhereInput
    orderBy?: PlanningDetailOrderByWithAggregationInput | PlanningDetailOrderByWithAggregationInput[]
    by: PlanningDetailScalarFieldEnum[] | PlanningDetailScalarFieldEnum
    having?: PlanningDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanningDetailCountAggregateInputType | true
    _avg?: PlanningDetailAvgAggregateInputType
    _sum?: PlanningDetailSumAggregateInputType
    _min?: PlanningDetailMinAggregateInputType
    _max?: PlanningDetailMaxAggregateInputType
  }

  export type PlanningDetailGroupByOutputType = {
    id: string
    planningVersionId: string
    dimensionType: string
    collectionId: string | null
    genderId: string | null
    categoryId: string | null
    subCategoryId: string | null
    lastSeasonSales: Decimal
    lastSeasonPct: Decimal
    systemBuyPct: Decimal
    userBuyPct: Decimal
    otbValue: Decimal
    variancePct: Decimal
    userComment: string | null
    _count: PlanningDetailCountAggregateOutputType | null
    _avg: PlanningDetailAvgAggregateOutputType | null
    _sum: PlanningDetailSumAggregateOutputType | null
    _min: PlanningDetailMinAggregateOutputType | null
    _max: PlanningDetailMaxAggregateOutputType | null
  }

  type GetPlanningDetailGroupByPayload<T extends PlanningDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanningDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanningDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanningDetailGroupByOutputType[P]>
            : GetScalarType<T[P], PlanningDetailGroupByOutputType[P]>
        }
      >
    >


  export type PlanningDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planningVersionId?: boolean
    dimensionType?: boolean
    collectionId?: boolean
    genderId?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    lastSeasonSales?: boolean
    lastSeasonPct?: boolean
    systemBuyPct?: boolean
    userBuyPct?: boolean
    otbValue?: boolean
    variancePct?: boolean
    userComment?: boolean
    planningVersion?: boolean | PlanningVersionDefaultArgs<ExtArgs>
    collection?: boolean | PlanningDetail$collectionArgs<ExtArgs>
    gender?: boolean | PlanningDetail$genderArgs<ExtArgs>
    category?: boolean | PlanningDetail$categoryArgs<ExtArgs>
    subCategory?: boolean | PlanningDetail$subCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["planningDetail"]>

  export type PlanningDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planningVersionId?: boolean
    dimensionType?: boolean
    collectionId?: boolean
    genderId?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    lastSeasonSales?: boolean
    lastSeasonPct?: boolean
    systemBuyPct?: boolean
    userBuyPct?: boolean
    otbValue?: boolean
    variancePct?: boolean
    userComment?: boolean
    planningVersion?: boolean | PlanningVersionDefaultArgs<ExtArgs>
    collection?: boolean | PlanningDetail$collectionArgs<ExtArgs>
    gender?: boolean | PlanningDetail$genderArgs<ExtArgs>
    category?: boolean | PlanningDetail$categoryArgs<ExtArgs>
    subCategory?: boolean | PlanningDetail$subCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["planningDetail"]>

  export type PlanningDetailSelectScalar = {
    id?: boolean
    planningVersionId?: boolean
    dimensionType?: boolean
    collectionId?: boolean
    genderId?: boolean
    categoryId?: boolean
    subCategoryId?: boolean
    lastSeasonSales?: boolean
    lastSeasonPct?: boolean
    systemBuyPct?: boolean
    userBuyPct?: boolean
    otbValue?: boolean
    variancePct?: boolean
    userComment?: boolean
  }

  export type PlanningDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planningVersion?: boolean | PlanningVersionDefaultArgs<ExtArgs>
    collection?: boolean | PlanningDetail$collectionArgs<ExtArgs>
    gender?: boolean | PlanningDetail$genderArgs<ExtArgs>
    category?: boolean | PlanningDetail$categoryArgs<ExtArgs>
    subCategory?: boolean | PlanningDetail$subCategoryArgs<ExtArgs>
  }
  export type PlanningDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planningVersion?: boolean | PlanningVersionDefaultArgs<ExtArgs>
    collection?: boolean | PlanningDetail$collectionArgs<ExtArgs>
    gender?: boolean | PlanningDetail$genderArgs<ExtArgs>
    category?: boolean | PlanningDetail$categoryArgs<ExtArgs>
    subCategory?: boolean | PlanningDetail$subCategoryArgs<ExtArgs>
  }

  export type $PlanningDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanningDetail"
    objects: {
      planningVersion: Prisma.$PlanningVersionPayload<ExtArgs>
      collection: Prisma.$CollectionPayload<ExtArgs> | null
      gender: Prisma.$GenderPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
      subCategory: Prisma.$SubCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planningVersionId: string
      dimensionType: string
      collectionId: string | null
      genderId: string | null
      categoryId: string | null
      subCategoryId: string | null
      lastSeasonSales: Prisma.Decimal
      lastSeasonPct: Prisma.Decimal
      systemBuyPct: Prisma.Decimal
      userBuyPct: Prisma.Decimal
      otbValue: Prisma.Decimal
      variancePct: Prisma.Decimal
      userComment: string | null
    }, ExtArgs["result"]["planningDetail"]>
    composites: {}
  }

  type PlanningDetailGetPayload<S extends boolean | null | undefined | PlanningDetailDefaultArgs> = $Result.GetResult<Prisma.$PlanningDetailPayload, S>

  type PlanningDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanningDetailFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanningDetailCountAggregateInputType | true
    }

  export interface PlanningDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanningDetail'], meta: { name: 'PlanningDetail' } }
    /**
     * Find zero or one PlanningDetail that matches the filter.
     * @param {PlanningDetailFindUniqueArgs} args - Arguments to find a PlanningDetail
     * @example
     * // Get one PlanningDetail
     * const planningDetail = await prisma.planningDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanningDetailFindUniqueArgs>(args: SelectSubset<T, PlanningDetailFindUniqueArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlanningDetail that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanningDetailFindUniqueOrThrowArgs} args - Arguments to find a PlanningDetail
     * @example
     * // Get one PlanningDetail
     * const planningDetail = await prisma.planningDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanningDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanningDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlanningDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailFindFirstArgs} args - Arguments to find a PlanningDetail
     * @example
     * // Get one PlanningDetail
     * const planningDetail = await prisma.planningDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanningDetailFindFirstArgs>(args?: SelectSubset<T, PlanningDetailFindFirstArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlanningDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailFindFirstOrThrowArgs} args - Arguments to find a PlanningDetail
     * @example
     * // Get one PlanningDetail
     * const planningDetail = await prisma.planningDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanningDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanningDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlanningDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanningDetails
     * const planningDetails = await prisma.planningDetail.findMany()
     * 
     * // Get first 10 PlanningDetails
     * const planningDetails = await prisma.planningDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planningDetailWithIdOnly = await prisma.planningDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanningDetailFindManyArgs>(args?: SelectSubset<T, PlanningDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlanningDetail.
     * @param {PlanningDetailCreateArgs} args - Arguments to create a PlanningDetail.
     * @example
     * // Create one PlanningDetail
     * const PlanningDetail = await prisma.planningDetail.create({
     *   data: {
     *     // ... data to create a PlanningDetail
     *   }
     * })
     * 
     */
    create<T extends PlanningDetailCreateArgs>(args: SelectSubset<T, PlanningDetailCreateArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlanningDetails.
     * @param {PlanningDetailCreateManyArgs} args - Arguments to create many PlanningDetails.
     * @example
     * // Create many PlanningDetails
     * const planningDetail = await prisma.planningDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanningDetailCreateManyArgs>(args?: SelectSubset<T, PlanningDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanningDetails and returns the data saved in the database.
     * @param {PlanningDetailCreateManyAndReturnArgs} args - Arguments to create many PlanningDetails.
     * @example
     * // Create many PlanningDetails
     * const planningDetail = await prisma.planningDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanningDetails and only return the `id`
     * const planningDetailWithIdOnly = await prisma.planningDetail.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanningDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanningDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlanningDetail.
     * @param {PlanningDetailDeleteArgs} args - Arguments to delete one PlanningDetail.
     * @example
     * // Delete one PlanningDetail
     * const PlanningDetail = await prisma.planningDetail.delete({
     *   where: {
     *     // ... filter to delete one PlanningDetail
     *   }
     * })
     * 
     */
    delete<T extends PlanningDetailDeleteArgs>(args: SelectSubset<T, PlanningDetailDeleteArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlanningDetail.
     * @param {PlanningDetailUpdateArgs} args - Arguments to update one PlanningDetail.
     * @example
     * // Update one PlanningDetail
     * const planningDetail = await prisma.planningDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanningDetailUpdateArgs>(args: SelectSubset<T, PlanningDetailUpdateArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlanningDetails.
     * @param {PlanningDetailDeleteManyArgs} args - Arguments to filter PlanningDetails to delete.
     * @example
     * // Delete a few PlanningDetails
     * const { count } = await prisma.planningDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanningDetailDeleteManyArgs>(args?: SelectSubset<T, PlanningDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanningDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanningDetails
     * const planningDetail = await prisma.planningDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanningDetailUpdateManyArgs>(args: SelectSubset<T, PlanningDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlanningDetail.
     * @param {PlanningDetailUpsertArgs} args - Arguments to update or create a PlanningDetail.
     * @example
     * // Update or create a PlanningDetail
     * const planningDetail = await prisma.planningDetail.upsert({
     *   create: {
     *     // ... data to create a PlanningDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanningDetail we want to update
     *   }
     * })
     */
    upsert<T extends PlanningDetailUpsertArgs>(args: SelectSubset<T, PlanningDetailUpsertArgs<ExtArgs>>): Prisma__PlanningDetailClient<$Result.GetResult<Prisma.$PlanningDetailPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlanningDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailCountArgs} args - Arguments to filter PlanningDetails to count.
     * @example
     * // Count the number of PlanningDetails
     * const count = await prisma.planningDetail.count({
     *   where: {
     *     // ... the filter for the PlanningDetails we want to count
     *   }
     * })
    **/
    count<T extends PlanningDetailCountArgs>(
      args?: Subset<T, PlanningDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanningDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanningDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanningDetailAggregateArgs>(args: Subset<T, PlanningDetailAggregateArgs>): Prisma.PrismaPromise<GetPlanningDetailAggregateType<T>>

    /**
     * Group by PlanningDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanningDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanningDetailGroupByArgs['orderBy'] }
        : { orderBy?: PlanningDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanningDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanningDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanningDetail model
   */
  readonly fields: PlanningDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanningDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanningDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planningVersion<T extends PlanningVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanningVersionDefaultArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    collection<T extends PlanningDetail$collectionArgs<ExtArgs> = {}>(args?: Subset<T, PlanningDetail$collectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    gender<T extends PlanningDetail$genderArgs<ExtArgs> = {}>(args?: Subset<T, PlanningDetail$genderArgs<ExtArgs>>): Prisma__GenderClient<$Result.GetResult<Prisma.$GenderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    category<T extends PlanningDetail$categoryArgs<ExtArgs> = {}>(args?: Subset<T, PlanningDetail$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subCategory<T extends PlanningDetail$subCategoryArgs<ExtArgs> = {}>(args?: Subset<T, PlanningDetail$subCategoryArgs<ExtArgs>>): Prisma__SubCategoryClient<$Result.GetResult<Prisma.$SubCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanningDetail model
   */ 
  interface PlanningDetailFieldRefs {
    readonly id: FieldRef<"PlanningDetail", 'String'>
    readonly planningVersionId: FieldRef<"PlanningDetail", 'String'>
    readonly dimensionType: FieldRef<"PlanningDetail", 'String'>
    readonly collectionId: FieldRef<"PlanningDetail", 'String'>
    readonly genderId: FieldRef<"PlanningDetail", 'String'>
    readonly categoryId: FieldRef<"PlanningDetail", 'String'>
    readonly subCategoryId: FieldRef<"PlanningDetail", 'String'>
    readonly lastSeasonSales: FieldRef<"PlanningDetail", 'Decimal'>
    readonly lastSeasonPct: FieldRef<"PlanningDetail", 'Decimal'>
    readonly systemBuyPct: FieldRef<"PlanningDetail", 'Decimal'>
    readonly userBuyPct: FieldRef<"PlanningDetail", 'Decimal'>
    readonly otbValue: FieldRef<"PlanningDetail", 'Decimal'>
    readonly variancePct: FieldRef<"PlanningDetail", 'Decimal'>
    readonly userComment: FieldRef<"PlanningDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlanningDetail findUnique
   */
  export type PlanningDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * Filter, which PlanningDetail to fetch.
     */
    where: PlanningDetailWhereUniqueInput
  }

  /**
   * PlanningDetail findUniqueOrThrow
   */
  export type PlanningDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * Filter, which PlanningDetail to fetch.
     */
    where: PlanningDetailWhereUniqueInput
  }

  /**
   * PlanningDetail findFirst
   */
  export type PlanningDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * Filter, which PlanningDetail to fetch.
     */
    where?: PlanningDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningDetails to fetch.
     */
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanningDetails.
     */
    cursor?: PlanningDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanningDetails.
     */
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * PlanningDetail findFirstOrThrow
   */
  export type PlanningDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * Filter, which PlanningDetail to fetch.
     */
    where?: PlanningDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningDetails to fetch.
     */
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanningDetails.
     */
    cursor?: PlanningDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanningDetails.
     */
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * PlanningDetail findMany
   */
  export type PlanningDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * Filter, which PlanningDetails to fetch.
     */
    where?: PlanningDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanningDetails to fetch.
     */
    orderBy?: PlanningDetailOrderByWithRelationInput | PlanningDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanningDetails.
     */
    cursor?: PlanningDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanningDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanningDetails.
     */
    skip?: number
    distinct?: PlanningDetailScalarFieldEnum | PlanningDetailScalarFieldEnum[]
  }

  /**
   * PlanningDetail create
   */
  export type PlanningDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanningDetail.
     */
    data: XOR<PlanningDetailCreateInput, PlanningDetailUncheckedCreateInput>
  }

  /**
   * PlanningDetail createMany
   */
  export type PlanningDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanningDetails.
     */
    data: PlanningDetailCreateManyInput | PlanningDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanningDetail createManyAndReturn
   */
  export type PlanningDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlanningDetails.
     */
    data: PlanningDetailCreateManyInput | PlanningDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanningDetail update
   */
  export type PlanningDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanningDetail.
     */
    data: XOR<PlanningDetailUpdateInput, PlanningDetailUncheckedUpdateInput>
    /**
     * Choose, which PlanningDetail to update.
     */
    where: PlanningDetailWhereUniqueInput
  }

  /**
   * PlanningDetail updateMany
   */
  export type PlanningDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanningDetails.
     */
    data: XOR<PlanningDetailUpdateManyMutationInput, PlanningDetailUncheckedUpdateManyInput>
    /**
     * Filter which PlanningDetails to update
     */
    where?: PlanningDetailWhereInput
  }

  /**
   * PlanningDetail upsert
   */
  export type PlanningDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanningDetail to update in case it exists.
     */
    where: PlanningDetailWhereUniqueInput
    /**
     * In case the PlanningDetail found by the `where` argument doesn't exist, create a new PlanningDetail with this data.
     */
    create: XOR<PlanningDetailCreateInput, PlanningDetailUncheckedCreateInput>
    /**
     * In case the PlanningDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanningDetailUpdateInput, PlanningDetailUncheckedUpdateInput>
  }

  /**
   * PlanningDetail delete
   */
  export type PlanningDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
    /**
     * Filter which PlanningDetail to delete.
     */
    where: PlanningDetailWhereUniqueInput
  }

  /**
   * PlanningDetail deleteMany
   */
  export type PlanningDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanningDetails to delete
     */
    where?: PlanningDetailWhereInput
  }

  /**
   * PlanningDetail.collection
   */
  export type PlanningDetail$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * PlanningDetail.gender
   */
  export type PlanningDetail$genderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenderInclude<ExtArgs> | null
    where?: GenderWhereInput
  }

  /**
   * PlanningDetail.category
   */
  export type PlanningDetail$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * PlanningDetail.subCategory
   */
  export type PlanningDetail$subCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubCategoryInclude<ExtArgs> | null
    where?: SubCategoryWhereInput
  }

  /**
   * PlanningDetail without action
   */
  export type PlanningDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningDetail
     */
    select?: PlanningDetailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningDetailInclude<ExtArgs> | null
  }


  /**
   * Model Proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    totalSkuCount: number | null
    totalOrderQty: number | null
    totalValue: Decimal | null
  }

  export type ProposalSumAggregateOutputType = {
    totalSkuCount: number | null
    totalOrderQty: number | null
    totalValue: Decimal | null
  }

  export type ProposalMinAggregateOutputType = {
    id: string | null
    ticketName: string | null
    budgetId: string | null
    planningVersionId: string | null
    status: $Enums.ProposalStatus | null
    totalSkuCount: number | null
    totalOrderQty: number | null
    totalValue: Decimal | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: string | null
    ticketName: string | null
    budgetId: string | null
    planningVersionId: string | null
    status: $Enums.ProposalStatus | null
    totalSkuCount: number | null
    totalOrderQty: number | null
    totalValue: Decimal | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    ticketName: number
    budgetId: number
    planningVersionId: number
    status: number
    totalSkuCount: number
    totalOrderQty: number
    totalValue: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    totalSkuCount?: true
    totalOrderQty?: true
    totalValue?: true
  }

  export type ProposalSumAggregateInputType = {
    totalSkuCount?: true
    totalOrderQty?: true
    totalValue?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    ticketName?: true
    budgetId?: true
    planningVersionId?: true
    status?: true
    totalSkuCount?: true
    totalOrderQty?: true
    totalValue?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    ticketName?: true
    budgetId?: true
    planningVersionId?: true
    status?: true
    totalSkuCount?: true
    totalOrderQty?: true
    totalValue?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    ticketName?: true
    budgetId?: true
    planningVersionId?: true
    status?: true
    totalSkuCount?: true
    totalOrderQty?: true
    totalValue?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposal to aggregate.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type ProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithAggregationInput | ProposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    id: string
    ticketName: string
    budgetId: string
    planningVersionId: string | null
    status: $Enums.ProposalStatus
    totalSkuCount: number
    totalOrderQty: number
    totalValue: Decimal
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type ProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketName?: boolean
    budgetId?: boolean
    planningVersionId?: boolean
    status?: boolean
    totalSkuCount?: boolean
    totalOrderQty?: boolean
    totalValue?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    planningVersion?: boolean | Proposal$planningVersionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | Proposal$productsArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketName?: boolean
    budgetId?: boolean
    planningVersionId?: boolean
    status?: boolean
    totalSkuCount?: boolean
    totalOrderQty?: boolean
    totalValue?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    planningVersion?: boolean | Proposal$planningVersionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectScalar = {
    id?: boolean
    ticketName?: boolean
    budgetId?: boolean
    planningVersionId?: boolean
    status?: boolean
    totalSkuCount?: boolean
    totalOrderQty?: boolean
    totalValue?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    planningVersion?: boolean | Proposal$planningVersionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    products?: boolean | Proposal$productsArgs<ExtArgs>
    _count?: boolean | ProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
    planningVersion?: boolean | Proposal$planningVersionArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proposal"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
      planningVersion: Prisma.$PlanningVersionPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      products: Prisma.$ProposalProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketName: string
      budgetId: string
      planningVersionId: string | null
      status: $Enums.ProposalStatus
      totalSkuCount: number
      totalOrderQty: number
      totalValue: Prisma.Decimal
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type ProposalGetPayload<S extends boolean | null | undefined | ProposalDefaultArgs> = $Result.GetResult<Prisma.$ProposalPayload, S>

  type ProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProposalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface ProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proposal'], meta: { name: 'Proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalFindUniqueArgs>(args: SelectSubset<T, ProposalFindUniqueArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalFindFirstArgs>(args?: SelectSubset<T, ProposalFindFirstArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalFindManyArgs>(args?: SelectSubset<T, ProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends ProposalCreateArgs>(args: SelectSubset<T, ProposalCreateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proposals.
     * @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCreateManyArgs>(args?: SelectSubset<T, ProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proposals and returns the data saved in the database.
     * @param {ProposalCreateManyAndReturnArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends ProposalDeleteArgs>(args: SelectSubset<T, ProposalDeleteArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalUpdateArgs>(args: SelectSubset<T, ProposalUpdateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalDeleteManyArgs>(args?: SelectSubset<T, ProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalUpdateManyArgs>(args: SelectSubset<T, ProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends ProposalUpsertArgs>(args: SelectSubset<T, ProposalUpsertArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proposal model
   */
  readonly fields: ProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    planningVersion<T extends Proposal$planningVersionArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$planningVersionArgs<ExtArgs>>): Prisma__PlanningVersionClient<$Result.GetResult<Prisma.$PlanningVersionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    products<T extends Proposal$productsArgs<ExtArgs> = {}>(args?: Subset<T, Proposal$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proposal model
   */ 
  interface ProposalFieldRefs {
    readonly id: FieldRef<"Proposal", 'String'>
    readonly ticketName: FieldRef<"Proposal", 'String'>
    readonly budgetId: FieldRef<"Proposal", 'String'>
    readonly planningVersionId: FieldRef<"Proposal", 'String'>
    readonly status: FieldRef<"Proposal", 'ProposalStatus'>
    readonly totalSkuCount: FieldRef<"Proposal", 'Int'>
    readonly totalOrderQty: FieldRef<"Proposal", 'Int'>
    readonly totalValue: FieldRef<"Proposal", 'Decimal'>
    readonly createdById: FieldRef<"Proposal", 'String'>
    readonly createdAt: FieldRef<"Proposal", 'DateTime'>
    readonly updatedAt: FieldRef<"Proposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findUniqueOrThrow
   */
  export type ProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findFirstOrThrow
   */
  export type ProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposals to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal create
   */
  export type ProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a Proposal.
     */
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
  }

  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proposal createManyAndReturn
   */
  export type ProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal update
   */
  export type ProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a Proposal.
     */
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
  }

  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the Proposal to update in case it exists.
     */
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
     */
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
  }

  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter which Proposal to delete.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposals to delete
     */
    where?: ProposalWhereInput
  }

  /**
   * Proposal.planningVersion
   */
  export type Proposal$planningVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanningVersion
     */
    select?: PlanningVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningVersionInclude<ExtArgs> | null
    where?: PlanningVersionWhereInput
  }

  /**
   * Proposal.products
   */
  export type Proposal$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    where?: ProposalProductWhereInput
    orderBy?: ProposalProductOrderByWithRelationInput | ProposalProductOrderByWithRelationInput[]
    cursor?: ProposalProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalProductScalarFieldEnum | ProposalProductScalarFieldEnum[]
  }

  /**
   * Proposal without action
   */
  export type ProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
  }


  /**
   * Model ProposalProduct
   */

  export type AggregateProposalProduct = {
    _count: ProposalProductCountAggregateOutputType | null
    _avg: ProposalProductAvgAggregateOutputType | null
    _sum: ProposalProductSumAggregateOutputType | null
    _min: ProposalProductMinAggregateOutputType | null
    _max: ProposalProductMaxAggregateOutputType | null
  }

  export type ProposalProductAvgAggregateOutputType = {
    unitCost: Decimal | null
    srp: Decimal | null
    orderQty: number | null
    totalValue: Decimal | null
    sortOrder: number | null
  }

  export type ProposalProductSumAggregateOutputType = {
    unitCost: Decimal | null
    srp: Decimal | null
    orderQty: number | null
    totalValue: Decimal | null
    sortOrder: number | null
  }

  export type ProposalProductMinAggregateOutputType = {
    id: string | null
    proposalId: string | null
    skuId: string | null
    skuCode: string | null
    productName: string | null
    collection: string | null
    gender: string | null
    category: string | null
    subCategory: string | null
    theme: string | null
    color: string | null
    composition: string | null
    unitCost: Decimal | null
    srp: Decimal | null
    orderQty: number | null
    totalValue: Decimal | null
    customerTarget: string | null
    imageUrl: string | null
    sortOrder: number | null
  }

  export type ProposalProductMaxAggregateOutputType = {
    id: string | null
    proposalId: string | null
    skuId: string | null
    skuCode: string | null
    productName: string | null
    collection: string | null
    gender: string | null
    category: string | null
    subCategory: string | null
    theme: string | null
    color: string | null
    composition: string | null
    unitCost: Decimal | null
    srp: Decimal | null
    orderQty: number | null
    totalValue: Decimal | null
    customerTarget: string | null
    imageUrl: string | null
    sortOrder: number | null
  }

  export type ProposalProductCountAggregateOutputType = {
    id: number
    proposalId: number
    skuId: number
    skuCode: number
    productName: number
    collection: number
    gender: number
    category: number
    subCategory: number
    theme: number
    color: number
    composition: number
    unitCost: number
    srp: number
    orderQty: number
    totalValue: number
    customerTarget: number
    imageUrl: number
    sortOrder: number
    _all: number
  }


  export type ProposalProductAvgAggregateInputType = {
    unitCost?: true
    srp?: true
    orderQty?: true
    totalValue?: true
    sortOrder?: true
  }

  export type ProposalProductSumAggregateInputType = {
    unitCost?: true
    srp?: true
    orderQty?: true
    totalValue?: true
    sortOrder?: true
  }

  export type ProposalProductMinAggregateInputType = {
    id?: true
    proposalId?: true
    skuId?: true
    skuCode?: true
    productName?: true
    collection?: true
    gender?: true
    category?: true
    subCategory?: true
    theme?: true
    color?: true
    composition?: true
    unitCost?: true
    srp?: true
    orderQty?: true
    totalValue?: true
    customerTarget?: true
    imageUrl?: true
    sortOrder?: true
  }

  export type ProposalProductMaxAggregateInputType = {
    id?: true
    proposalId?: true
    skuId?: true
    skuCode?: true
    productName?: true
    collection?: true
    gender?: true
    category?: true
    subCategory?: true
    theme?: true
    color?: true
    composition?: true
    unitCost?: true
    srp?: true
    orderQty?: true
    totalValue?: true
    customerTarget?: true
    imageUrl?: true
    sortOrder?: true
  }

  export type ProposalProductCountAggregateInputType = {
    id?: true
    proposalId?: true
    skuId?: true
    skuCode?: true
    productName?: true
    collection?: true
    gender?: true
    category?: true
    subCategory?: true
    theme?: true
    color?: true
    composition?: true
    unitCost?: true
    srp?: true
    orderQty?: true
    totalValue?: true
    customerTarget?: true
    imageUrl?: true
    sortOrder?: true
    _all?: true
  }

  export type ProposalProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalProduct to aggregate.
     */
    where?: ProposalProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalProducts to fetch.
     */
    orderBy?: ProposalProductOrderByWithRelationInput | ProposalProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalProducts
    **/
    _count?: true | ProposalProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalProductMaxAggregateInputType
  }

  export type GetProposalProductAggregateType<T extends ProposalProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalProduct[P]>
      : GetScalarType<T[P], AggregateProposalProduct[P]>
  }




  export type ProposalProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalProductWhereInput
    orderBy?: ProposalProductOrderByWithAggregationInput | ProposalProductOrderByWithAggregationInput[]
    by: ProposalProductScalarFieldEnum[] | ProposalProductScalarFieldEnum
    having?: ProposalProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalProductCountAggregateInputType | true
    _avg?: ProposalProductAvgAggregateInputType
    _sum?: ProposalProductSumAggregateInputType
    _min?: ProposalProductMinAggregateInputType
    _max?: ProposalProductMaxAggregateInputType
  }

  export type ProposalProductGroupByOutputType = {
    id: string
    proposalId: string
    skuId: string
    skuCode: string
    productName: string
    collection: string | null
    gender: string | null
    category: string | null
    subCategory: string | null
    theme: string | null
    color: string | null
    composition: string | null
    unitCost: Decimal
    srp: Decimal
    orderQty: number
    totalValue: Decimal
    customerTarget: string | null
    imageUrl: string | null
    sortOrder: number
    _count: ProposalProductCountAggregateOutputType | null
    _avg: ProposalProductAvgAggregateOutputType | null
    _sum: ProposalProductSumAggregateOutputType | null
    _min: ProposalProductMinAggregateOutputType | null
    _max: ProposalProductMaxAggregateOutputType | null
  }

  type GetProposalProductGroupByPayload<T extends ProposalProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalProductGroupByOutputType[P]>
        }
      >
    >


  export type ProposalProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    skuId?: boolean
    skuCode?: boolean
    productName?: boolean
    collection?: boolean
    gender?: boolean
    category?: boolean
    subCategory?: boolean
    theme?: boolean
    color?: boolean
    composition?: boolean
    unitCost?: boolean
    srp?: boolean
    orderQty?: boolean
    totalValue?: boolean
    customerTarget?: boolean
    imageUrl?: boolean
    sortOrder?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    allocations?: boolean | ProposalProduct$allocationsArgs<ExtArgs>
    _count?: boolean | ProposalProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalProduct"]>

  export type ProposalProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    skuId?: boolean
    skuCode?: boolean
    productName?: boolean
    collection?: boolean
    gender?: boolean
    category?: boolean
    subCategory?: boolean
    theme?: boolean
    color?: boolean
    composition?: boolean
    unitCost?: boolean
    srp?: boolean
    orderQty?: boolean
    totalValue?: boolean
    customerTarget?: boolean
    imageUrl?: boolean
    sortOrder?: boolean
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalProduct"]>

  export type ProposalProductSelectScalar = {
    id?: boolean
    proposalId?: boolean
    skuId?: boolean
    skuCode?: boolean
    productName?: boolean
    collection?: boolean
    gender?: boolean
    category?: boolean
    subCategory?: boolean
    theme?: boolean
    color?: boolean
    composition?: boolean
    unitCost?: boolean
    srp?: boolean
    orderQty?: boolean
    totalValue?: boolean
    customerTarget?: boolean
    imageUrl?: boolean
    sortOrder?: boolean
  }

  export type ProposalProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    allocations?: boolean | ProposalProduct$allocationsArgs<ExtArgs>
    _count?: boolean | ProposalProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProposalProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | ProposalDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
  }

  export type $ProposalProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalProduct"
    objects: {
      proposal: Prisma.$ProposalPayload<ExtArgs>
      sku: Prisma.$SkuCatalogPayload<ExtArgs>
      allocations: Prisma.$ProductAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalId: string
      skuId: string
      skuCode: string
      productName: string
      collection: string | null
      gender: string | null
      category: string | null
      subCategory: string | null
      theme: string | null
      color: string | null
      composition: string | null
      unitCost: Prisma.Decimal
      srp: Prisma.Decimal
      orderQty: number
      totalValue: Prisma.Decimal
      customerTarget: string | null
      imageUrl: string | null
      sortOrder: number
    }, ExtArgs["result"]["proposalProduct"]>
    composites: {}
  }

  type ProposalProductGetPayload<S extends boolean | null | undefined | ProposalProductDefaultArgs> = $Result.GetResult<Prisma.$ProposalProductPayload, S>

  type ProposalProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProposalProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProposalProductCountAggregateInputType | true
    }

  export interface ProposalProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalProduct'], meta: { name: 'ProposalProduct' } }
    /**
     * Find zero or one ProposalProduct that matches the filter.
     * @param {ProposalProductFindUniqueArgs} args - Arguments to find a ProposalProduct
     * @example
     * // Get one ProposalProduct
     * const proposalProduct = await prisma.proposalProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalProductFindUniqueArgs>(args: SelectSubset<T, ProposalProductFindUniqueArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProposalProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProposalProductFindUniqueOrThrowArgs} args - Arguments to find a ProposalProduct
     * @example
     * // Get one ProposalProduct
     * const proposalProduct = await prisma.proposalProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProposalProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductFindFirstArgs} args - Arguments to find a ProposalProduct
     * @example
     * // Get one ProposalProduct
     * const proposalProduct = await prisma.proposalProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalProductFindFirstArgs>(args?: SelectSubset<T, ProposalProductFindFirstArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProposalProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductFindFirstOrThrowArgs} args - Arguments to find a ProposalProduct
     * @example
     * // Get one ProposalProduct
     * const proposalProduct = await prisma.proposalProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProposalProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalProducts
     * const proposalProducts = await prisma.proposalProduct.findMany()
     * 
     * // Get first 10 ProposalProducts
     * const proposalProducts = await prisma.proposalProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalProductWithIdOnly = await prisma.proposalProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalProductFindManyArgs>(args?: SelectSubset<T, ProposalProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProposalProduct.
     * @param {ProposalProductCreateArgs} args - Arguments to create a ProposalProduct.
     * @example
     * // Create one ProposalProduct
     * const ProposalProduct = await prisma.proposalProduct.create({
     *   data: {
     *     // ... data to create a ProposalProduct
     *   }
     * })
     * 
     */
    create<T extends ProposalProductCreateArgs>(args: SelectSubset<T, ProposalProductCreateArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProposalProducts.
     * @param {ProposalProductCreateManyArgs} args - Arguments to create many ProposalProducts.
     * @example
     * // Create many ProposalProducts
     * const proposalProduct = await prisma.proposalProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalProductCreateManyArgs>(args?: SelectSubset<T, ProposalProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProposalProducts and returns the data saved in the database.
     * @param {ProposalProductCreateManyAndReturnArgs} args - Arguments to create many ProposalProducts.
     * @example
     * // Create many ProposalProducts
     * const proposalProduct = await prisma.proposalProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProposalProducts and only return the `id`
     * const proposalProductWithIdOnly = await prisma.proposalProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProposalProduct.
     * @param {ProposalProductDeleteArgs} args - Arguments to delete one ProposalProduct.
     * @example
     * // Delete one ProposalProduct
     * const ProposalProduct = await prisma.proposalProduct.delete({
     *   where: {
     *     // ... filter to delete one ProposalProduct
     *   }
     * })
     * 
     */
    delete<T extends ProposalProductDeleteArgs>(args: SelectSubset<T, ProposalProductDeleteArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProposalProduct.
     * @param {ProposalProductUpdateArgs} args - Arguments to update one ProposalProduct.
     * @example
     * // Update one ProposalProduct
     * const proposalProduct = await prisma.proposalProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalProductUpdateArgs>(args: SelectSubset<T, ProposalProductUpdateArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProposalProducts.
     * @param {ProposalProductDeleteManyArgs} args - Arguments to filter ProposalProducts to delete.
     * @example
     * // Delete a few ProposalProducts
     * const { count } = await prisma.proposalProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalProductDeleteManyArgs>(args?: SelectSubset<T, ProposalProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalProducts
     * const proposalProduct = await prisma.proposalProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalProductUpdateManyArgs>(args: SelectSubset<T, ProposalProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProposalProduct.
     * @param {ProposalProductUpsertArgs} args - Arguments to update or create a ProposalProduct.
     * @example
     * // Update or create a ProposalProduct
     * const proposalProduct = await prisma.proposalProduct.upsert({
     *   create: {
     *     // ... data to create a ProposalProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalProduct we want to update
     *   }
     * })
     */
    upsert<T extends ProposalProductUpsertArgs>(args: SelectSubset<T, ProposalProductUpsertArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProposalProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductCountArgs} args - Arguments to filter ProposalProducts to count.
     * @example
     * // Count the number of ProposalProducts
     * const count = await prisma.proposalProduct.count({
     *   where: {
     *     // ... the filter for the ProposalProducts we want to count
     *   }
     * })
    **/
    count<T extends ProposalProductCountArgs>(
      args?: Subset<T, ProposalProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalProductAggregateArgs>(args: Subset<T, ProposalProductAggregateArgs>): Prisma.PrismaPromise<GetProposalProductAggregateType<T>>

    /**
     * Group by ProposalProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalProductGroupByArgs['orderBy'] }
        : { orderBy?: ProposalProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalProduct model
   */
  readonly fields: ProposalProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends ProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalDefaultArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sku<T extends SkuCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalogDefaultArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    allocations<T extends ProposalProduct$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, ProposalProduct$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalProduct model
   */ 
  interface ProposalProductFieldRefs {
    readonly id: FieldRef<"ProposalProduct", 'String'>
    readonly proposalId: FieldRef<"ProposalProduct", 'String'>
    readonly skuId: FieldRef<"ProposalProduct", 'String'>
    readonly skuCode: FieldRef<"ProposalProduct", 'String'>
    readonly productName: FieldRef<"ProposalProduct", 'String'>
    readonly collection: FieldRef<"ProposalProduct", 'String'>
    readonly gender: FieldRef<"ProposalProduct", 'String'>
    readonly category: FieldRef<"ProposalProduct", 'String'>
    readonly subCategory: FieldRef<"ProposalProduct", 'String'>
    readonly theme: FieldRef<"ProposalProduct", 'String'>
    readonly color: FieldRef<"ProposalProduct", 'String'>
    readonly composition: FieldRef<"ProposalProduct", 'String'>
    readonly unitCost: FieldRef<"ProposalProduct", 'Decimal'>
    readonly srp: FieldRef<"ProposalProduct", 'Decimal'>
    readonly orderQty: FieldRef<"ProposalProduct", 'Int'>
    readonly totalValue: FieldRef<"ProposalProduct", 'Decimal'>
    readonly customerTarget: FieldRef<"ProposalProduct", 'String'>
    readonly imageUrl: FieldRef<"ProposalProduct", 'String'>
    readonly sortOrder: FieldRef<"ProposalProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProposalProduct findUnique
   */
  export type ProposalProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * Filter, which ProposalProduct to fetch.
     */
    where: ProposalProductWhereUniqueInput
  }

  /**
   * ProposalProduct findUniqueOrThrow
   */
  export type ProposalProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * Filter, which ProposalProduct to fetch.
     */
    where: ProposalProductWhereUniqueInput
  }

  /**
   * ProposalProduct findFirst
   */
  export type ProposalProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * Filter, which ProposalProduct to fetch.
     */
    where?: ProposalProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalProducts to fetch.
     */
    orderBy?: ProposalProductOrderByWithRelationInput | ProposalProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalProducts.
     */
    cursor?: ProposalProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalProducts.
     */
    distinct?: ProposalProductScalarFieldEnum | ProposalProductScalarFieldEnum[]
  }

  /**
   * ProposalProduct findFirstOrThrow
   */
  export type ProposalProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * Filter, which ProposalProduct to fetch.
     */
    where?: ProposalProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalProducts to fetch.
     */
    orderBy?: ProposalProductOrderByWithRelationInput | ProposalProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalProducts.
     */
    cursor?: ProposalProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalProducts.
     */
    distinct?: ProposalProductScalarFieldEnum | ProposalProductScalarFieldEnum[]
  }

  /**
   * ProposalProduct findMany
   */
  export type ProposalProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * Filter, which ProposalProducts to fetch.
     */
    where?: ProposalProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalProducts to fetch.
     */
    orderBy?: ProposalProductOrderByWithRelationInput | ProposalProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalProducts.
     */
    cursor?: ProposalProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalProducts.
     */
    skip?: number
    distinct?: ProposalProductScalarFieldEnum | ProposalProductScalarFieldEnum[]
  }

  /**
   * ProposalProduct create
   */
  export type ProposalProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalProduct.
     */
    data: XOR<ProposalProductCreateInput, ProposalProductUncheckedCreateInput>
  }

  /**
   * ProposalProduct createMany
   */
  export type ProposalProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalProducts.
     */
    data: ProposalProductCreateManyInput | ProposalProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProposalProduct createManyAndReturn
   */
  export type ProposalProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProposalProducts.
     */
    data: ProposalProductCreateManyInput | ProposalProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalProduct update
   */
  export type ProposalProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalProduct.
     */
    data: XOR<ProposalProductUpdateInput, ProposalProductUncheckedUpdateInput>
    /**
     * Choose, which ProposalProduct to update.
     */
    where: ProposalProductWhereUniqueInput
  }

  /**
   * ProposalProduct updateMany
   */
  export type ProposalProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalProducts.
     */
    data: XOR<ProposalProductUpdateManyMutationInput, ProposalProductUncheckedUpdateManyInput>
    /**
     * Filter which ProposalProducts to update
     */
    where?: ProposalProductWhereInput
  }

  /**
   * ProposalProduct upsert
   */
  export type ProposalProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalProduct to update in case it exists.
     */
    where: ProposalProductWhereUniqueInput
    /**
     * In case the ProposalProduct found by the `where` argument doesn't exist, create a new ProposalProduct with this data.
     */
    create: XOR<ProposalProductCreateInput, ProposalProductUncheckedCreateInput>
    /**
     * In case the ProposalProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalProductUpdateInput, ProposalProductUncheckedUpdateInput>
  }

  /**
   * ProposalProduct delete
   */
  export type ProposalProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
    /**
     * Filter which ProposalProduct to delete.
     */
    where: ProposalProductWhereUniqueInput
  }

  /**
   * ProposalProduct deleteMany
   */
  export type ProposalProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalProducts to delete
     */
    where?: ProposalProductWhereInput
  }

  /**
   * ProposalProduct.allocations
   */
  export type ProposalProduct$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    where?: ProductAllocationWhereInput
    orderBy?: ProductAllocationOrderByWithRelationInput | ProductAllocationOrderByWithRelationInput[]
    cursor?: ProductAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductAllocationScalarFieldEnum | ProductAllocationScalarFieldEnum[]
  }

  /**
   * ProposalProduct without action
   */
  export type ProposalProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalProduct
     */
    select?: ProposalProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductAllocation
   */

  export type AggregateProductAllocation = {
    _count: ProductAllocationCountAggregateOutputType | null
    _avg: ProductAllocationAvgAggregateOutputType | null
    _sum: ProductAllocationSumAggregateOutputType | null
    _min: ProductAllocationMinAggregateOutputType | null
    _max: ProductAllocationMaxAggregateOutputType | null
  }

  export type ProductAllocationAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ProductAllocationSumAggregateOutputType = {
    quantity: number | null
  }

  export type ProductAllocationMinAggregateOutputType = {
    id: string | null
    proposalProductId: string | null
    storeId: string | null
    quantity: number | null
  }

  export type ProductAllocationMaxAggregateOutputType = {
    id: string | null
    proposalProductId: string | null
    storeId: string | null
    quantity: number | null
  }

  export type ProductAllocationCountAggregateOutputType = {
    id: number
    proposalProductId: number
    storeId: number
    quantity: number
    _all: number
  }


  export type ProductAllocationAvgAggregateInputType = {
    quantity?: true
  }

  export type ProductAllocationSumAggregateInputType = {
    quantity?: true
  }

  export type ProductAllocationMinAggregateInputType = {
    id?: true
    proposalProductId?: true
    storeId?: true
    quantity?: true
  }

  export type ProductAllocationMaxAggregateInputType = {
    id?: true
    proposalProductId?: true
    storeId?: true
    quantity?: true
  }

  export type ProductAllocationCountAggregateInputType = {
    id?: true
    proposalProductId?: true
    storeId?: true
    quantity?: true
    _all?: true
  }

  export type ProductAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAllocation to aggregate.
     */
    where?: ProductAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllocations to fetch.
     */
    orderBy?: ProductAllocationOrderByWithRelationInput | ProductAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductAllocations
    **/
    _count?: true | ProductAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductAllocationMaxAggregateInputType
  }

  export type GetProductAllocationAggregateType<T extends ProductAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductAllocation[P]>
      : GetScalarType<T[P], AggregateProductAllocation[P]>
  }




  export type ProductAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductAllocationWhereInput
    orderBy?: ProductAllocationOrderByWithAggregationInput | ProductAllocationOrderByWithAggregationInput[]
    by: ProductAllocationScalarFieldEnum[] | ProductAllocationScalarFieldEnum
    having?: ProductAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductAllocationCountAggregateInputType | true
    _avg?: ProductAllocationAvgAggregateInputType
    _sum?: ProductAllocationSumAggregateInputType
    _min?: ProductAllocationMinAggregateInputType
    _max?: ProductAllocationMaxAggregateInputType
  }

  export type ProductAllocationGroupByOutputType = {
    id: string
    proposalProductId: string
    storeId: string
    quantity: number
    _count: ProductAllocationCountAggregateOutputType | null
    _avg: ProductAllocationAvgAggregateOutputType | null
    _sum: ProductAllocationSumAggregateOutputType | null
    _min: ProductAllocationMinAggregateOutputType | null
    _max: ProductAllocationMaxAggregateOutputType | null
  }

  type GetProductAllocationGroupByPayload<T extends ProductAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductAllocationGroupByOutputType[P]>
        }
      >
    >


  export type ProductAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalProductId?: boolean
    storeId?: boolean
    quantity?: boolean
    proposalProduct?: boolean | ProposalProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productAllocation"]>

  export type ProductAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalProductId?: boolean
    storeId?: boolean
    quantity?: boolean
    proposalProduct?: boolean | ProposalProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productAllocation"]>

  export type ProductAllocationSelectScalar = {
    id?: boolean
    proposalProductId?: boolean
    storeId?: boolean
    quantity?: boolean
  }

  export type ProductAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposalProduct?: boolean | ProposalProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type ProductAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposalProduct?: boolean | ProposalProductDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $ProductAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductAllocation"
    objects: {
      proposalProduct: Prisma.$ProposalProductPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalProductId: string
      storeId: string
      quantity: number
    }, ExtArgs["result"]["productAllocation"]>
    composites: {}
  }

  type ProductAllocationGetPayload<S extends boolean | null | undefined | ProductAllocationDefaultArgs> = $Result.GetResult<Prisma.$ProductAllocationPayload, S>

  type ProductAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductAllocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductAllocationCountAggregateInputType | true
    }

  export interface ProductAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductAllocation'], meta: { name: 'ProductAllocation' } }
    /**
     * Find zero or one ProductAllocation that matches the filter.
     * @param {ProductAllocationFindUniqueArgs} args - Arguments to find a ProductAllocation
     * @example
     * // Get one ProductAllocation
     * const productAllocation = await prisma.productAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductAllocationFindUniqueArgs>(args: SelectSubset<T, ProductAllocationFindUniqueArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductAllocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductAllocationFindUniqueOrThrowArgs} args - Arguments to find a ProductAllocation
     * @example
     * // Get one ProductAllocation
     * const productAllocation = await prisma.productAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationFindFirstArgs} args - Arguments to find a ProductAllocation
     * @example
     * // Get one ProductAllocation
     * const productAllocation = await prisma.productAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductAllocationFindFirstArgs>(args?: SelectSubset<T, ProductAllocationFindFirstArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationFindFirstOrThrowArgs} args - Arguments to find a ProductAllocation
     * @example
     * // Get one ProductAllocation
     * const productAllocation = await prisma.productAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductAllocations
     * const productAllocations = await prisma.productAllocation.findMany()
     * 
     * // Get first 10 ProductAllocations
     * const productAllocations = await prisma.productAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productAllocationWithIdOnly = await prisma.productAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductAllocationFindManyArgs>(args?: SelectSubset<T, ProductAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductAllocation.
     * @param {ProductAllocationCreateArgs} args - Arguments to create a ProductAllocation.
     * @example
     * // Create one ProductAllocation
     * const ProductAllocation = await prisma.productAllocation.create({
     *   data: {
     *     // ... data to create a ProductAllocation
     *   }
     * })
     * 
     */
    create<T extends ProductAllocationCreateArgs>(args: SelectSubset<T, ProductAllocationCreateArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductAllocations.
     * @param {ProductAllocationCreateManyArgs} args - Arguments to create many ProductAllocations.
     * @example
     * // Create many ProductAllocations
     * const productAllocation = await prisma.productAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductAllocationCreateManyArgs>(args?: SelectSubset<T, ProductAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductAllocations and returns the data saved in the database.
     * @param {ProductAllocationCreateManyAndReturnArgs} args - Arguments to create many ProductAllocations.
     * @example
     * // Create many ProductAllocations
     * const productAllocation = await prisma.productAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductAllocations and only return the `id`
     * const productAllocationWithIdOnly = await prisma.productAllocation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductAllocation.
     * @param {ProductAllocationDeleteArgs} args - Arguments to delete one ProductAllocation.
     * @example
     * // Delete one ProductAllocation
     * const ProductAllocation = await prisma.productAllocation.delete({
     *   where: {
     *     // ... filter to delete one ProductAllocation
     *   }
     * })
     * 
     */
    delete<T extends ProductAllocationDeleteArgs>(args: SelectSubset<T, ProductAllocationDeleteArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductAllocation.
     * @param {ProductAllocationUpdateArgs} args - Arguments to update one ProductAllocation.
     * @example
     * // Update one ProductAllocation
     * const productAllocation = await prisma.productAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductAllocationUpdateArgs>(args: SelectSubset<T, ProductAllocationUpdateArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductAllocations.
     * @param {ProductAllocationDeleteManyArgs} args - Arguments to filter ProductAllocations to delete.
     * @example
     * // Delete a few ProductAllocations
     * const { count } = await prisma.productAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductAllocationDeleteManyArgs>(args?: SelectSubset<T, ProductAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductAllocations
     * const productAllocation = await prisma.productAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductAllocationUpdateManyArgs>(args: SelectSubset<T, ProductAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductAllocation.
     * @param {ProductAllocationUpsertArgs} args - Arguments to update or create a ProductAllocation.
     * @example
     * // Update or create a ProductAllocation
     * const productAllocation = await prisma.productAllocation.upsert({
     *   create: {
     *     // ... data to create a ProductAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductAllocation we want to update
     *   }
     * })
     */
    upsert<T extends ProductAllocationUpsertArgs>(args: SelectSubset<T, ProductAllocationUpsertArgs<ExtArgs>>): Prisma__ProductAllocationClient<$Result.GetResult<Prisma.$ProductAllocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationCountArgs} args - Arguments to filter ProductAllocations to count.
     * @example
     * // Count the number of ProductAllocations
     * const count = await prisma.productAllocation.count({
     *   where: {
     *     // ... the filter for the ProductAllocations we want to count
     *   }
     * })
    **/
    count<T extends ProductAllocationCountArgs>(
      args?: Subset<T, ProductAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAllocationAggregateArgs>(args: Subset<T, ProductAllocationAggregateArgs>): Prisma.PrismaPromise<GetProductAllocationAggregateType<T>>

    /**
     * Group by ProductAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductAllocationGroupByArgs['orderBy'] }
        : { orderBy?: ProductAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductAllocation model
   */
  readonly fields: ProductAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposalProduct<T extends ProposalProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProposalProductDefaultArgs<ExtArgs>>): Prisma__ProposalProductClient<$Result.GetResult<Prisma.$ProposalProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductAllocation model
   */ 
  interface ProductAllocationFieldRefs {
    readonly id: FieldRef<"ProductAllocation", 'String'>
    readonly proposalProductId: FieldRef<"ProductAllocation", 'String'>
    readonly storeId: FieldRef<"ProductAllocation", 'String'>
    readonly quantity: FieldRef<"ProductAllocation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductAllocation findUnique
   */
  export type ProductAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductAllocation to fetch.
     */
    where: ProductAllocationWhereUniqueInput
  }

  /**
   * ProductAllocation findUniqueOrThrow
   */
  export type ProductAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductAllocation to fetch.
     */
    where: ProductAllocationWhereUniqueInput
  }

  /**
   * ProductAllocation findFirst
   */
  export type ProductAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductAllocation to fetch.
     */
    where?: ProductAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllocations to fetch.
     */
    orderBy?: ProductAllocationOrderByWithRelationInput | ProductAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAllocations.
     */
    cursor?: ProductAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAllocations.
     */
    distinct?: ProductAllocationScalarFieldEnum | ProductAllocationScalarFieldEnum[]
  }

  /**
   * ProductAllocation findFirstOrThrow
   */
  export type ProductAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductAllocation to fetch.
     */
    where?: ProductAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllocations to fetch.
     */
    orderBy?: ProductAllocationOrderByWithRelationInput | ProductAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductAllocations.
     */
    cursor?: ProductAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductAllocations.
     */
    distinct?: ProductAllocationScalarFieldEnum | ProductAllocationScalarFieldEnum[]
  }

  /**
   * ProductAllocation findMany
   */
  export type ProductAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * Filter, which ProductAllocations to fetch.
     */
    where?: ProductAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductAllocations to fetch.
     */
    orderBy?: ProductAllocationOrderByWithRelationInput | ProductAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductAllocations.
     */
    cursor?: ProductAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductAllocations.
     */
    skip?: number
    distinct?: ProductAllocationScalarFieldEnum | ProductAllocationScalarFieldEnum[]
  }

  /**
   * ProductAllocation create
   */
  export type ProductAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductAllocation.
     */
    data: XOR<ProductAllocationCreateInput, ProductAllocationUncheckedCreateInput>
  }

  /**
   * ProductAllocation createMany
   */
  export type ProductAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductAllocations.
     */
    data: ProductAllocationCreateManyInput | ProductAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductAllocation createManyAndReturn
   */
  export type ProductAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductAllocations.
     */
    data: ProductAllocationCreateManyInput | ProductAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductAllocation update
   */
  export type ProductAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductAllocation.
     */
    data: XOR<ProductAllocationUpdateInput, ProductAllocationUncheckedUpdateInput>
    /**
     * Choose, which ProductAllocation to update.
     */
    where: ProductAllocationWhereUniqueInput
  }

  /**
   * ProductAllocation updateMany
   */
  export type ProductAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductAllocations.
     */
    data: XOR<ProductAllocationUpdateManyMutationInput, ProductAllocationUncheckedUpdateManyInput>
    /**
     * Filter which ProductAllocations to update
     */
    where?: ProductAllocationWhereInput
  }

  /**
   * ProductAllocation upsert
   */
  export type ProductAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductAllocation to update in case it exists.
     */
    where: ProductAllocationWhereUniqueInput
    /**
     * In case the ProductAllocation found by the `where` argument doesn't exist, create a new ProductAllocation with this data.
     */
    create: XOR<ProductAllocationCreateInput, ProductAllocationUncheckedCreateInput>
    /**
     * In case the ProductAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductAllocationUpdateInput, ProductAllocationUncheckedUpdateInput>
  }

  /**
   * ProductAllocation delete
   */
  export type ProductAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
    /**
     * Filter which ProductAllocation to delete.
     */
    where: ProductAllocationWhereUniqueInput
  }

  /**
   * ProductAllocation deleteMany
   */
  export type ProductAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductAllocations to delete
     */
    where?: ProductAllocationWhereInput
  }

  /**
   * ProductAllocation without action
   */
  export type ProductAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductAllocation
     */
    select?: ProductAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductAllocationInclude<ExtArgs> | null
  }


  /**
   * Model Approval
   */

  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalAvgAggregateOutputType = {
    level: number | null
  }

  export type ApprovalSumAggregateOutputType = {
    level: number | null
  }

  export type ApprovalMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    level: number | null
    deciderId: string | null
    action: $Enums.ApprovalAction | null
    comment: string | null
    decidedAt: Date | null
  }

  export type ApprovalMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    level: number | null
    deciderId: string | null
    action: $Enums.ApprovalAction | null
    comment: string | null
    decidedAt: Date | null
  }

  export type ApprovalCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    level: number
    deciderId: number
    action: number
    comment: number
    decidedAt: number
    _all: number
  }


  export type ApprovalAvgAggregateInputType = {
    level?: true
  }

  export type ApprovalSumAggregateInputType = {
    level?: true
  }

  export type ApprovalMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    level?: true
    deciderId?: true
    action?: true
    comment?: true
    decidedAt?: true
  }

  export type ApprovalMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    level?: true
    deciderId?: true
    action?: true
    comment?: true
    decidedAt?: true
  }

  export type ApprovalCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    level?: true
    deciderId?: true
    action?: true
    comment?: true
    decidedAt?: true
    _all?: true
  }

  export type ApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approval to aggregate.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithAggregationInput | ApprovalOrderByWithAggregationInput[]
    by: ApprovalScalarFieldEnum[] | ApprovalScalarFieldEnum
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _avg?: ApprovalAvgAggregateInputType
    _sum?: ApprovalSumAggregateInputType
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }

  export type ApprovalGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    level: number
    deciderId: string
    action: $Enums.ApprovalAction
    comment: string | null
    decidedAt: Date
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    level?: boolean
    deciderId?: boolean
    action?: boolean
    comment?: boolean
    decidedAt?: boolean
    decider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    level?: boolean
    deciderId?: boolean
    action?: boolean
    comment?: boolean
    decidedAt?: boolean
    decider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    level?: boolean
    deciderId?: boolean
    action?: boolean
    comment?: boolean
    decidedAt?: boolean
  }

  export type ApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decider?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    decider?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Approval"
    objects: {
      decider: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      level: number
      deciderId: string
      action: $Enums.ApprovalAction
      comment: string | null
      decidedAt: Date
    }, ExtArgs["result"]["approval"]>
    composites: {}
  }

  type ApprovalGetPayload<S extends boolean | null | undefined | ApprovalDefaultArgs> = $Result.GetResult<Prisma.$ApprovalPayload, S>

  type ApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalCountAggregateInputType | true
    }

  export interface ApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Approval'], meta: { name: 'Approval' } }
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalFindUniqueArgs>(args: SelectSubset<T, ApprovalFindUniqueArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Approval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalFindUniqueOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalFindFirstArgs>(args?: SelectSubset<T, ApprovalFindFirstArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWithIdOnly = await prisma.approval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalFindManyArgs>(args?: SelectSubset<T, ApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
     */
    create<T extends ApprovalCreateArgs>(args: SelectSubset<T, ApprovalCreateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Approvals.
     * @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalCreateManyArgs>(args?: SelectSubset<T, ApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Approvals and returns the data saved in the database.
     * @param {ApprovalCreateManyAndReturnArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
     */
    delete<T extends ApprovalDeleteArgs>(args: SelectSubset<T, ApprovalDeleteArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalUpdateArgs>(args: SelectSubset<T, ApprovalUpdateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalDeleteManyArgs>(args?: SelectSubset<T, ApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalUpdateManyArgs>(args: SelectSubset<T, ApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalUpsertArgs>(args: SelectSubset<T, ApprovalUpsertArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): Prisma.PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Approval model
   */
  readonly fields: ApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    decider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Approval model
   */ 
  interface ApprovalFieldRefs {
    readonly id: FieldRef<"Approval", 'String'>
    readonly entityType: FieldRef<"Approval", 'String'>
    readonly entityId: FieldRef<"Approval", 'String'>
    readonly level: FieldRef<"Approval", 'Int'>
    readonly deciderId: FieldRef<"Approval", 'String'>
    readonly action: FieldRef<"Approval", 'ApprovalAction'>
    readonly comment: FieldRef<"Approval", 'String'>
    readonly decidedAt: FieldRef<"Approval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findUniqueOrThrow
   */
  export type ApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findFirstOrThrow
   */
  export type ApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approvals to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval create
   */
  export type ApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a Approval.
     */
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }

  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Approval createManyAndReturn
   */
  export type ApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval update
   */
  export type ApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a Approval.
     */
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
  }

  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the Approval to update in case it exists.
     */
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     */
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }

  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter which Approval to delete.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approvals to delete
     */
    where?: ApprovalWhereInput
  }

  /**
   * Approval without action
   */
  export type ApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    entityType: string | null
    entityId: string | null
    action: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    entityType: number
    entityId: number
    action: number
    changes: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    action?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    action?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    entityType?: true
    entityId?: true
    action?: true
    changes?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    entityType: string
    entityId: string
    action: string
    changes: JsonValue | null
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      entityType: string
      entityId: string
      action: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SalesHistory
   */

  export type AggregateSalesHistory = {
    _count: SalesHistoryCountAggregateOutputType | null
    _avg: SalesHistoryAvgAggregateOutputType | null
    _sum: SalesHistorySumAggregateOutputType | null
    _min: SalesHistoryMinAggregateOutputType | null
    _max: SalesHistoryMaxAggregateOutputType | null
  }

  export type SalesHistoryAvgAggregateOutputType = {
    quantitySold: number | null
    quantityBought: number | null
    sellThroughPct: Decimal | null
  }

  export type SalesHistorySumAggregateOutputType = {
    quantitySold: number | null
    quantityBought: number | null
    sellThroughPct: Decimal | null
  }

  export type SalesHistoryMinAggregateOutputType = {
    id: string | null
    skuCode: string | null
    storeId: string | null
    sizeCode: string | null
    season: string | null
    quantitySold: number | null
    quantityBought: number | null
    sellThroughPct: Decimal | null
    createdAt: Date | null
  }

  export type SalesHistoryMaxAggregateOutputType = {
    id: string | null
    skuCode: string | null
    storeId: string | null
    sizeCode: string | null
    season: string | null
    quantitySold: number | null
    quantityBought: number | null
    sellThroughPct: Decimal | null
    createdAt: Date | null
  }

  export type SalesHistoryCountAggregateOutputType = {
    id: number
    skuCode: number
    storeId: number
    sizeCode: number
    season: number
    quantitySold: number
    quantityBought: number
    sellThroughPct: number
    createdAt: number
    _all: number
  }


  export type SalesHistoryAvgAggregateInputType = {
    quantitySold?: true
    quantityBought?: true
    sellThroughPct?: true
  }

  export type SalesHistorySumAggregateInputType = {
    quantitySold?: true
    quantityBought?: true
    sellThroughPct?: true
  }

  export type SalesHistoryMinAggregateInputType = {
    id?: true
    skuCode?: true
    storeId?: true
    sizeCode?: true
    season?: true
    quantitySold?: true
    quantityBought?: true
    sellThroughPct?: true
    createdAt?: true
  }

  export type SalesHistoryMaxAggregateInputType = {
    id?: true
    skuCode?: true
    storeId?: true
    sizeCode?: true
    season?: true
    quantitySold?: true
    quantityBought?: true
    sellThroughPct?: true
    createdAt?: true
  }

  export type SalesHistoryCountAggregateInputType = {
    id?: true
    skuCode?: true
    storeId?: true
    sizeCode?: true
    season?: true
    quantitySold?: true
    quantityBought?: true
    sellThroughPct?: true
    createdAt?: true
    _all?: true
  }

  export type SalesHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesHistory to aggregate.
     */
    where?: SalesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesHistories to fetch.
     */
    orderBy?: SalesHistoryOrderByWithRelationInput | SalesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesHistories
    **/
    _count?: true | SalesHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesHistoryMaxAggregateInputType
  }

  export type GetSalesHistoryAggregateType<T extends SalesHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesHistory[P]>
      : GetScalarType<T[P], AggregateSalesHistory[P]>
  }




  export type SalesHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesHistoryWhereInput
    orderBy?: SalesHistoryOrderByWithAggregationInput | SalesHistoryOrderByWithAggregationInput[]
    by: SalesHistoryScalarFieldEnum[] | SalesHistoryScalarFieldEnum
    having?: SalesHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesHistoryCountAggregateInputType | true
    _avg?: SalesHistoryAvgAggregateInputType
    _sum?: SalesHistorySumAggregateInputType
    _min?: SalesHistoryMinAggregateInputType
    _max?: SalesHistoryMaxAggregateInputType
  }

  export type SalesHistoryGroupByOutputType = {
    id: string
    skuCode: string
    storeId: string
    sizeCode: string
    season: string
    quantitySold: number
    quantityBought: number
    sellThroughPct: Decimal
    createdAt: Date
    _count: SalesHistoryCountAggregateOutputType | null
    _avg: SalesHistoryAvgAggregateOutputType | null
    _sum: SalesHistorySumAggregateOutputType | null
    _min: SalesHistoryMinAggregateOutputType | null
    _max: SalesHistoryMaxAggregateOutputType | null
  }

  type GetSalesHistoryGroupByPayload<T extends SalesHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SalesHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SalesHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuCode?: boolean
    storeId?: boolean
    sizeCode?: boolean
    season?: boolean
    quantitySold?: boolean
    quantityBought?: boolean
    sellThroughPct?: boolean
    createdAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesHistory"]>

  export type SalesHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuCode?: boolean
    storeId?: boolean
    sizeCode?: boolean
    season?: boolean
    quantitySold?: boolean
    quantityBought?: boolean
    sellThroughPct?: boolean
    createdAt?: boolean
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesHistory"]>

  export type SalesHistorySelectScalar = {
    id?: boolean
    skuCode?: boolean
    storeId?: boolean
    sizeCode?: boolean
    season?: boolean
    quantitySold?: boolean
    quantityBought?: boolean
    sellThroughPct?: boolean
    createdAt?: boolean
  }

  export type SalesHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type SalesHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $SalesHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesHistory"
    objects: {
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skuCode: string
      storeId: string
      sizeCode: string
      season: string
      quantitySold: number
      quantityBought: number
      sellThroughPct: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["salesHistory"]>
    composites: {}
  }

  type SalesHistoryGetPayload<S extends boolean | null | undefined | SalesHistoryDefaultArgs> = $Result.GetResult<Prisma.$SalesHistoryPayload, S>

  type SalesHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesHistoryCountAggregateInputType | true
    }

  export interface SalesHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesHistory'], meta: { name: 'SalesHistory' } }
    /**
     * Find zero or one SalesHistory that matches the filter.
     * @param {SalesHistoryFindUniqueArgs} args - Arguments to find a SalesHistory
     * @example
     * // Get one SalesHistory
     * const salesHistory = await prisma.salesHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesHistoryFindUniqueArgs>(args: SelectSubset<T, SalesHistoryFindUniqueArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesHistoryFindUniqueOrThrowArgs} args - Arguments to find a SalesHistory
     * @example
     * // Get one SalesHistory
     * const salesHistory = await prisma.salesHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryFindFirstArgs} args - Arguments to find a SalesHistory
     * @example
     * // Get one SalesHistory
     * const salesHistory = await prisma.salesHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesHistoryFindFirstArgs>(args?: SelectSubset<T, SalesHistoryFindFirstArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryFindFirstOrThrowArgs} args - Arguments to find a SalesHistory
     * @example
     * // Get one SalesHistory
     * const salesHistory = await prisma.salesHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesHistories
     * const salesHistories = await prisma.salesHistory.findMany()
     * 
     * // Get first 10 SalesHistories
     * const salesHistories = await prisma.salesHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesHistoryWithIdOnly = await prisma.salesHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesHistoryFindManyArgs>(args?: SelectSubset<T, SalesHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesHistory.
     * @param {SalesHistoryCreateArgs} args - Arguments to create a SalesHistory.
     * @example
     * // Create one SalesHistory
     * const SalesHistory = await prisma.salesHistory.create({
     *   data: {
     *     // ... data to create a SalesHistory
     *   }
     * })
     * 
     */
    create<T extends SalesHistoryCreateArgs>(args: SelectSubset<T, SalesHistoryCreateArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesHistories.
     * @param {SalesHistoryCreateManyArgs} args - Arguments to create many SalesHistories.
     * @example
     * // Create many SalesHistories
     * const salesHistory = await prisma.salesHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesHistoryCreateManyArgs>(args?: SelectSubset<T, SalesHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesHistories and returns the data saved in the database.
     * @param {SalesHistoryCreateManyAndReturnArgs} args - Arguments to create many SalesHistories.
     * @example
     * // Create many SalesHistories
     * const salesHistory = await prisma.salesHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesHistories and only return the `id`
     * const salesHistoryWithIdOnly = await prisma.salesHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalesHistory.
     * @param {SalesHistoryDeleteArgs} args - Arguments to delete one SalesHistory.
     * @example
     * // Delete one SalesHistory
     * const SalesHistory = await prisma.salesHistory.delete({
     *   where: {
     *     // ... filter to delete one SalesHistory
     *   }
     * })
     * 
     */
    delete<T extends SalesHistoryDeleteArgs>(args: SelectSubset<T, SalesHistoryDeleteArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesHistory.
     * @param {SalesHistoryUpdateArgs} args - Arguments to update one SalesHistory.
     * @example
     * // Update one SalesHistory
     * const salesHistory = await prisma.salesHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesHistoryUpdateArgs>(args: SelectSubset<T, SalesHistoryUpdateArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesHistories.
     * @param {SalesHistoryDeleteManyArgs} args - Arguments to filter SalesHistories to delete.
     * @example
     * // Delete a few SalesHistories
     * const { count } = await prisma.salesHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesHistoryDeleteManyArgs>(args?: SelectSubset<T, SalesHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesHistories
     * const salesHistory = await prisma.salesHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesHistoryUpdateManyArgs>(args: SelectSubset<T, SalesHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesHistory.
     * @param {SalesHistoryUpsertArgs} args - Arguments to update or create a SalesHistory.
     * @example
     * // Update or create a SalesHistory
     * const salesHistory = await prisma.salesHistory.upsert({
     *   create: {
     *     // ... data to create a SalesHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesHistory we want to update
     *   }
     * })
     */
    upsert<T extends SalesHistoryUpsertArgs>(args: SelectSubset<T, SalesHistoryUpsertArgs<ExtArgs>>): Prisma__SalesHistoryClient<$Result.GetResult<Prisma.$SalesHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryCountArgs} args - Arguments to filter SalesHistories to count.
     * @example
     * // Count the number of SalesHistories
     * const count = await prisma.salesHistory.count({
     *   where: {
     *     // ... the filter for the SalesHistories we want to count
     *   }
     * })
    **/
    count<T extends SalesHistoryCountArgs>(
      args?: Subset<T, SalesHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesHistoryAggregateArgs>(args: Subset<T, SalesHistoryAggregateArgs>): Prisma.PrismaPromise<GetSalesHistoryAggregateType<T>>

    /**
     * Group by SalesHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SalesHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesHistory model
   */
  readonly fields: SalesHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesHistory model
   */ 
  interface SalesHistoryFieldRefs {
    readonly id: FieldRef<"SalesHistory", 'String'>
    readonly skuCode: FieldRef<"SalesHistory", 'String'>
    readonly storeId: FieldRef<"SalesHistory", 'String'>
    readonly sizeCode: FieldRef<"SalesHistory", 'String'>
    readonly season: FieldRef<"SalesHistory", 'String'>
    readonly quantitySold: FieldRef<"SalesHistory", 'Int'>
    readonly quantityBought: FieldRef<"SalesHistory", 'Int'>
    readonly sellThroughPct: FieldRef<"SalesHistory", 'Decimal'>
    readonly createdAt: FieldRef<"SalesHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesHistory findUnique
   */
  export type SalesHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SalesHistory to fetch.
     */
    where: SalesHistoryWhereUniqueInput
  }

  /**
   * SalesHistory findUniqueOrThrow
   */
  export type SalesHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SalesHistory to fetch.
     */
    where: SalesHistoryWhereUniqueInput
  }

  /**
   * SalesHistory findFirst
   */
  export type SalesHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SalesHistory to fetch.
     */
    where?: SalesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesHistories to fetch.
     */
    orderBy?: SalesHistoryOrderByWithRelationInput | SalesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesHistories.
     */
    cursor?: SalesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesHistories.
     */
    distinct?: SalesHistoryScalarFieldEnum | SalesHistoryScalarFieldEnum[]
  }

  /**
   * SalesHistory findFirstOrThrow
   */
  export type SalesHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SalesHistory to fetch.
     */
    where?: SalesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesHistories to fetch.
     */
    orderBy?: SalesHistoryOrderByWithRelationInput | SalesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesHistories.
     */
    cursor?: SalesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesHistories.
     */
    distinct?: SalesHistoryScalarFieldEnum | SalesHistoryScalarFieldEnum[]
  }

  /**
   * SalesHistory findMany
   */
  export type SalesHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SalesHistories to fetch.
     */
    where?: SalesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesHistories to fetch.
     */
    orderBy?: SalesHistoryOrderByWithRelationInput | SalesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesHistories.
     */
    cursor?: SalesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesHistories.
     */
    skip?: number
    distinct?: SalesHistoryScalarFieldEnum | SalesHistoryScalarFieldEnum[]
  }

  /**
   * SalesHistory create
   */
  export type SalesHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesHistory.
     */
    data: XOR<SalesHistoryCreateInput, SalesHistoryUncheckedCreateInput>
  }

  /**
   * SalesHistory createMany
   */
  export type SalesHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesHistories.
     */
    data: SalesHistoryCreateManyInput | SalesHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesHistory createManyAndReturn
   */
  export type SalesHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalesHistories.
     */
    data: SalesHistoryCreateManyInput | SalesHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesHistory update
   */
  export type SalesHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesHistory.
     */
    data: XOR<SalesHistoryUpdateInput, SalesHistoryUncheckedUpdateInput>
    /**
     * Choose, which SalesHistory to update.
     */
    where: SalesHistoryWhereUniqueInput
  }

  /**
   * SalesHistory updateMany
   */
  export type SalesHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesHistories.
     */
    data: XOR<SalesHistoryUpdateManyMutationInput, SalesHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SalesHistories to update
     */
    where?: SalesHistoryWhereInput
  }

  /**
   * SalesHistory upsert
   */
  export type SalesHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesHistory to update in case it exists.
     */
    where: SalesHistoryWhereUniqueInput
    /**
     * In case the SalesHistory found by the `where` argument doesn't exist, create a new SalesHistory with this data.
     */
    create: XOR<SalesHistoryCreateInput, SalesHistoryUncheckedCreateInput>
    /**
     * In case the SalesHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesHistoryUpdateInput, SalesHistoryUncheckedUpdateInput>
  }

  /**
   * SalesHistory delete
   */
  export type SalesHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
    /**
     * Filter which SalesHistory to delete.
     */
    where: SalesHistoryWhereUniqueInput
  }

  /**
   * SalesHistory deleteMany
   */
  export type SalesHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesHistories to delete
     */
    where?: SalesHistoryWhereInput
  }

  /**
   * SalesHistory without action
   */
  export type SalesHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesHistory
     */
    select?: SalesHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SizeCurveRecommendation
   */

  export type AggregateSizeCurveRecommendation = {
    _count: SizeCurveRecommendationCountAggregateOutputType | null
    _avg: SizeCurveRecommendationAvgAggregateOutputType | null
    _sum: SizeCurveRecommendationSumAggregateOutputType | null
    _min: SizeCurveRecommendationMinAggregateOutputType | null
    _max: SizeCurveRecommendationMaxAggregateOutputType | null
  }

  export type SizeCurveRecommendationAvgAggregateOutputType = {
    recommendedPct: Decimal | null
    confidence: Decimal | null
    basedOnSeasons: number | null
  }

  export type SizeCurveRecommendationSumAggregateOutputType = {
    recommendedPct: Decimal | null
    confidence: Decimal | null
    basedOnSeasons: number | null
  }

  export type SizeCurveRecommendationMinAggregateOutputType = {
    id: string | null
    skuId: string | null
    storeId: string | null
    category: string | null
    sizeCode: string | null
    recommendedPct: Decimal | null
    confidence: Decimal | null
    basedOnSeasons: number | null
    reasoning: string | null
    createdAt: Date | null
  }

  export type SizeCurveRecommendationMaxAggregateOutputType = {
    id: string | null
    skuId: string | null
    storeId: string | null
    category: string | null
    sizeCode: string | null
    recommendedPct: Decimal | null
    confidence: Decimal | null
    basedOnSeasons: number | null
    reasoning: string | null
    createdAt: Date | null
  }

  export type SizeCurveRecommendationCountAggregateOutputType = {
    id: number
    skuId: number
    storeId: number
    category: number
    sizeCode: number
    recommendedPct: number
    confidence: number
    basedOnSeasons: number
    reasoning: number
    createdAt: number
    _all: number
  }


  export type SizeCurveRecommendationAvgAggregateInputType = {
    recommendedPct?: true
    confidence?: true
    basedOnSeasons?: true
  }

  export type SizeCurveRecommendationSumAggregateInputType = {
    recommendedPct?: true
    confidence?: true
    basedOnSeasons?: true
  }

  export type SizeCurveRecommendationMinAggregateInputType = {
    id?: true
    skuId?: true
    storeId?: true
    category?: true
    sizeCode?: true
    recommendedPct?: true
    confidence?: true
    basedOnSeasons?: true
    reasoning?: true
    createdAt?: true
  }

  export type SizeCurveRecommendationMaxAggregateInputType = {
    id?: true
    skuId?: true
    storeId?: true
    category?: true
    sizeCode?: true
    recommendedPct?: true
    confidence?: true
    basedOnSeasons?: true
    reasoning?: true
    createdAt?: true
  }

  export type SizeCurveRecommendationCountAggregateInputType = {
    id?: true
    skuId?: true
    storeId?: true
    category?: true
    sizeCode?: true
    recommendedPct?: true
    confidence?: true
    basedOnSeasons?: true
    reasoning?: true
    createdAt?: true
    _all?: true
  }

  export type SizeCurveRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SizeCurveRecommendation to aggregate.
     */
    where?: SizeCurveRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCurveRecommendations to fetch.
     */
    orderBy?: SizeCurveRecommendationOrderByWithRelationInput | SizeCurveRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SizeCurveRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCurveRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCurveRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SizeCurveRecommendations
    **/
    _count?: true | SizeCurveRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SizeCurveRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SizeCurveRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SizeCurveRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SizeCurveRecommendationMaxAggregateInputType
  }

  export type GetSizeCurveRecommendationAggregateType<T extends SizeCurveRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateSizeCurveRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSizeCurveRecommendation[P]>
      : GetScalarType<T[P], AggregateSizeCurveRecommendation[P]>
  }




  export type SizeCurveRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeCurveRecommendationWhereInput
    orderBy?: SizeCurveRecommendationOrderByWithAggregationInput | SizeCurveRecommendationOrderByWithAggregationInput[]
    by: SizeCurveRecommendationScalarFieldEnum[] | SizeCurveRecommendationScalarFieldEnum
    having?: SizeCurveRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SizeCurveRecommendationCountAggregateInputType | true
    _avg?: SizeCurveRecommendationAvgAggregateInputType
    _sum?: SizeCurveRecommendationSumAggregateInputType
    _min?: SizeCurveRecommendationMinAggregateInputType
    _max?: SizeCurveRecommendationMaxAggregateInputType
  }

  export type SizeCurveRecommendationGroupByOutputType = {
    id: string
    skuId: string
    storeId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal
    confidence: Decimal
    basedOnSeasons: number
    reasoning: string | null
    createdAt: Date
    _count: SizeCurveRecommendationCountAggregateOutputType | null
    _avg: SizeCurveRecommendationAvgAggregateOutputType | null
    _sum: SizeCurveRecommendationSumAggregateOutputType | null
    _min: SizeCurveRecommendationMinAggregateOutputType | null
    _max: SizeCurveRecommendationMaxAggregateOutputType | null
  }

  type GetSizeCurveRecommendationGroupByPayload<T extends SizeCurveRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SizeCurveRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SizeCurveRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SizeCurveRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], SizeCurveRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type SizeCurveRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuId?: boolean
    storeId?: boolean
    category?: boolean
    sizeCode?: boolean
    recommendedPct?: boolean
    confidence?: boolean
    basedOnSeasons?: boolean
    reasoning?: boolean
    createdAt?: boolean
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sizeCurveRecommendation"]>

  export type SizeCurveRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuId?: boolean
    storeId?: boolean
    category?: boolean
    sizeCode?: boolean
    recommendedPct?: boolean
    confidence?: boolean
    basedOnSeasons?: boolean
    reasoning?: boolean
    createdAt?: boolean
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sizeCurveRecommendation"]>

  export type SizeCurveRecommendationSelectScalar = {
    id?: boolean
    skuId?: boolean
    storeId?: boolean
    category?: boolean
    sizeCode?: boolean
    recommendedPct?: boolean
    confidence?: boolean
    basedOnSeasons?: boolean
    reasoning?: boolean
    createdAt?: boolean
  }

  export type SizeCurveRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }
  export type SizeCurveRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | StoreDefaultArgs<ExtArgs>
  }

  export type $SizeCurveRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SizeCurveRecommendation"
    objects: {
      sku: Prisma.$SkuCatalogPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skuId: string
      storeId: string
      category: string
      sizeCode: string
      recommendedPct: Prisma.Decimal
      confidence: Prisma.Decimal
      basedOnSeasons: number
      reasoning: string | null
      createdAt: Date
    }, ExtArgs["result"]["sizeCurveRecommendation"]>
    composites: {}
  }

  type SizeCurveRecommendationGetPayload<S extends boolean | null | undefined | SizeCurveRecommendationDefaultArgs> = $Result.GetResult<Prisma.$SizeCurveRecommendationPayload, S>

  type SizeCurveRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SizeCurveRecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SizeCurveRecommendationCountAggregateInputType | true
    }

  export interface SizeCurveRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SizeCurveRecommendation'], meta: { name: 'SizeCurveRecommendation' } }
    /**
     * Find zero or one SizeCurveRecommendation that matches the filter.
     * @param {SizeCurveRecommendationFindUniqueArgs} args - Arguments to find a SizeCurveRecommendation
     * @example
     * // Get one SizeCurveRecommendation
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SizeCurveRecommendationFindUniqueArgs>(args: SelectSubset<T, SizeCurveRecommendationFindUniqueArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SizeCurveRecommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SizeCurveRecommendationFindUniqueOrThrowArgs} args - Arguments to find a SizeCurveRecommendation
     * @example
     * // Get one SizeCurveRecommendation
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SizeCurveRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, SizeCurveRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SizeCurveRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationFindFirstArgs} args - Arguments to find a SizeCurveRecommendation
     * @example
     * // Get one SizeCurveRecommendation
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SizeCurveRecommendationFindFirstArgs>(args?: SelectSubset<T, SizeCurveRecommendationFindFirstArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SizeCurveRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationFindFirstOrThrowArgs} args - Arguments to find a SizeCurveRecommendation
     * @example
     * // Get one SizeCurveRecommendation
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SizeCurveRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, SizeCurveRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SizeCurveRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SizeCurveRecommendations
     * const sizeCurveRecommendations = await prisma.sizeCurveRecommendation.findMany()
     * 
     * // Get first 10 SizeCurveRecommendations
     * const sizeCurveRecommendations = await prisma.sizeCurveRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sizeCurveRecommendationWithIdOnly = await prisma.sizeCurveRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SizeCurveRecommendationFindManyArgs>(args?: SelectSubset<T, SizeCurveRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SizeCurveRecommendation.
     * @param {SizeCurveRecommendationCreateArgs} args - Arguments to create a SizeCurveRecommendation.
     * @example
     * // Create one SizeCurveRecommendation
     * const SizeCurveRecommendation = await prisma.sizeCurveRecommendation.create({
     *   data: {
     *     // ... data to create a SizeCurveRecommendation
     *   }
     * })
     * 
     */
    create<T extends SizeCurveRecommendationCreateArgs>(args: SelectSubset<T, SizeCurveRecommendationCreateArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SizeCurveRecommendations.
     * @param {SizeCurveRecommendationCreateManyArgs} args - Arguments to create many SizeCurveRecommendations.
     * @example
     * // Create many SizeCurveRecommendations
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SizeCurveRecommendationCreateManyArgs>(args?: SelectSubset<T, SizeCurveRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SizeCurveRecommendations and returns the data saved in the database.
     * @param {SizeCurveRecommendationCreateManyAndReturnArgs} args - Arguments to create many SizeCurveRecommendations.
     * @example
     * // Create many SizeCurveRecommendations
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SizeCurveRecommendations and only return the `id`
     * const sizeCurveRecommendationWithIdOnly = await prisma.sizeCurveRecommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SizeCurveRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, SizeCurveRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SizeCurveRecommendation.
     * @param {SizeCurveRecommendationDeleteArgs} args - Arguments to delete one SizeCurveRecommendation.
     * @example
     * // Delete one SizeCurveRecommendation
     * const SizeCurveRecommendation = await prisma.sizeCurveRecommendation.delete({
     *   where: {
     *     // ... filter to delete one SizeCurveRecommendation
     *   }
     * })
     * 
     */
    delete<T extends SizeCurveRecommendationDeleteArgs>(args: SelectSubset<T, SizeCurveRecommendationDeleteArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SizeCurveRecommendation.
     * @param {SizeCurveRecommendationUpdateArgs} args - Arguments to update one SizeCurveRecommendation.
     * @example
     * // Update one SizeCurveRecommendation
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SizeCurveRecommendationUpdateArgs>(args: SelectSubset<T, SizeCurveRecommendationUpdateArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SizeCurveRecommendations.
     * @param {SizeCurveRecommendationDeleteManyArgs} args - Arguments to filter SizeCurveRecommendations to delete.
     * @example
     * // Delete a few SizeCurveRecommendations
     * const { count } = await prisma.sizeCurveRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SizeCurveRecommendationDeleteManyArgs>(args?: SelectSubset<T, SizeCurveRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SizeCurveRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SizeCurveRecommendations
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SizeCurveRecommendationUpdateManyArgs>(args: SelectSubset<T, SizeCurveRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SizeCurveRecommendation.
     * @param {SizeCurveRecommendationUpsertArgs} args - Arguments to update or create a SizeCurveRecommendation.
     * @example
     * // Update or create a SizeCurveRecommendation
     * const sizeCurveRecommendation = await prisma.sizeCurveRecommendation.upsert({
     *   create: {
     *     // ... data to create a SizeCurveRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SizeCurveRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends SizeCurveRecommendationUpsertArgs>(args: SelectSubset<T, SizeCurveRecommendationUpsertArgs<ExtArgs>>): Prisma__SizeCurveRecommendationClient<$Result.GetResult<Prisma.$SizeCurveRecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SizeCurveRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationCountArgs} args - Arguments to filter SizeCurveRecommendations to count.
     * @example
     * // Count the number of SizeCurveRecommendations
     * const count = await prisma.sizeCurveRecommendation.count({
     *   where: {
     *     // ... the filter for the SizeCurveRecommendations we want to count
     *   }
     * })
    **/
    count<T extends SizeCurveRecommendationCountArgs>(
      args?: Subset<T, SizeCurveRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SizeCurveRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SizeCurveRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SizeCurveRecommendationAggregateArgs>(args: Subset<T, SizeCurveRecommendationAggregateArgs>): Prisma.PrismaPromise<GetSizeCurveRecommendationAggregateType<T>>

    /**
     * Group by SizeCurveRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCurveRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SizeCurveRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SizeCurveRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: SizeCurveRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SizeCurveRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSizeCurveRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SizeCurveRecommendation model
   */
  readonly fields: SizeCurveRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SizeCurveRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SizeCurveRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sku<T extends SkuCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalogDefaultArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoreDefaultArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SizeCurveRecommendation model
   */ 
  interface SizeCurveRecommendationFieldRefs {
    readonly id: FieldRef<"SizeCurveRecommendation", 'String'>
    readonly skuId: FieldRef<"SizeCurveRecommendation", 'String'>
    readonly storeId: FieldRef<"SizeCurveRecommendation", 'String'>
    readonly category: FieldRef<"SizeCurveRecommendation", 'String'>
    readonly sizeCode: FieldRef<"SizeCurveRecommendation", 'String'>
    readonly recommendedPct: FieldRef<"SizeCurveRecommendation", 'Decimal'>
    readonly confidence: FieldRef<"SizeCurveRecommendation", 'Decimal'>
    readonly basedOnSeasons: FieldRef<"SizeCurveRecommendation", 'Int'>
    readonly reasoning: FieldRef<"SizeCurveRecommendation", 'String'>
    readonly createdAt: FieldRef<"SizeCurveRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SizeCurveRecommendation findUnique
   */
  export type SizeCurveRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SizeCurveRecommendation to fetch.
     */
    where: SizeCurveRecommendationWhereUniqueInput
  }

  /**
   * SizeCurveRecommendation findUniqueOrThrow
   */
  export type SizeCurveRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SizeCurveRecommendation to fetch.
     */
    where: SizeCurveRecommendationWhereUniqueInput
  }

  /**
   * SizeCurveRecommendation findFirst
   */
  export type SizeCurveRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SizeCurveRecommendation to fetch.
     */
    where?: SizeCurveRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCurveRecommendations to fetch.
     */
    orderBy?: SizeCurveRecommendationOrderByWithRelationInput | SizeCurveRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SizeCurveRecommendations.
     */
    cursor?: SizeCurveRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCurveRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCurveRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SizeCurveRecommendations.
     */
    distinct?: SizeCurveRecommendationScalarFieldEnum | SizeCurveRecommendationScalarFieldEnum[]
  }

  /**
   * SizeCurveRecommendation findFirstOrThrow
   */
  export type SizeCurveRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SizeCurveRecommendation to fetch.
     */
    where?: SizeCurveRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCurveRecommendations to fetch.
     */
    orderBy?: SizeCurveRecommendationOrderByWithRelationInput | SizeCurveRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SizeCurveRecommendations.
     */
    cursor?: SizeCurveRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCurveRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCurveRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SizeCurveRecommendations.
     */
    distinct?: SizeCurveRecommendationScalarFieldEnum | SizeCurveRecommendationScalarFieldEnum[]
  }

  /**
   * SizeCurveRecommendation findMany
   */
  export type SizeCurveRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SizeCurveRecommendations to fetch.
     */
    where?: SizeCurveRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SizeCurveRecommendations to fetch.
     */
    orderBy?: SizeCurveRecommendationOrderByWithRelationInput | SizeCurveRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SizeCurveRecommendations.
     */
    cursor?: SizeCurveRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SizeCurveRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SizeCurveRecommendations.
     */
    skip?: number
    distinct?: SizeCurveRecommendationScalarFieldEnum | SizeCurveRecommendationScalarFieldEnum[]
  }

  /**
   * SizeCurveRecommendation create
   */
  export type SizeCurveRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a SizeCurveRecommendation.
     */
    data: XOR<SizeCurveRecommendationCreateInput, SizeCurveRecommendationUncheckedCreateInput>
  }

  /**
   * SizeCurveRecommendation createMany
   */
  export type SizeCurveRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SizeCurveRecommendations.
     */
    data: SizeCurveRecommendationCreateManyInput | SizeCurveRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SizeCurveRecommendation createManyAndReturn
   */
  export type SizeCurveRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SizeCurveRecommendations.
     */
    data: SizeCurveRecommendationCreateManyInput | SizeCurveRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SizeCurveRecommendation update
   */
  export type SizeCurveRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a SizeCurveRecommendation.
     */
    data: XOR<SizeCurveRecommendationUpdateInput, SizeCurveRecommendationUncheckedUpdateInput>
    /**
     * Choose, which SizeCurveRecommendation to update.
     */
    where: SizeCurveRecommendationWhereUniqueInput
  }

  /**
   * SizeCurveRecommendation updateMany
   */
  export type SizeCurveRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SizeCurveRecommendations.
     */
    data: XOR<SizeCurveRecommendationUpdateManyMutationInput, SizeCurveRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which SizeCurveRecommendations to update
     */
    where?: SizeCurveRecommendationWhereInput
  }

  /**
   * SizeCurveRecommendation upsert
   */
  export type SizeCurveRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the SizeCurveRecommendation to update in case it exists.
     */
    where: SizeCurveRecommendationWhereUniqueInput
    /**
     * In case the SizeCurveRecommendation found by the `where` argument doesn't exist, create a new SizeCurveRecommendation with this data.
     */
    create: XOR<SizeCurveRecommendationCreateInput, SizeCurveRecommendationUncheckedCreateInput>
    /**
     * In case the SizeCurveRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SizeCurveRecommendationUpdateInput, SizeCurveRecommendationUncheckedUpdateInput>
  }

  /**
   * SizeCurveRecommendation delete
   */
  export type SizeCurveRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
    /**
     * Filter which SizeCurveRecommendation to delete.
     */
    where: SizeCurveRecommendationWhereUniqueInput
  }

  /**
   * SizeCurveRecommendation deleteMany
   */
  export type SizeCurveRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SizeCurveRecommendations to delete
     */
    where?: SizeCurveRecommendationWhereInput
  }

  /**
   * SizeCurveRecommendation without action
   */
  export type SizeCurveRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCurveRecommendation
     */
    select?: SizeCurveRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeCurveRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model BudgetAlert
   */

  export type AggregateBudgetAlert = {
    _count: BudgetAlertCountAggregateOutputType | null
    _avg: BudgetAlertAvgAggregateOutputType | null
    _sum: BudgetAlertSumAggregateOutputType | null
    _min: BudgetAlertMinAggregateOutputType | null
    _max: BudgetAlertMaxAggregateOutputType | null
  }

  export type BudgetAlertAvgAggregateOutputType = {
    metricValue: Decimal | null
    threshold: Decimal | null
  }

  export type BudgetAlertSumAggregateOutputType = {
    metricValue: Decimal | null
    threshold: Decimal | null
  }

  export type BudgetAlertMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    alertType: string | null
    severity: string | null
    title: string | null
    message: string | null
    metricValue: Decimal | null
    threshold: Decimal | null
    category: string | null
    isRead: boolean | null
    isDismissed: boolean | null
    createdAt: Date | null
  }

  export type BudgetAlertMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    alertType: string | null
    severity: string | null
    title: string | null
    message: string | null
    metricValue: Decimal | null
    threshold: Decimal | null
    category: string | null
    isRead: boolean | null
    isDismissed: boolean | null
    createdAt: Date | null
  }

  export type BudgetAlertCountAggregateOutputType = {
    id: number
    budgetId: number
    alertType: number
    severity: number
    title: number
    message: number
    metricValue: number
    threshold: number
    category: number
    isRead: number
    isDismissed: number
    createdAt: number
    _all: number
  }


  export type BudgetAlertAvgAggregateInputType = {
    metricValue?: true
    threshold?: true
  }

  export type BudgetAlertSumAggregateInputType = {
    metricValue?: true
    threshold?: true
  }

  export type BudgetAlertMinAggregateInputType = {
    id?: true
    budgetId?: true
    alertType?: true
    severity?: true
    title?: true
    message?: true
    metricValue?: true
    threshold?: true
    category?: true
    isRead?: true
    isDismissed?: true
    createdAt?: true
  }

  export type BudgetAlertMaxAggregateInputType = {
    id?: true
    budgetId?: true
    alertType?: true
    severity?: true
    title?: true
    message?: true
    metricValue?: true
    threshold?: true
    category?: true
    isRead?: true
    isDismissed?: true
    createdAt?: true
  }

  export type BudgetAlertCountAggregateInputType = {
    id?: true
    budgetId?: true
    alertType?: true
    severity?: true
    title?: true
    message?: true
    metricValue?: true
    threshold?: true
    category?: true
    isRead?: true
    isDismissed?: true
    createdAt?: true
    _all?: true
  }

  export type BudgetAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetAlert to aggregate.
     */
    where?: BudgetAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetAlerts to fetch.
     */
    orderBy?: BudgetAlertOrderByWithRelationInput | BudgetAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetAlerts
    **/
    _count?: true | BudgetAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetAlertMaxAggregateInputType
  }

  export type GetBudgetAlertAggregateType<T extends BudgetAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetAlert[P]>
      : GetScalarType<T[P], AggregateBudgetAlert[P]>
  }




  export type BudgetAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetAlertWhereInput
    orderBy?: BudgetAlertOrderByWithAggregationInput | BudgetAlertOrderByWithAggregationInput[]
    by: BudgetAlertScalarFieldEnum[] | BudgetAlertScalarFieldEnum
    having?: BudgetAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetAlertCountAggregateInputType | true
    _avg?: BudgetAlertAvgAggregateInputType
    _sum?: BudgetAlertSumAggregateInputType
    _min?: BudgetAlertMinAggregateInputType
    _max?: BudgetAlertMaxAggregateInputType
  }

  export type BudgetAlertGroupByOutputType = {
    id: string
    budgetId: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal
    threshold: Decimal
    category: string | null
    isRead: boolean
    isDismissed: boolean
    createdAt: Date
    _count: BudgetAlertCountAggregateOutputType | null
    _avg: BudgetAlertAvgAggregateOutputType | null
    _sum: BudgetAlertSumAggregateOutputType | null
    _min: BudgetAlertMinAggregateOutputType | null
    _max: BudgetAlertMaxAggregateOutputType | null
  }

  type GetBudgetAlertGroupByPayload<T extends BudgetAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetAlertGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetAlertGroupByOutputType[P]>
        }
      >
    >


  export type BudgetAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    alertType?: boolean
    severity?: boolean
    title?: boolean
    message?: boolean
    metricValue?: boolean
    threshold?: boolean
    category?: boolean
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetAlert"]>

  export type BudgetAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    alertType?: boolean
    severity?: boolean
    title?: boolean
    message?: boolean
    metricValue?: boolean
    threshold?: boolean
    category?: boolean
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetAlert"]>

  export type BudgetAlertSelectScalar = {
    id?: boolean
    budgetId?: boolean
    alertType?: boolean
    severity?: boolean
    title?: boolean
    message?: boolean
    metricValue?: boolean
    threshold?: boolean
    category?: boolean
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: boolean
  }

  export type BudgetAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }

  export type $BudgetAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetAlert"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      alertType: string
      severity: string
      title: string
      message: string
      metricValue: Prisma.Decimal
      threshold: Prisma.Decimal
      category: string | null
      isRead: boolean
      isDismissed: boolean
      createdAt: Date
    }, ExtArgs["result"]["budgetAlert"]>
    composites: {}
  }

  type BudgetAlertGetPayload<S extends boolean | null | undefined | BudgetAlertDefaultArgs> = $Result.GetResult<Prisma.$BudgetAlertPayload, S>

  type BudgetAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetAlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetAlertCountAggregateInputType | true
    }

  export interface BudgetAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetAlert'], meta: { name: 'BudgetAlert' } }
    /**
     * Find zero or one BudgetAlert that matches the filter.
     * @param {BudgetAlertFindUniqueArgs} args - Arguments to find a BudgetAlert
     * @example
     * // Get one BudgetAlert
     * const budgetAlert = await prisma.budgetAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetAlertFindUniqueArgs>(args: SelectSubset<T, BudgetAlertFindUniqueArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BudgetAlert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetAlertFindUniqueOrThrowArgs} args - Arguments to find a BudgetAlert
     * @example
     * // Get one BudgetAlert
     * const budgetAlert = await prisma.budgetAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BudgetAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertFindFirstArgs} args - Arguments to find a BudgetAlert
     * @example
     * // Get one BudgetAlert
     * const budgetAlert = await prisma.budgetAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetAlertFindFirstArgs>(args?: SelectSubset<T, BudgetAlertFindFirstArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BudgetAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertFindFirstOrThrowArgs} args - Arguments to find a BudgetAlert
     * @example
     * // Get one BudgetAlert
     * const budgetAlert = await prisma.budgetAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BudgetAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetAlerts
     * const budgetAlerts = await prisma.budgetAlert.findMany()
     * 
     * // Get first 10 BudgetAlerts
     * const budgetAlerts = await prisma.budgetAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetAlertWithIdOnly = await prisma.budgetAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetAlertFindManyArgs>(args?: SelectSubset<T, BudgetAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BudgetAlert.
     * @param {BudgetAlertCreateArgs} args - Arguments to create a BudgetAlert.
     * @example
     * // Create one BudgetAlert
     * const BudgetAlert = await prisma.budgetAlert.create({
     *   data: {
     *     // ... data to create a BudgetAlert
     *   }
     * })
     * 
     */
    create<T extends BudgetAlertCreateArgs>(args: SelectSubset<T, BudgetAlertCreateArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BudgetAlerts.
     * @param {BudgetAlertCreateManyArgs} args - Arguments to create many BudgetAlerts.
     * @example
     * // Create many BudgetAlerts
     * const budgetAlert = await prisma.budgetAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetAlertCreateManyArgs>(args?: SelectSubset<T, BudgetAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetAlerts and returns the data saved in the database.
     * @param {BudgetAlertCreateManyAndReturnArgs} args - Arguments to create many BudgetAlerts.
     * @example
     * // Create many BudgetAlerts
     * const budgetAlert = await prisma.budgetAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetAlerts and only return the `id`
     * const budgetAlertWithIdOnly = await prisma.budgetAlert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BudgetAlert.
     * @param {BudgetAlertDeleteArgs} args - Arguments to delete one BudgetAlert.
     * @example
     * // Delete one BudgetAlert
     * const BudgetAlert = await prisma.budgetAlert.delete({
     *   where: {
     *     // ... filter to delete one BudgetAlert
     *   }
     * })
     * 
     */
    delete<T extends BudgetAlertDeleteArgs>(args: SelectSubset<T, BudgetAlertDeleteArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BudgetAlert.
     * @param {BudgetAlertUpdateArgs} args - Arguments to update one BudgetAlert.
     * @example
     * // Update one BudgetAlert
     * const budgetAlert = await prisma.budgetAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetAlertUpdateArgs>(args: SelectSubset<T, BudgetAlertUpdateArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BudgetAlerts.
     * @param {BudgetAlertDeleteManyArgs} args - Arguments to filter BudgetAlerts to delete.
     * @example
     * // Delete a few BudgetAlerts
     * const { count } = await prisma.budgetAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetAlertDeleteManyArgs>(args?: SelectSubset<T, BudgetAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetAlerts
     * const budgetAlert = await prisma.budgetAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetAlertUpdateManyArgs>(args: SelectSubset<T, BudgetAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudgetAlert.
     * @param {BudgetAlertUpsertArgs} args - Arguments to update or create a BudgetAlert.
     * @example
     * // Update or create a BudgetAlert
     * const budgetAlert = await prisma.budgetAlert.upsert({
     *   create: {
     *     // ... data to create a BudgetAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetAlert we want to update
     *   }
     * })
     */
    upsert<T extends BudgetAlertUpsertArgs>(args: SelectSubset<T, BudgetAlertUpsertArgs<ExtArgs>>): Prisma__BudgetAlertClient<$Result.GetResult<Prisma.$BudgetAlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BudgetAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertCountArgs} args - Arguments to filter BudgetAlerts to count.
     * @example
     * // Count the number of BudgetAlerts
     * const count = await prisma.budgetAlert.count({
     *   where: {
     *     // ... the filter for the BudgetAlerts we want to count
     *   }
     * })
    **/
    count<T extends BudgetAlertCountArgs>(
      args?: Subset<T, BudgetAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAlertAggregateArgs>(args: Subset<T, BudgetAlertAggregateArgs>): Prisma.PrismaPromise<GetBudgetAlertAggregateType<T>>

    /**
     * Group by BudgetAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetAlertGroupByArgs['orderBy'] }
        : { orderBy?: BudgetAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetAlert model
   */
  readonly fields: BudgetAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetAlert model
   */ 
  interface BudgetAlertFieldRefs {
    readonly id: FieldRef<"BudgetAlert", 'String'>
    readonly budgetId: FieldRef<"BudgetAlert", 'String'>
    readonly alertType: FieldRef<"BudgetAlert", 'String'>
    readonly severity: FieldRef<"BudgetAlert", 'String'>
    readonly title: FieldRef<"BudgetAlert", 'String'>
    readonly message: FieldRef<"BudgetAlert", 'String'>
    readonly metricValue: FieldRef<"BudgetAlert", 'Decimal'>
    readonly threshold: FieldRef<"BudgetAlert", 'Decimal'>
    readonly category: FieldRef<"BudgetAlert", 'String'>
    readonly isRead: FieldRef<"BudgetAlert", 'Boolean'>
    readonly isDismissed: FieldRef<"BudgetAlert", 'Boolean'>
    readonly createdAt: FieldRef<"BudgetAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BudgetAlert findUnique
   */
  export type BudgetAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * Filter, which BudgetAlert to fetch.
     */
    where: BudgetAlertWhereUniqueInput
  }

  /**
   * BudgetAlert findUniqueOrThrow
   */
  export type BudgetAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * Filter, which BudgetAlert to fetch.
     */
    where: BudgetAlertWhereUniqueInput
  }

  /**
   * BudgetAlert findFirst
   */
  export type BudgetAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * Filter, which BudgetAlert to fetch.
     */
    where?: BudgetAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetAlerts to fetch.
     */
    orderBy?: BudgetAlertOrderByWithRelationInput | BudgetAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetAlerts.
     */
    cursor?: BudgetAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetAlerts.
     */
    distinct?: BudgetAlertScalarFieldEnum | BudgetAlertScalarFieldEnum[]
  }

  /**
   * BudgetAlert findFirstOrThrow
   */
  export type BudgetAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * Filter, which BudgetAlert to fetch.
     */
    where?: BudgetAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetAlerts to fetch.
     */
    orderBy?: BudgetAlertOrderByWithRelationInput | BudgetAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetAlerts.
     */
    cursor?: BudgetAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetAlerts.
     */
    distinct?: BudgetAlertScalarFieldEnum | BudgetAlertScalarFieldEnum[]
  }

  /**
   * BudgetAlert findMany
   */
  export type BudgetAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * Filter, which BudgetAlerts to fetch.
     */
    where?: BudgetAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetAlerts to fetch.
     */
    orderBy?: BudgetAlertOrderByWithRelationInput | BudgetAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetAlerts.
     */
    cursor?: BudgetAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetAlerts.
     */
    skip?: number
    distinct?: BudgetAlertScalarFieldEnum | BudgetAlertScalarFieldEnum[]
  }

  /**
   * BudgetAlert create
   */
  export type BudgetAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetAlert.
     */
    data: XOR<BudgetAlertCreateInput, BudgetAlertUncheckedCreateInput>
  }

  /**
   * BudgetAlert createMany
   */
  export type BudgetAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetAlerts.
     */
    data: BudgetAlertCreateManyInput | BudgetAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetAlert createManyAndReturn
   */
  export type BudgetAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BudgetAlerts.
     */
    data: BudgetAlertCreateManyInput | BudgetAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetAlert update
   */
  export type BudgetAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetAlert.
     */
    data: XOR<BudgetAlertUpdateInput, BudgetAlertUncheckedUpdateInput>
    /**
     * Choose, which BudgetAlert to update.
     */
    where: BudgetAlertWhereUniqueInput
  }

  /**
   * BudgetAlert updateMany
   */
  export type BudgetAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetAlerts.
     */
    data: XOR<BudgetAlertUpdateManyMutationInput, BudgetAlertUncheckedUpdateManyInput>
    /**
     * Filter which BudgetAlerts to update
     */
    where?: BudgetAlertWhereInput
  }

  /**
   * BudgetAlert upsert
   */
  export type BudgetAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetAlert to update in case it exists.
     */
    where: BudgetAlertWhereUniqueInput
    /**
     * In case the BudgetAlert found by the `where` argument doesn't exist, create a new BudgetAlert with this data.
     */
    create: XOR<BudgetAlertCreateInput, BudgetAlertUncheckedCreateInput>
    /**
     * In case the BudgetAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetAlertUpdateInput, BudgetAlertUncheckedUpdateInput>
  }

  /**
   * BudgetAlert delete
   */
  export type BudgetAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
    /**
     * Filter which BudgetAlert to delete.
     */
    where: BudgetAlertWhereUniqueInput
  }

  /**
   * BudgetAlert deleteMany
   */
  export type BudgetAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetAlerts to delete
     */
    where?: BudgetAlertWhereInput
  }

  /**
   * BudgetAlert without action
   */
  export type BudgetAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetAlert
     */
    select?: BudgetAlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetAlertInclude<ExtArgs> | null
  }


  /**
   * Model BudgetSnapshot
   */

  export type AggregateBudgetSnapshot = {
    _count: BudgetSnapshotCountAggregateOutputType | null
    _avg: BudgetSnapshotAvgAggregateOutputType | null
    _sum: BudgetSnapshotSumAggregateOutputType | null
    _min: BudgetSnapshotMinAggregateOutputType | null
    _max: BudgetSnapshotMaxAggregateOutputType | null
  }

  export type BudgetSnapshotAvgAggregateOutputType = {
    totalCommitted: Decimal | null
    totalPlanned: Decimal | null
    utilizationPct: Decimal | null
  }

  export type BudgetSnapshotSumAggregateOutputType = {
    totalCommitted: Decimal | null
    totalPlanned: Decimal | null
    utilizationPct: Decimal | null
  }

  export type BudgetSnapshotMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    snapshotDate: Date | null
    totalCommitted: Decimal | null
    totalPlanned: Decimal | null
    utilizationPct: Decimal | null
  }

  export type BudgetSnapshotMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    snapshotDate: Date | null
    totalCommitted: Decimal | null
    totalPlanned: Decimal | null
    utilizationPct: Decimal | null
  }

  export type BudgetSnapshotCountAggregateOutputType = {
    id: number
    budgetId: number
    snapshotDate: number
    totalCommitted: number
    totalPlanned: number
    utilizationPct: number
    _all: number
  }


  export type BudgetSnapshotAvgAggregateInputType = {
    totalCommitted?: true
    totalPlanned?: true
    utilizationPct?: true
  }

  export type BudgetSnapshotSumAggregateInputType = {
    totalCommitted?: true
    totalPlanned?: true
    utilizationPct?: true
  }

  export type BudgetSnapshotMinAggregateInputType = {
    id?: true
    budgetId?: true
    snapshotDate?: true
    totalCommitted?: true
    totalPlanned?: true
    utilizationPct?: true
  }

  export type BudgetSnapshotMaxAggregateInputType = {
    id?: true
    budgetId?: true
    snapshotDate?: true
    totalCommitted?: true
    totalPlanned?: true
    utilizationPct?: true
  }

  export type BudgetSnapshotCountAggregateInputType = {
    id?: true
    budgetId?: true
    snapshotDate?: true
    totalCommitted?: true
    totalPlanned?: true
    utilizationPct?: true
    _all?: true
  }

  export type BudgetSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetSnapshot to aggregate.
     */
    where?: BudgetSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetSnapshots to fetch.
     */
    orderBy?: BudgetSnapshotOrderByWithRelationInput | BudgetSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BudgetSnapshots
    **/
    _count?: true | BudgetSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetSnapshotMaxAggregateInputType
  }

  export type GetBudgetSnapshotAggregateType<T extends BudgetSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgetSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgetSnapshot[P]>
      : GetScalarType<T[P], AggregateBudgetSnapshot[P]>
  }




  export type BudgetSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetSnapshotWhereInput
    orderBy?: BudgetSnapshotOrderByWithAggregationInput | BudgetSnapshotOrderByWithAggregationInput[]
    by: BudgetSnapshotScalarFieldEnum[] | BudgetSnapshotScalarFieldEnum
    having?: BudgetSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetSnapshotCountAggregateInputType | true
    _avg?: BudgetSnapshotAvgAggregateInputType
    _sum?: BudgetSnapshotSumAggregateInputType
    _min?: BudgetSnapshotMinAggregateInputType
    _max?: BudgetSnapshotMaxAggregateInputType
  }

  export type BudgetSnapshotGroupByOutputType = {
    id: string
    budgetId: string
    snapshotDate: Date
    totalCommitted: Decimal
    totalPlanned: Decimal
    utilizationPct: Decimal
    _count: BudgetSnapshotCountAggregateOutputType | null
    _avg: BudgetSnapshotAvgAggregateOutputType | null
    _sum: BudgetSnapshotSumAggregateOutputType | null
    _min: BudgetSnapshotMinAggregateOutputType | null
    _max: BudgetSnapshotMaxAggregateOutputType | null
  }

  type GetBudgetSnapshotGroupByPayload<T extends BudgetSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    snapshotDate?: boolean
    totalCommitted?: boolean
    totalPlanned?: boolean
    utilizationPct?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetSnapshot"]>

  export type BudgetSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    snapshotDate?: boolean
    totalCommitted?: boolean
    totalPlanned?: boolean
    utilizationPct?: boolean
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgetSnapshot"]>

  export type BudgetSnapshotSelectScalar = {
    id?: boolean
    budgetId?: boolean
    snapshotDate?: boolean
    totalCommitted?: boolean
    totalPlanned?: boolean
    utilizationPct?: boolean
  }

  export type BudgetSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }
  export type BudgetSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget?: boolean | BudgetDefaultArgs<ExtArgs>
  }

  export type $BudgetSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BudgetSnapshot"
    objects: {
      budget: Prisma.$BudgetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      snapshotDate: Date
      totalCommitted: Prisma.Decimal
      totalPlanned: Prisma.Decimal
      utilizationPct: Prisma.Decimal
    }, ExtArgs["result"]["budgetSnapshot"]>
    composites: {}
  }

  type BudgetSnapshotGetPayload<S extends boolean | null | undefined | BudgetSnapshotDefaultArgs> = $Result.GetResult<Prisma.$BudgetSnapshotPayload, S>

  type BudgetSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BudgetSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BudgetSnapshotCountAggregateInputType | true
    }

  export interface BudgetSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BudgetSnapshot'], meta: { name: 'BudgetSnapshot' } }
    /**
     * Find zero or one BudgetSnapshot that matches the filter.
     * @param {BudgetSnapshotFindUniqueArgs} args - Arguments to find a BudgetSnapshot
     * @example
     * // Get one BudgetSnapshot
     * const budgetSnapshot = await prisma.budgetSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetSnapshotFindUniqueArgs>(args: SelectSubset<T, BudgetSnapshotFindUniqueArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BudgetSnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BudgetSnapshotFindUniqueOrThrowArgs} args - Arguments to find a BudgetSnapshot
     * @example
     * // Get one BudgetSnapshot
     * const budgetSnapshot = await prisma.budgetSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BudgetSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotFindFirstArgs} args - Arguments to find a BudgetSnapshot
     * @example
     * // Get one BudgetSnapshot
     * const budgetSnapshot = await prisma.budgetSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetSnapshotFindFirstArgs>(args?: SelectSubset<T, BudgetSnapshotFindFirstArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BudgetSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotFindFirstOrThrowArgs} args - Arguments to find a BudgetSnapshot
     * @example
     * // Get one BudgetSnapshot
     * const budgetSnapshot = await prisma.budgetSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BudgetSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BudgetSnapshots
     * const budgetSnapshots = await prisma.budgetSnapshot.findMany()
     * 
     * // Get first 10 BudgetSnapshots
     * const budgetSnapshots = await prisma.budgetSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetSnapshotWithIdOnly = await prisma.budgetSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetSnapshotFindManyArgs>(args?: SelectSubset<T, BudgetSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BudgetSnapshot.
     * @param {BudgetSnapshotCreateArgs} args - Arguments to create a BudgetSnapshot.
     * @example
     * // Create one BudgetSnapshot
     * const BudgetSnapshot = await prisma.budgetSnapshot.create({
     *   data: {
     *     // ... data to create a BudgetSnapshot
     *   }
     * })
     * 
     */
    create<T extends BudgetSnapshotCreateArgs>(args: SelectSubset<T, BudgetSnapshotCreateArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BudgetSnapshots.
     * @param {BudgetSnapshotCreateManyArgs} args - Arguments to create many BudgetSnapshots.
     * @example
     * // Create many BudgetSnapshots
     * const budgetSnapshot = await prisma.budgetSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetSnapshotCreateManyArgs>(args?: SelectSubset<T, BudgetSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BudgetSnapshots and returns the data saved in the database.
     * @param {BudgetSnapshotCreateManyAndReturnArgs} args - Arguments to create many BudgetSnapshots.
     * @example
     * // Create many BudgetSnapshots
     * const budgetSnapshot = await prisma.budgetSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BudgetSnapshots and only return the `id`
     * const budgetSnapshotWithIdOnly = await prisma.budgetSnapshot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BudgetSnapshot.
     * @param {BudgetSnapshotDeleteArgs} args - Arguments to delete one BudgetSnapshot.
     * @example
     * // Delete one BudgetSnapshot
     * const BudgetSnapshot = await prisma.budgetSnapshot.delete({
     *   where: {
     *     // ... filter to delete one BudgetSnapshot
     *   }
     * })
     * 
     */
    delete<T extends BudgetSnapshotDeleteArgs>(args: SelectSubset<T, BudgetSnapshotDeleteArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BudgetSnapshot.
     * @param {BudgetSnapshotUpdateArgs} args - Arguments to update one BudgetSnapshot.
     * @example
     * // Update one BudgetSnapshot
     * const budgetSnapshot = await prisma.budgetSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetSnapshotUpdateArgs>(args: SelectSubset<T, BudgetSnapshotUpdateArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BudgetSnapshots.
     * @param {BudgetSnapshotDeleteManyArgs} args - Arguments to filter BudgetSnapshots to delete.
     * @example
     * // Delete a few BudgetSnapshots
     * const { count } = await prisma.budgetSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetSnapshotDeleteManyArgs>(args?: SelectSubset<T, BudgetSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BudgetSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BudgetSnapshots
     * const budgetSnapshot = await prisma.budgetSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetSnapshotUpdateManyArgs>(args: SelectSubset<T, BudgetSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BudgetSnapshot.
     * @param {BudgetSnapshotUpsertArgs} args - Arguments to update or create a BudgetSnapshot.
     * @example
     * // Update or create a BudgetSnapshot
     * const budgetSnapshot = await prisma.budgetSnapshot.upsert({
     *   create: {
     *     // ... data to create a BudgetSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BudgetSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends BudgetSnapshotUpsertArgs>(args: SelectSubset<T, BudgetSnapshotUpsertArgs<ExtArgs>>): Prisma__BudgetSnapshotClient<$Result.GetResult<Prisma.$BudgetSnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BudgetSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotCountArgs} args - Arguments to filter BudgetSnapshots to count.
     * @example
     * // Count the number of BudgetSnapshots
     * const count = await prisma.budgetSnapshot.count({
     *   where: {
     *     // ... the filter for the BudgetSnapshots we want to count
     *   }
     * })
    **/
    count<T extends BudgetSnapshotCountArgs>(
      args?: Subset<T, BudgetSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BudgetSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetSnapshotAggregateArgs>(args: Subset<T, BudgetSnapshotAggregateArgs>): Prisma.PrismaPromise<GetBudgetSnapshotAggregateType<T>>

    /**
     * Group by BudgetSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: BudgetSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BudgetSnapshot model
   */
  readonly fields: BudgetSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BudgetSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget<T extends BudgetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDefaultArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BudgetSnapshot model
   */ 
  interface BudgetSnapshotFieldRefs {
    readonly id: FieldRef<"BudgetSnapshot", 'String'>
    readonly budgetId: FieldRef<"BudgetSnapshot", 'String'>
    readonly snapshotDate: FieldRef<"BudgetSnapshot", 'DateTime'>
    readonly totalCommitted: FieldRef<"BudgetSnapshot", 'Decimal'>
    readonly totalPlanned: FieldRef<"BudgetSnapshot", 'Decimal'>
    readonly utilizationPct: FieldRef<"BudgetSnapshot", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BudgetSnapshot findUnique
   */
  export type BudgetSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which BudgetSnapshot to fetch.
     */
    where: BudgetSnapshotWhereUniqueInput
  }

  /**
   * BudgetSnapshot findUniqueOrThrow
   */
  export type BudgetSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which BudgetSnapshot to fetch.
     */
    where: BudgetSnapshotWhereUniqueInput
  }

  /**
   * BudgetSnapshot findFirst
   */
  export type BudgetSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which BudgetSnapshot to fetch.
     */
    where?: BudgetSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetSnapshots to fetch.
     */
    orderBy?: BudgetSnapshotOrderByWithRelationInput | BudgetSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetSnapshots.
     */
    cursor?: BudgetSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetSnapshots.
     */
    distinct?: BudgetSnapshotScalarFieldEnum | BudgetSnapshotScalarFieldEnum[]
  }

  /**
   * BudgetSnapshot findFirstOrThrow
   */
  export type BudgetSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which BudgetSnapshot to fetch.
     */
    where?: BudgetSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetSnapshots to fetch.
     */
    orderBy?: BudgetSnapshotOrderByWithRelationInput | BudgetSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BudgetSnapshots.
     */
    cursor?: BudgetSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BudgetSnapshots.
     */
    distinct?: BudgetSnapshotScalarFieldEnum | BudgetSnapshotScalarFieldEnum[]
  }

  /**
   * BudgetSnapshot findMany
   */
  export type BudgetSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which BudgetSnapshots to fetch.
     */
    where?: BudgetSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BudgetSnapshots to fetch.
     */
    orderBy?: BudgetSnapshotOrderByWithRelationInput | BudgetSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BudgetSnapshots.
     */
    cursor?: BudgetSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BudgetSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BudgetSnapshots.
     */
    skip?: number
    distinct?: BudgetSnapshotScalarFieldEnum | BudgetSnapshotScalarFieldEnum[]
  }

  /**
   * BudgetSnapshot create
   */
  export type BudgetSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a BudgetSnapshot.
     */
    data: XOR<BudgetSnapshotCreateInput, BudgetSnapshotUncheckedCreateInput>
  }

  /**
   * BudgetSnapshot createMany
   */
  export type BudgetSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BudgetSnapshots.
     */
    data: BudgetSnapshotCreateManyInput | BudgetSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BudgetSnapshot createManyAndReturn
   */
  export type BudgetSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BudgetSnapshots.
     */
    data: BudgetSnapshotCreateManyInput | BudgetSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BudgetSnapshot update
   */
  export type BudgetSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a BudgetSnapshot.
     */
    data: XOR<BudgetSnapshotUpdateInput, BudgetSnapshotUncheckedUpdateInput>
    /**
     * Choose, which BudgetSnapshot to update.
     */
    where: BudgetSnapshotWhereUniqueInput
  }

  /**
   * BudgetSnapshot updateMany
   */
  export type BudgetSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BudgetSnapshots.
     */
    data: XOR<BudgetSnapshotUpdateManyMutationInput, BudgetSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which BudgetSnapshots to update
     */
    where?: BudgetSnapshotWhereInput
  }

  /**
   * BudgetSnapshot upsert
   */
  export type BudgetSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the BudgetSnapshot to update in case it exists.
     */
    where: BudgetSnapshotWhereUniqueInput
    /**
     * In case the BudgetSnapshot found by the `where` argument doesn't exist, create a new BudgetSnapshot with this data.
     */
    create: XOR<BudgetSnapshotCreateInput, BudgetSnapshotUncheckedCreateInput>
    /**
     * In case the BudgetSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetSnapshotUpdateInput, BudgetSnapshotUncheckedUpdateInput>
  }

  /**
   * BudgetSnapshot delete
   */
  export type BudgetSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
    /**
     * Filter which BudgetSnapshot to delete.
     */
    where: BudgetSnapshotWhereUniqueInput
  }

  /**
   * BudgetSnapshot deleteMany
   */
  export type BudgetSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BudgetSnapshots to delete
     */
    where?: BudgetSnapshotWhereInput
  }

  /**
   * BudgetSnapshot without action
   */
  export type BudgetSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetSnapshot
     */
    select?: BudgetSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model AllocationHistory
   */

  export type AggregateAllocationHistory = {
    _count: AllocationHistoryCountAggregateOutputType | null
    _avg: AllocationHistoryAvgAggregateOutputType | null
    _sum: AllocationHistorySumAggregateOutputType | null
    _min: AllocationHistoryMinAggregateOutputType | null
    _max: AllocationHistoryMaxAggregateOutputType | null
  }

  export type AllocationHistoryAvgAggregateOutputType = {
    fiscalYear: number | null
    allocatedPct: Decimal | null
    allocatedAmount: Decimal | null
    actualSales: Decimal | null
    sellThroughPct: Decimal | null
  }

  export type AllocationHistorySumAggregateOutputType = {
    fiscalYear: number | null
    allocatedPct: Decimal | null
    allocatedAmount: Decimal | null
    actualSales: Decimal | null
    sellThroughPct: Decimal | null
  }

  export type AllocationHistoryMinAggregateOutputType = {
    id: string | null
    budgetId: string | null
    seasonGroup: string | null
    seasonType: string | null
    fiscalYear: number | null
    dimensionType: string | null
    dimensionValue: string | null
    allocatedPct: Decimal | null
    allocatedAmount: Decimal | null
    actualSales: Decimal | null
    sellThroughPct: Decimal | null
    createdAt: Date | null
  }

  export type AllocationHistoryMaxAggregateOutputType = {
    id: string | null
    budgetId: string | null
    seasonGroup: string | null
    seasonType: string | null
    fiscalYear: number | null
    dimensionType: string | null
    dimensionValue: string | null
    allocatedPct: Decimal | null
    allocatedAmount: Decimal | null
    actualSales: Decimal | null
    sellThroughPct: Decimal | null
    createdAt: Date | null
  }

  export type AllocationHistoryCountAggregateOutputType = {
    id: number
    budgetId: number
    seasonGroup: number
    seasonType: number
    fiscalYear: number
    dimensionType: number
    dimensionValue: number
    allocatedPct: number
    allocatedAmount: number
    actualSales: number
    sellThroughPct: number
    createdAt: number
    _all: number
  }


  export type AllocationHistoryAvgAggregateInputType = {
    fiscalYear?: true
    allocatedPct?: true
    allocatedAmount?: true
    actualSales?: true
    sellThroughPct?: true
  }

  export type AllocationHistorySumAggregateInputType = {
    fiscalYear?: true
    allocatedPct?: true
    allocatedAmount?: true
    actualSales?: true
    sellThroughPct?: true
  }

  export type AllocationHistoryMinAggregateInputType = {
    id?: true
    budgetId?: true
    seasonGroup?: true
    seasonType?: true
    fiscalYear?: true
    dimensionType?: true
    dimensionValue?: true
    allocatedPct?: true
    allocatedAmount?: true
    actualSales?: true
    sellThroughPct?: true
    createdAt?: true
  }

  export type AllocationHistoryMaxAggregateInputType = {
    id?: true
    budgetId?: true
    seasonGroup?: true
    seasonType?: true
    fiscalYear?: true
    dimensionType?: true
    dimensionValue?: true
    allocatedPct?: true
    allocatedAmount?: true
    actualSales?: true
    sellThroughPct?: true
    createdAt?: true
  }

  export type AllocationHistoryCountAggregateInputType = {
    id?: true
    budgetId?: true
    seasonGroup?: true
    seasonType?: true
    fiscalYear?: true
    dimensionType?: true
    dimensionValue?: true
    allocatedPct?: true
    allocatedAmount?: true
    actualSales?: true
    sellThroughPct?: true
    createdAt?: true
    _all?: true
  }

  export type AllocationHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllocationHistory to aggregate.
     */
    where?: AllocationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationHistories to fetch.
     */
    orderBy?: AllocationHistoryOrderByWithRelationInput | AllocationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllocationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AllocationHistories
    **/
    _count?: true | AllocationHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AllocationHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AllocationHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllocationHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllocationHistoryMaxAggregateInputType
  }

  export type GetAllocationHistoryAggregateType<T extends AllocationHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAllocationHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllocationHistory[P]>
      : GetScalarType<T[P], AggregateAllocationHistory[P]>
  }




  export type AllocationHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationHistoryWhereInput
    orderBy?: AllocationHistoryOrderByWithAggregationInput | AllocationHistoryOrderByWithAggregationInput[]
    by: AllocationHistoryScalarFieldEnum[] | AllocationHistoryScalarFieldEnum
    having?: AllocationHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllocationHistoryCountAggregateInputType | true
    _avg?: AllocationHistoryAvgAggregateInputType
    _sum?: AllocationHistorySumAggregateInputType
    _min?: AllocationHistoryMinAggregateInputType
    _max?: AllocationHistoryMaxAggregateInputType
  }

  export type AllocationHistoryGroupByOutputType = {
    id: string
    budgetId: string
    seasonGroup: string
    seasonType: string
    fiscalYear: number
    dimensionType: string
    dimensionValue: string
    allocatedPct: Decimal
    allocatedAmount: Decimal
    actualSales: Decimal | null
    sellThroughPct: Decimal | null
    createdAt: Date
    _count: AllocationHistoryCountAggregateOutputType | null
    _avg: AllocationHistoryAvgAggregateOutputType | null
    _sum: AllocationHistorySumAggregateOutputType | null
    _min: AllocationHistoryMinAggregateOutputType | null
    _max: AllocationHistoryMaxAggregateOutputType | null
  }

  type GetAllocationHistoryGroupByPayload<T extends AllocationHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllocationHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllocationHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllocationHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AllocationHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AllocationHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    seasonGroup?: boolean
    seasonType?: boolean
    fiscalYear?: boolean
    dimensionType?: boolean
    dimensionValue?: boolean
    allocatedPct?: boolean
    allocatedAmount?: boolean
    actualSales?: boolean
    sellThroughPct?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["allocationHistory"]>

  export type AllocationHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetId?: boolean
    seasonGroup?: boolean
    seasonType?: boolean
    fiscalYear?: boolean
    dimensionType?: boolean
    dimensionValue?: boolean
    allocatedPct?: boolean
    allocatedAmount?: boolean
    actualSales?: boolean
    sellThroughPct?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["allocationHistory"]>

  export type AllocationHistorySelectScalar = {
    id?: boolean
    budgetId?: boolean
    seasonGroup?: boolean
    seasonType?: boolean
    fiscalYear?: boolean
    dimensionType?: boolean
    dimensionValue?: boolean
    allocatedPct?: boolean
    allocatedAmount?: boolean
    actualSales?: boolean
    sellThroughPct?: boolean
    createdAt?: boolean
  }


  export type $AllocationHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AllocationHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetId: string
      seasonGroup: string
      seasonType: string
      fiscalYear: number
      dimensionType: string
      dimensionValue: string
      allocatedPct: Prisma.Decimal
      allocatedAmount: Prisma.Decimal
      actualSales: Prisma.Decimal | null
      sellThroughPct: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["allocationHistory"]>
    composites: {}
  }

  type AllocationHistoryGetPayload<S extends boolean | null | undefined | AllocationHistoryDefaultArgs> = $Result.GetResult<Prisma.$AllocationHistoryPayload, S>

  type AllocationHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AllocationHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AllocationHistoryCountAggregateInputType | true
    }

  export interface AllocationHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AllocationHistory'], meta: { name: 'AllocationHistory' } }
    /**
     * Find zero or one AllocationHistory that matches the filter.
     * @param {AllocationHistoryFindUniqueArgs} args - Arguments to find a AllocationHistory
     * @example
     * // Get one AllocationHistory
     * const allocationHistory = await prisma.allocationHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllocationHistoryFindUniqueArgs>(args: SelectSubset<T, AllocationHistoryFindUniqueArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AllocationHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AllocationHistoryFindUniqueOrThrowArgs} args - Arguments to find a AllocationHistory
     * @example
     * // Get one AllocationHistory
     * const allocationHistory = await prisma.allocationHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllocationHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AllocationHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AllocationHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryFindFirstArgs} args - Arguments to find a AllocationHistory
     * @example
     * // Get one AllocationHistory
     * const allocationHistory = await prisma.allocationHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllocationHistoryFindFirstArgs>(args?: SelectSubset<T, AllocationHistoryFindFirstArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AllocationHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryFindFirstOrThrowArgs} args - Arguments to find a AllocationHistory
     * @example
     * // Get one AllocationHistory
     * const allocationHistory = await prisma.allocationHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllocationHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AllocationHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AllocationHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AllocationHistories
     * const allocationHistories = await prisma.allocationHistory.findMany()
     * 
     * // Get first 10 AllocationHistories
     * const allocationHistories = await prisma.allocationHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allocationHistoryWithIdOnly = await prisma.allocationHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllocationHistoryFindManyArgs>(args?: SelectSubset<T, AllocationHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AllocationHistory.
     * @param {AllocationHistoryCreateArgs} args - Arguments to create a AllocationHistory.
     * @example
     * // Create one AllocationHistory
     * const AllocationHistory = await prisma.allocationHistory.create({
     *   data: {
     *     // ... data to create a AllocationHistory
     *   }
     * })
     * 
     */
    create<T extends AllocationHistoryCreateArgs>(args: SelectSubset<T, AllocationHistoryCreateArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AllocationHistories.
     * @param {AllocationHistoryCreateManyArgs} args - Arguments to create many AllocationHistories.
     * @example
     * // Create many AllocationHistories
     * const allocationHistory = await prisma.allocationHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllocationHistoryCreateManyArgs>(args?: SelectSubset<T, AllocationHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AllocationHistories and returns the data saved in the database.
     * @param {AllocationHistoryCreateManyAndReturnArgs} args - Arguments to create many AllocationHistories.
     * @example
     * // Create many AllocationHistories
     * const allocationHistory = await prisma.allocationHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AllocationHistories and only return the `id`
     * const allocationHistoryWithIdOnly = await prisma.allocationHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllocationHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AllocationHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AllocationHistory.
     * @param {AllocationHistoryDeleteArgs} args - Arguments to delete one AllocationHistory.
     * @example
     * // Delete one AllocationHistory
     * const AllocationHistory = await prisma.allocationHistory.delete({
     *   where: {
     *     // ... filter to delete one AllocationHistory
     *   }
     * })
     * 
     */
    delete<T extends AllocationHistoryDeleteArgs>(args: SelectSubset<T, AllocationHistoryDeleteArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AllocationHistory.
     * @param {AllocationHistoryUpdateArgs} args - Arguments to update one AllocationHistory.
     * @example
     * // Update one AllocationHistory
     * const allocationHistory = await prisma.allocationHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllocationHistoryUpdateArgs>(args: SelectSubset<T, AllocationHistoryUpdateArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AllocationHistories.
     * @param {AllocationHistoryDeleteManyArgs} args - Arguments to filter AllocationHistories to delete.
     * @example
     * // Delete a few AllocationHistories
     * const { count } = await prisma.allocationHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllocationHistoryDeleteManyArgs>(args?: SelectSubset<T, AllocationHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllocationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AllocationHistories
     * const allocationHistory = await prisma.allocationHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllocationHistoryUpdateManyArgs>(args: SelectSubset<T, AllocationHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AllocationHistory.
     * @param {AllocationHistoryUpsertArgs} args - Arguments to update or create a AllocationHistory.
     * @example
     * // Update or create a AllocationHistory
     * const allocationHistory = await prisma.allocationHistory.upsert({
     *   create: {
     *     // ... data to create a AllocationHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AllocationHistory we want to update
     *   }
     * })
     */
    upsert<T extends AllocationHistoryUpsertArgs>(args: SelectSubset<T, AllocationHistoryUpsertArgs<ExtArgs>>): Prisma__AllocationHistoryClient<$Result.GetResult<Prisma.$AllocationHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AllocationHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryCountArgs} args - Arguments to filter AllocationHistories to count.
     * @example
     * // Count the number of AllocationHistories
     * const count = await prisma.allocationHistory.count({
     *   where: {
     *     // ... the filter for the AllocationHistories we want to count
     *   }
     * })
    **/
    count<T extends AllocationHistoryCountArgs>(
      args?: Subset<T, AllocationHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllocationHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AllocationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllocationHistoryAggregateArgs>(args: Subset<T, AllocationHistoryAggregateArgs>): Prisma.PrismaPromise<GetAllocationHistoryAggregateType<T>>

    /**
     * Group by AllocationHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllocationHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllocationHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AllocationHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllocationHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllocationHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AllocationHistory model
   */
  readonly fields: AllocationHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AllocationHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllocationHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AllocationHistory model
   */ 
  interface AllocationHistoryFieldRefs {
    readonly id: FieldRef<"AllocationHistory", 'String'>
    readonly budgetId: FieldRef<"AllocationHistory", 'String'>
    readonly seasonGroup: FieldRef<"AllocationHistory", 'String'>
    readonly seasonType: FieldRef<"AllocationHistory", 'String'>
    readonly fiscalYear: FieldRef<"AllocationHistory", 'Int'>
    readonly dimensionType: FieldRef<"AllocationHistory", 'String'>
    readonly dimensionValue: FieldRef<"AllocationHistory", 'String'>
    readonly allocatedPct: FieldRef<"AllocationHistory", 'Decimal'>
    readonly allocatedAmount: FieldRef<"AllocationHistory", 'Decimal'>
    readonly actualSales: FieldRef<"AllocationHistory", 'Decimal'>
    readonly sellThroughPct: FieldRef<"AllocationHistory", 'Decimal'>
    readonly createdAt: FieldRef<"AllocationHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AllocationHistory findUnique
   */
  export type AllocationHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * Filter, which AllocationHistory to fetch.
     */
    where: AllocationHistoryWhereUniqueInput
  }

  /**
   * AllocationHistory findUniqueOrThrow
   */
  export type AllocationHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * Filter, which AllocationHistory to fetch.
     */
    where: AllocationHistoryWhereUniqueInput
  }

  /**
   * AllocationHistory findFirst
   */
  export type AllocationHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * Filter, which AllocationHistory to fetch.
     */
    where?: AllocationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationHistories to fetch.
     */
    orderBy?: AllocationHistoryOrderByWithRelationInput | AllocationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllocationHistories.
     */
    cursor?: AllocationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllocationHistories.
     */
    distinct?: AllocationHistoryScalarFieldEnum | AllocationHistoryScalarFieldEnum[]
  }

  /**
   * AllocationHistory findFirstOrThrow
   */
  export type AllocationHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * Filter, which AllocationHistory to fetch.
     */
    where?: AllocationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationHistories to fetch.
     */
    orderBy?: AllocationHistoryOrderByWithRelationInput | AllocationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllocationHistories.
     */
    cursor?: AllocationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllocationHistories.
     */
    distinct?: AllocationHistoryScalarFieldEnum | AllocationHistoryScalarFieldEnum[]
  }

  /**
   * AllocationHistory findMany
   */
  export type AllocationHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * Filter, which AllocationHistories to fetch.
     */
    where?: AllocationHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationHistories to fetch.
     */
    orderBy?: AllocationHistoryOrderByWithRelationInput | AllocationHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AllocationHistories.
     */
    cursor?: AllocationHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationHistories.
     */
    skip?: number
    distinct?: AllocationHistoryScalarFieldEnum | AllocationHistoryScalarFieldEnum[]
  }

  /**
   * AllocationHistory create
   */
  export type AllocationHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * The data needed to create a AllocationHistory.
     */
    data: XOR<AllocationHistoryCreateInput, AllocationHistoryUncheckedCreateInput>
  }

  /**
   * AllocationHistory createMany
   */
  export type AllocationHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AllocationHistories.
     */
    data: AllocationHistoryCreateManyInput | AllocationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllocationHistory createManyAndReturn
   */
  export type AllocationHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AllocationHistories.
     */
    data: AllocationHistoryCreateManyInput | AllocationHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllocationHistory update
   */
  export type AllocationHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * The data needed to update a AllocationHistory.
     */
    data: XOR<AllocationHistoryUpdateInput, AllocationHistoryUncheckedUpdateInput>
    /**
     * Choose, which AllocationHistory to update.
     */
    where: AllocationHistoryWhereUniqueInput
  }

  /**
   * AllocationHistory updateMany
   */
  export type AllocationHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AllocationHistories.
     */
    data: XOR<AllocationHistoryUpdateManyMutationInput, AllocationHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AllocationHistories to update
     */
    where?: AllocationHistoryWhereInput
  }

  /**
   * AllocationHistory upsert
   */
  export type AllocationHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * The filter to search for the AllocationHistory to update in case it exists.
     */
    where: AllocationHistoryWhereUniqueInput
    /**
     * In case the AllocationHistory found by the `where` argument doesn't exist, create a new AllocationHistory with this data.
     */
    create: XOR<AllocationHistoryCreateInput, AllocationHistoryUncheckedCreateInput>
    /**
     * In case the AllocationHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllocationHistoryUpdateInput, AllocationHistoryUncheckedUpdateInput>
  }

  /**
   * AllocationHistory delete
   */
  export type AllocationHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
    /**
     * Filter which AllocationHistory to delete.
     */
    where: AllocationHistoryWhereUniqueInput
  }

  /**
   * AllocationHistory deleteMany
   */
  export type AllocationHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllocationHistories to delete
     */
    where?: AllocationHistoryWhereInput
  }

  /**
   * AllocationHistory without action
   */
  export type AllocationHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationHistory
     */
    select?: AllocationHistorySelect<ExtArgs> | null
  }


  /**
   * Model AllocationRecommendation
   */

  export type AggregateAllocationRecommendation = {
    _count: AllocationRecommendationCountAggregateOutputType | null
    _avg: AllocationRecommendationAvgAggregateOutputType | null
    _sum: AllocationRecommendationSumAggregateOutputType | null
    _min: AllocationRecommendationMinAggregateOutputType | null
    _max: AllocationRecommendationMaxAggregateOutputType | null
  }

  export type AllocationRecommendationAvgAggregateOutputType = {
    recommendedPct: Decimal | null
    recommendedAmt: Decimal | null
    confidence: Decimal | null
    basedOnSeasons: number | null
  }

  export type AllocationRecommendationSumAggregateOutputType = {
    recommendedPct: Decimal | null
    recommendedAmt: Decimal | null
    confidence: Decimal | null
    basedOnSeasons: number | null
  }

  export type AllocationRecommendationMinAggregateOutputType = {
    id: string | null
    budgetDetailId: string | null
    dimensionType: string | null
    dimensionValue: string | null
    recommendedPct: Decimal | null
    recommendedAmt: Decimal | null
    confidence: Decimal | null
    reasoning: string | null
    basedOnSeasons: number | null
    isApplied: boolean | null
    createdAt: Date | null
  }

  export type AllocationRecommendationMaxAggregateOutputType = {
    id: string | null
    budgetDetailId: string | null
    dimensionType: string | null
    dimensionValue: string | null
    recommendedPct: Decimal | null
    recommendedAmt: Decimal | null
    confidence: Decimal | null
    reasoning: string | null
    basedOnSeasons: number | null
    isApplied: boolean | null
    createdAt: Date | null
  }

  export type AllocationRecommendationCountAggregateOutputType = {
    id: number
    budgetDetailId: number
    dimensionType: number
    dimensionValue: number
    recommendedPct: number
    recommendedAmt: number
    confidence: number
    reasoning: number
    basedOnSeasons: number
    factors: number
    isApplied: number
    createdAt: number
    _all: number
  }


  export type AllocationRecommendationAvgAggregateInputType = {
    recommendedPct?: true
    recommendedAmt?: true
    confidence?: true
    basedOnSeasons?: true
  }

  export type AllocationRecommendationSumAggregateInputType = {
    recommendedPct?: true
    recommendedAmt?: true
    confidence?: true
    basedOnSeasons?: true
  }

  export type AllocationRecommendationMinAggregateInputType = {
    id?: true
    budgetDetailId?: true
    dimensionType?: true
    dimensionValue?: true
    recommendedPct?: true
    recommendedAmt?: true
    confidence?: true
    reasoning?: true
    basedOnSeasons?: true
    isApplied?: true
    createdAt?: true
  }

  export type AllocationRecommendationMaxAggregateInputType = {
    id?: true
    budgetDetailId?: true
    dimensionType?: true
    dimensionValue?: true
    recommendedPct?: true
    recommendedAmt?: true
    confidence?: true
    reasoning?: true
    basedOnSeasons?: true
    isApplied?: true
    createdAt?: true
  }

  export type AllocationRecommendationCountAggregateInputType = {
    id?: true
    budgetDetailId?: true
    dimensionType?: true
    dimensionValue?: true
    recommendedPct?: true
    recommendedAmt?: true
    confidence?: true
    reasoning?: true
    basedOnSeasons?: true
    factors?: true
    isApplied?: true
    createdAt?: true
    _all?: true
  }

  export type AllocationRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllocationRecommendation to aggregate.
     */
    where?: AllocationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationRecommendations to fetch.
     */
    orderBy?: AllocationRecommendationOrderByWithRelationInput | AllocationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllocationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AllocationRecommendations
    **/
    _count?: true | AllocationRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AllocationRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AllocationRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllocationRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllocationRecommendationMaxAggregateInputType
  }

  export type GetAllocationRecommendationAggregateType<T extends AllocationRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateAllocationRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllocationRecommendation[P]>
      : GetScalarType<T[P], AggregateAllocationRecommendation[P]>
  }




  export type AllocationRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllocationRecommendationWhereInput
    orderBy?: AllocationRecommendationOrderByWithAggregationInput | AllocationRecommendationOrderByWithAggregationInput[]
    by: AllocationRecommendationScalarFieldEnum[] | AllocationRecommendationScalarFieldEnum
    having?: AllocationRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllocationRecommendationCountAggregateInputType | true
    _avg?: AllocationRecommendationAvgAggregateInputType
    _sum?: AllocationRecommendationSumAggregateInputType
    _min?: AllocationRecommendationMinAggregateInputType
    _max?: AllocationRecommendationMaxAggregateInputType
  }

  export type AllocationRecommendationGroupByOutputType = {
    id: string
    budgetDetailId: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal
    recommendedAmt: Decimal
    confidence: Decimal
    reasoning: string | null
    basedOnSeasons: number
    factors: JsonValue | null
    isApplied: boolean
    createdAt: Date
    _count: AllocationRecommendationCountAggregateOutputType | null
    _avg: AllocationRecommendationAvgAggregateOutputType | null
    _sum: AllocationRecommendationSumAggregateOutputType | null
    _min: AllocationRecommendationMinAggregateOutputType | null
    _max: AllocationRecommendationMaxAggregateOutputType | null
  }

  type GetAllocationRecommendationGroupByPayload<T extends AllocationRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllocationRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllocationRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllocationRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], AllocationRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type AllocationRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetDetailId?: boolean
    dimensionType?: boolean
    dimensionValue?: boolean
    recommendedPct?: boolean
    recommendedAmt?: boolean
    confidence?: boolean
    reasoning?: boolean
    basedOnSeasons?: boolean
    factors?: boolean
    isApplied?: boolean
    createdAt?: boolean
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allocationRecommendation"]>

  export type AllocationRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetDetailId?: boolean
    dimensionType?: boolean
    dimensionValue?: boolean
    recommendedPct?: boolean
    recommendedAmt?: boolean
    confidence?: boolean
    reasoning?: boolean
    basedOnSeasons?: boolean
    factors?: boolean
    isApplied?: boolean
    createdAt?: boolean
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allocationRecommendation"]>

  export type AllocationRecommendationSelectScalar = {
    id?: boolean
    budgetDetailId?: boolean
    dimensionType?: boolean
    dimensionValue?: boolean
    recommendedPct?: boolean
    recommendedAmt?: boolean
    confidence?: boolean
    reasoning?: boolean
    basedOnSeasons?: boolean
    factors?: boolean
    isApplied?: boolean
    createdAt?: boolean
  }

  export type AllocationRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
  }
  export type AllocationRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
  }

  export type $AllocationRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AllocationRecommendation"
    objects: {
      budgetDetail: Prisma.$BudgetDetailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetDetailId: string
      dimensionType: string
      dimensionValue: string
      recommendedPct: Prisma.Decimal
      recommendedAmt: Prisma.Decimal
      confidence: Prisma.Decimal
      reasoning: string | null
      basedOnSeasons: number
      factors: Prisma.JsonValue | null
      isApplied: boolean
      createdAt: Date
    }, ExtArgs["result"]["allocationRecommendation"]>
    composites: {}
  }

  type AllocationRecommendationGetPayload<S extends boolean | null | undefined | AllocationRecommendationDefaultArgs> = $Result.GetResult<Prisma.$AllocationRecommendationPayload, S>

  type AllocationRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AllocationRecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AllocationRecommendationCountAggregateInputType | true
    }

  export interface AllocationRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AllocationRecommendation'], meta: { name: 'AllocationRecommendation' } }
    /**
     * Find zero or one AllocationRecommendation that matches the filter.
     * @param {AllocationRecommendationFindUniqueArgs} args - Arguments to find a AllocationRecommendation
     * @example
     * // Get one AllocationRecommendation
     * const allocationRecommendation = await prisma.allocationRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllocationRecommendationFindUniqueArgs>(args: SelectSubset<T, AllocationRecommendationFindUniqueArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AllocationRecommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AllocationRecommendationFindUniqueOrThrowArgs} args - Arguments to find a AllocationRecommendation
     * @example
     * // Get one AllocationRecommendation
     * const allocationRecommendation = await prisma.allocationRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllocationRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, AllocationRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AllocationRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationFindFirstArgs} args - Arguments to find a AllocationRecommendation
     * @example
     * // Get one AllocationRecommendation
     * const allocationRecommendation = await prisma.allocationRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllocationRecommendationFindFirstArgs>(args?: SelectSubset<T, AllocationRecommendationFindFirstArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AllocationRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationFindFirstOrThrowArgs} args - Arguments to find a AllocationRecommendation
     * @example
     * // Get one AllocationRecommendation
     * const allocationRecommendation = await prisma.allocationRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllocationRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, AllocationRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AllocationRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AllocationRecommendations
     * const allocationRecommendations = await prisma.allocationRecommendation.findMany()
     * 
     * // Get first 10 AllocationRecommendations
     * const allocationRecommendations = await prisma.allocationRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allocationRecommendationWithIdOnly = await prisma.allocationRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllocationRecommendationFindManyArgs>(args?: SelectSubset<T, AllocationRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AllocationRecommendation.
     * @param {AllocationRecommendationCreateArgs} args - Arguments to create a AllocationRecommendation.
     * @example
     * // Create one AllocationRecommendation
     * const AllocationRecommendation = await prisma.allocationRecommendation.create({
     *   data: {
     *     // ... data to create a AllocationRecommendation
     *   }
     * })
     * 
     */
    create<T extends AllocationRecommendationCreateArgs>(args: SelectSubset<T, AllocationRecommendationCreateArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AllocationRecommendations.
     * @param {AllocationRecommendationCreateManyArgs} args - Arguments to create many AllocationRecommendations.
     * @example
     * // Create many AllocationRecommendations
     * const allocationRecommendation = await prisma.allocationRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllocationRecommendationCreateManyArgs>(args?: SelectSubset<T, AllocationRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AllocationRecommendations and returns the data saved in the database.
     * @param {AllocationRecommendationCreateManyAndReturnArgs} args - Arguments to create many AllocationRecommendations.
     * @example
     * // Create many AllocationRecommendations
     * const allocationRecommendation = await prisma.allocationRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AllocationRecommendations and only return the `id`
     * const allocationRecommendationWithIdOnly = await prisma.allocationRecommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllocationRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, AllocationRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AllocationRecommendation.
     * @param {AllocationRecommendationDeleteArgs} args - Arguments to delete one AllocationRecommendation.
     * @example
     * // Delete one AllocationRecommendation
     * const AllocationRecommendation = await prisma.allocationRecommendation.delete({
     *   where: {
     *     // ... filter to delete one AllocationRecommendation
     *   }
     * })
     * 
     */
    delete<T extends AllocationRecommendationDeleteArgs>(args: SelectSubset<T, AllocationRecommendationDeleteArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AllocationRecommendation.
     * @param {AllocationRecommendationUpdateArgs} args - Arguments to update one AllocationRecommendation.
     * @example
     * // Update one AllocationRecommendation
     * const allocationRecommendation = await prisma.allocationRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllocationRecommendationUpdateArgs>(args: SelectSubset<T, AllocationRecommendationUpdateArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AllocationRecommendations.
     * @param {AllocationRecommendationDeleteManyArgs} args - Arguments to filter AllocationRecommendations to delete.
     * @example
     * // Delete a few AllocationRecommendations
     * const { count } = await prisma.allocationRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllocationRecommendationDeleteManyArgs>(args?: SelectSubset<T, AllocationRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AllocationRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AllocationRecommendations
     * const allocationRecommendation = await prisma.allocationRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllocationRecommendationUpdateManyArgs>(args: SelectSubset<T, AllocationRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AllocationRecommendation.
     * @param {AllocationRecommendationUpsertArgs} args - Arguments to update or create a AllocationRecommendation.
     * @example
     * // Update or create a AllocationRecommendation
     * const allocationRecommendation = await prisma.allocationRecommendation.upsert({
     *   create: {
     *     // ... data to create a AllocationRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AllocationRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends AllocationRecommendationUpsertArgs>(args: SelectSubset<T, AllocationRecommendationUpsertArgs<ExtArgs>>): Prisma__AllocationRecommendationClient<$Result.GetResult<Prisma.$AllocationRecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AllocationRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationCountArgs} args - Arguments to filter AllocationRecommendations to count.
     * @example
     * // Count the number of AllocationRecommendations
     * const count = await prisma.allocationRecommendation.count({
     *   where: {
     *     // ... the filter for the AllocationRecommendations we want to count
     *   }
     * })
    **/
    count<T extends AllocationRecommendationCountArgs>(
      args?: Subset<T, AllocationRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllocationRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AllocationRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllocationRecommendationAggregateArgs>(args: Subset<T, AllocationRecommendationAggregateArgs>): Prisma.PrismaPromise<GetAllocationRecommendationAggregateType<T>>

    /**
     * Group by AllocationRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllocationRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllocationRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllocationRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: AllocationRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllocationRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllocationRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AllocationRecommendation model
   */
  readonly fields: AllocationRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AllocationRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllocationRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budgetDetail<T extends BudgetDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDetailDefaultArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AllocationRecommendation model
   */ 
  interface AllocationRecommendationFieldRefs {
    readonly id: FieldRef<"AllocationRecommendation", 'String'>
    readonly budgetDetailId: FieldRef<"AllocationRecommendation", 'String'>
    readonly dimensionType: FieldRef<"AllocationRecommendation", 'String'>
    readonly dimensionValue: FieldRef<"AllocationRecommendation", 'String'>
    readonly recommendedPct: FieldRef<"AllocationRecommendation", 'Decimal'>
    readonly recommendedAmt: FieldRef<"AllocationRecommendation", 'Decimal'>
    readonly confidence: FieldRef<"AllocationRecommendation", 'Decimal'>
    readonly reasoning: FieldRef<"AllocationRecommendation", 'String'>
    readonly basedOnSeasons: FieldRef<"AllocationRecommendation", 'Int'>
    readonly factors: FieldRef<"AllocationRecommendation", 'Json'>
    readonly isApplied: FieldRef<"AllocationRecommendation", 'Boolean'>
    readonly createdAt: FieldRef<"AllocationRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AllocationRecommendation findUnique
   */
  export type AllocationRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AllocationRecommendation to fetch.
     */
    where: AllocationRecommendationWhereUniqueInput
  }

  /**
   * AllocationRecommendation findUniqueOrThrow
   */
  export type AllocationRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AllocationRecommendation to fetch.
     */
    where: AllocationRecommendationWhereUniqueInput
  }

  /**
   * AllocationRecommendation findFirst
   */
  export type AllocationRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AllocationRecommendation to fetch.
     */
    where?: AllocationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationRecommendations to fetch.
     */
    orderBy?: AllocationRecommendationOrderByWithRelationInput | AllocationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllocationRecommendations.
     */
    cursor?: AllocationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllocationRecommendations.
     */
    distinct?: AllocationRecommendationScalarFieldEnum | AllocationRecommendationScalarFieldEnum[]
  }

  /**
   * AllocationRecommendation findFirstOrThrow
   */
  export type AllocationRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AllocationRecommendation to fetch.
     */
    where?: AllocationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationRecommendations to fetch.
     */
    orderBy?: AllocationRecommendationOrderByWithRelationInput | AllocationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AllocationRecommendations.
     */
    cursor?: AllocationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AllocationRecommendations.
     */
    distinct?: AllocationRecommendationScalarFieldEnum | AllocationRecommendationScalarFieldEnum[]
  }

  /**
   * AllocationRecommendation findMany
   */
  export type AllocationRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which AllocationRecommendations to fetch.
     */
    where?: AllocationRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AllocationRecommendations to fetch.
     */
    orderBy?: AllocationRecommendationOrderByWithRelationInput | AllocationRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AllocationRecommendations.
     */
    cursor?: AllocationRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AllocationRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AllocationRecommendations.
     */
    skip?: number
    distinct?: AllocationRecommendationScalarFieldEnum | AllocationRecommendationScalarFieldEnum[]
  }

  /**
   * AllocationRecommendation create
   */
  export type AllocationRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a AllocationRecommendation.
     */
    data: XOR<AllocationRecommendationCreateInput, AllocationRecommendationUncheckedCreateInput>
  }

  /**
   * AllocationRecommendation createMany
   */
  export type AllocationRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AllocationRecommendations.
     */
    data: AllocationRecommendationCreateManyInput | AllocationRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AllocationRecommendation createManyAndReturn
   */
  export type AllocationRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AllocationRecommendations.
     */
    data: AllocationRecommendationCreateManyInput | AllocationRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AllocationRecommendation update
   */
  export type AllocationRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a AllocationRecommendation.
     */
    data: XOR<AllocationRecommendationUpdateInput, AllocationRecommendationUncheckedUpdateInput>
    /**
     * Choose, which AllocationRecommendation to update.
     */
    where: AllocationRecommendationWhereUniqueInput
  }

  /**
   * AllocationRecommendation updateMany
   */
  export type AllocationRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AllocationRecommendations.
     */
    data: XOR<AllocationRecommendationUpdateManyMutationInput, AllocationRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which AllocationRecommendations to update
     */
    where?: AllocationRecommendationWhereInput
  }

  /**
   * AllocationRecommendation upsert
   */
  export type AllocationRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the AllocationRecommendation to update in case it exists.
     */
    where: AllocationRecommendationWhereUniqueInput
    /**
     * In case the AllocationRecommendation found by the `where` argument doesn't exist, create a new AllocationRecommendation with this data.
     */
    create: XOR<AllocationRecommendationCreateInput, AllocationRecommendationUncheckedCreateInput>
    /**
     * In case the AllocationRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllocationRecommendationUpdateInput, AllocationRecommendationUncheckedUpdateInput>
  }

  /**
   * AllocationRecommendation delete
   */
  export type AllocationRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
    /**
     * Filter which AllocationRecommendation to delete.
     */
    where: AllocationRecommendationWhereUniqueInput
  }

  /**
   * AllocationRecommendation deleteMany
   */
  export type AllocationRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AllocationRecommendations to delete
     */
    where?: AllocationRecommendationWhereInput
  }

  /**
   * AllocationRecommendation without action
   */
  export type AllocationRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllocationRecommendation
     */
    select?: AllocationRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllocationRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model RiskAssessment
   */

  export type AggregateRiskAssessment = {
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  export type RiskAssessmentAvgAggregateOutputType = {
    overallScore: Decimal | null
    budgetAlignmentScore: Decimal | null
    skuDiversityScore: Decimal | null
    sizeCurveScore: Decimal | null
    vendorConcentrationScore: Decimal | null
    categoryBalanceScore: Decimal | null
    marginImpactScore: Decimal | null
  }

  export type RiskAssessmentSumAggregateOutputType = {
    overallScore: Decimal | null
    budgetAlignmentScore: Decimal | null
    skuDiversityScore: Decimal | null
    sizeCurveScore: Decimal | null
    vendorConcentrationScore: Decimal | null
    categoryBalanceScore: Decimal | null
    marginImpactScore: Decimal | null
  }

  export type RiskAssessmentMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    overallScore: Decimal | null
    riskLevel: string | null
    budgetAlignmentScore: Decimal | null
    skuDiversityScore: Decimal | null
    sizeCurveScore: Decimal | null
    vendorConcentrationScore: Decimal | null
    categoryBalanceScore: Decimal | null
    marginImpactScore: Decimal | null
    recommendation: string | null
    calculatedAt: Date | null
    calculatedBy: string | null
    isStale: boolean | null
  }

  export type RiskAssessmentMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    entityId: string | null
    overallScore: Decimal | null
    riskLevel: string | null
    budgetAlignmentScore: Decimal | null
    skuDiversityScore: Decimal | null
    sizeCurveScore: Decimal | null
    vendorConcentrationScore: Decimal | null
    categoryBalanceScore: Decimal | null
    marginImpactScore: Decimal | null
    recommendation: string | null
    calculatedAt: Date | null
    calculatedBy: string | null
    isStale: boolean | null
  }

  export type RiskAssessmentCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    overallScore: number
    riskLevel: number
    budgetAlignmentScore: number
    skuDiversityScore: number
    sizeCurveScore: number
    vendorConcentrationScore: number
    categoryBalanceScore: number
    marginImpactScore: number
    factors: number
    warnings: number
    recommendation: number
    calculatedAt: number
    calculatedBy: number
    isStale: number
    _all: number
  }


  export type RiskAssessmentAvgAggregateInputType = {
    overallScore?: true
    budgetAlignmentScore?: true
    skuDiversityScore?: true
    sizeCurveScore?: true
    vendorConcentrationScore?: true
    categoryBalanceScore?: true
    marginImpactScore?: true
  }

  export type RiskAssessmentSumAggregateInputType = {
    overallScore?: true
    budgetAlignmentScore?: true
    skuDiversityScore?: true
    sizeCurveScore?: true
    vendorConcentrationScore?: true
    categoryBalanceScore?: true
    marginImpactScore?: true
  }

  export type RiskAssessmentMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    overallScore?: true
    riskLevel?: true
    budgetAlignmentScore?: true
    skuDiversityScore?: true
    sizeCurveScore?: true
    vendorConcentrationScore?: true
    categoryBalanceScore?: true
    marginImpactScore?: true
    recommendation?: true
    calculatedAt?: true
    calculatedBy?: true
    isStale?: true
  }

  export type RiskAssessmentMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    overallScore?: true
    riskLevel?: true
    budgetAlignmentScore?: true
    skuDiversityScore?: true
    sizeCurveScore?: true
    vendorConcentrationScore?: true
    categoryBalanceScore?: true
    marginImpactScore?: true
    recommendation?: true
    calculatedAt?: true
    calculatedBy?: true
    isStale?: true
  }

  export type RiskAssessmentCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    overallScore?: true
    riskLevel?: true
    budgetAlignmentScore?: true
    skuDiversityScore?: true
    sizeCurveScore?: true
    vendorConcentrationScore?: true
    categoryBalanceScore?: true
    marginImpactScore?: true
    factors?: true
    warnings?: true
    recommendation?: true
    calculatedAt?: true
    calculatedBy?: true
    isStale?: true
    _all?: true
  }

  export type RiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessment to aggregate.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAssessments
    **/
    _count?: true | RiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type GetRiskAssessmentAggregateType<T extends RiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAssessment[P]>
      : GetScalarType<T[P], AggregateRiskAssessment[P]>
  }




  export type RiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithAggregationInput | RiskAssessmentOrderByWithAggregationInput[]
    by: RiskAssessmentScalarFieldEnum[] | RiskAssessmentScalarFieldEnum
    having?: RiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAssessmentCountAggregateInputType | true
    _avg?: RiskAssessmentAvgAggregateInputType
    _sum?: RiskAssessmentSumAggregateInputType
    _min?: RiskAssessmentMinAggregateInputType
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type RiskAssessmentGroupByOutputType = {
    id: string
    entityType: string
    entityId: string
    overallScore: Decimal
    riskLevel: string
    budgetAlignmentScore: Decimal
    skuDiversityScore: Decimal
    sizeCurveScore: Decimal
    vendorConcentrationScore: Decimal
    categoryBalanceScore: Decimal
    marginImpactScore: Decimal
    factors: JsonValue | null
    warnings: JsonValue | null
    recommendation: string | null
    calculatedAt: Date
    calculatedBy: string | null
    isStale: boolean
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  type GetRiskAssessmentGroupByPayload<T extends RiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type RiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    budgetAlignmentScore?: boolean
    skuDiversityScore?: boolean
    sizeCurveScore?: boolean
    vendorConcentrationScore?: boolean
    categoryBalanceScore?: boolean
    marginImpactScore?: boolean
    factors?: boolean
    warnings?: boolean
    recommendation?: boolean
    calculatedAt?: boolean
    calculatedBy?: boolean
    isStale?: boolean
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    budgetAlignmentScore?: boolean
    skuDiversityScore?: boolean
    sizeCurveScore?: boolean
    vendorConcentrationScore?: boolean
    categoryBalanceScore?: boolean
    marginImpactScore?: boolean
    factors?: boolean
    warnings?: boolean
    recommendation?: boolean
    calculatedAt?: boolean
    calculatedBy?: boolean
    isStale?: boolean
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    budgetAlignmentScore?: boolean
    skuDiversityScore?: boolean
    sizeCurveScore?: boolean
    vendorConcentrationScore?: boolean
    categoryBalanceScore?: boolean
    marginImpactScore?: boolean
    factors?: boolean
    warnings?: boolean
    recommendation?: boolean
    calculatedAt?: boolean
    calculatedBy?: boolean
    isStale?: boolean
  }


  export type $RiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAssessment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      entityId: string
      overallScore: Prisma.Decimal
      riskLevel: string
      budgetAlignmentScore: Prisma.Decimal
      skuDiversityScore: Prisma.Decimal
      sizeCurveScore: Prisma.Decimal
      vendorConcentrationScore: Prisma.Decimal
      categoryBalanceScore: Prisma.Decimal
      marginImpactScore: Prisma.Decimal
      factors: Prisma.JsonValue | null
      warnings: Prisma.JsonValue | null
      recommendation: string | null
      calculatedAt: Date
      calculatedBy: string | null
      isStale: boolean
    }, ExtArgs["result"]["riskAssessment"]>
    composites: {}
  }

  type RiskAssessmentGetPayload<S extends boolean | null | undefined | RiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$RiskAssessmentPayload, S>

  type RiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskAssessmentCountAggregateInputType | true
    }

  export interface RiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAssessment'], meta: { name: 'RiskAssessment' } }
    /**
     * Find zero or one RiskAssessment that matches the filter.
     * @param {RiskAssessmentFindUniqueArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAssessmentFindUniqueArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAssessmentFindFirstArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany()
     * 
     * // Get first 10 RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAssessmentFindManyArgs>(args?: SelectSubset<T, RiskAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskAssessment.
     * @param {RiskAssessmentCreateArgs} args - Arguments to create a RiskAssessment.
     * @example
     * // Create one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.create({
     *   data: {
     *     // ... data to create a RiskAssessment
     *   }
     * })
     * 
     */
    create<T extends RiskAssessmentCreateArgs>(args: SelectSubset<T, RiskAssessmentCreateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskAssessments.
     * @param {RiskAssessmentCreateManyArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAssessmentCreateManyArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAssessments and returns the data saved in the database.
     * @param {RiskAssessmentCreateManyAndReturnArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAssessments and only return the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskAssessment.
     * @param {RiskAssessmentDeleteArgs} args - Arguments to delete one RiskAssessment.
     * @example
     * // Delete one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.delete({
     *   where: {
     *     // ... filter to delete one RiskAssessment
     *   }
     * })
     * 
     */
    delete<T extends RiskAssessmentDeleteArgs>(args: SelectSubset<T, RiskAssessmentDeleteArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskAssessment.
     * @param {RiskAssessmentUpdateArgs} args - Arguments to update one RiskAssessment.
     * @example
     * // Update one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAssessmentUpdateArgs>(args: SelectSubset<T, RiskAssessmentUpdateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskAssessments.
     * @param {RiskAssessmentDeleteManyArgs} args - Arguments to filter RiskAssessments to delete.
     * @example
     * // Delete a few RiskAssessments
     * const { count } = await prisma.riskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAssessmentDeleteManyArgs>(args?: SelectSubset<T, RiskAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAssessmentUpdateManyArgs>(args: SelectSubset<T, RiskAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskAssessment.
     * @param {RiskAssessmentUpsertArgs} args - Arguments to update or create a RiskAssessment.
     * @example
     * // Update or create a RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.upsert({
     *   create: {
     *     // ... data to create a RiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAssessment we want to update
     *   }
     * })
     */
    upsert<T extends RiskAssessmentUpsertArgs>(args: SelectSubset<T, RiskAssessmentUpsertArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentCountArgs} args - Arguments to filter RiskAssessments to count.
     * @example
     * // Count the number of RiskAssessments
     * const count = await prisma.riskAssessment.count({
     *   where: {
     *     // ... the filter for the RiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends RiskAssessmentCountArgs>(
      args?: Subset<T, RiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAssessmentAggregateArgs>(args: Subset<T, RiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetRiskAssessmentAggregateType<T>>

    /**
     * Group by RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: RiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAssessment model
   */
  readonly fields: RiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAssessment model
   */ 
  interface RiskAssessmentFieldRefs {
    readonly id: FieldRef<"RiskAssessment", 'String'>
    readonly entityType: FieldRef<"RiskAssessment", 'String'>
    readonly entityId: FieldRef<"RiskAssessment", 'String'>
    readonly overallScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly riskLevel: FieldRef<"RiskAssessment", 'String'>
    readonly budgetAlignmentScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly skuDiversityScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly sizeCurveScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly vendorConcentrationScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly categoryBalanceScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly marginImpactScore: FieldRef<"RiskAssessment", 'Decimal'>
    readonly factors: FieldRef<"RiskAssessment", 'Json'>
    readonly warnings: FieldRef<"RiskAssessment", 'Json'>
    readonly recommendation: FieldRef<"RiskAssessment", 'String'>
    readonly calculatedAt: FieldRef<"RiskAssessment", 'DateTime'>
    readonly calculatedBy: FieldRef<"RiskAssessment", 'String'>
    readonly isStale: FieldRef<"RiskAssessment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RiskAssessment findUnique
   */
  export type RiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findUniqueOrThrow
   */
  export type RiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findFirst
   */
  export type RiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findFirstOrThrow
   */
  export type RiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findMany
   */
  export type RiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessments to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment create
   */
  export type RiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * The data needed to create a RiskAssessment.
     */
    data: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
  }

  /**
   * RiskAssessment createMany
   */
  export type RiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment createManyAndReturn
   */
  export type RiskAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment update
   */
  export type RiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * The data needed to update a RiskAssessment.
     */
    data: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which RiskAssessment to update.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment updateMany
   */
  export type RiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAssessments.
     */
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which RiskAssessments to update
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment upsert
   */
  export type RiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * The filter to search for the RiskAssessment to update in case it exists.
     */
    where: RiskAssessmentWhereUniqueInput
    /**
     * In case the RiskAssessment found by the `where` argument doesn't exist, create a new RiskAssessment with this data.
     */
    create: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
    /**
     * In case the RiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
  }

  /**
   * RiskAssessment delete
   */
  export type RiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter which RiskAssessment to delete.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment deleteMany
   */
  export type RiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessments to delete
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment without action
   */
  export type RiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
  }


  /**
   * Model RiskThreshold
   */

  export type AggregateRiskThreshold = {
    _count: RiskThresholdCountAggregateOutputType | null
    _avg: RiskThresholdAvgAggregateOutputType | null
    _sum: RiskThresholdSumAggregateOutputType | null
    _min: RiskThresholdMinAggregateOutputType | null
    _max: RiskThresholdMaxAggregateOutputType | null
  }

  export type RiskThresholdAvgAggregateOutputType = {
    weight: Decimal | null
    lowThreshold: Decimal | null
    highThreshold: Decimal | null
  }

  export type RiskThresholdSumAggregateOutputType = {
    weight: Decimal | null
    lowThreshold: Decimal | null
    highThreshold: Decimal | null
  }

  export type RiskThresholdMinAggregateOutputType = {
    id: string | null
    factorName: string | null
    weight: Decimal | null
    lowThreshold: Decimal | null
    highThreshold: Decimal | null
    description: string | null
    isActive: boolean | null
  }

  export type RiskThresholdMaxAggregateOutputType = {
    id: string | null
    factorName: string | null
    weight: Decimal | null
    lowThreshold: Decimal | null
    highThreshold: Decimal | null
    description: string | null
    isActive: boolean | null
  }

  export type RiskThresholdCountAggregateOutputType = {
    id: number
    factorName: number
    weight: number
    lowThreshold: number
    highThreshold: number
    description: number
    isActive: number
    _all: number
  }


  export type RiskThresholdAvgAggregateInputType = {
    weight?: true
    lowThreshold?: true
    highThreshold?: true
  }

  export type RiskThresholdSumAggregateInputType = {
    weight?: true
    lowThreshold?: true
    highThreshold?: true
  }

  export type RiskThresholdMinAggregateInputType = {
    id?: true
    factorName?: true
    weight?: true
    lowThreshold?: true
    highThreshold?: true
    description?: true
    isActive?: true
  }

  export type RiskThresholdMaxAggregateInputType = {
    id?: true
    factorName?: true
    weight?: true
    lowThreshold?: true
    highThreshold?: true
    description?: true
    isActive?: true
  }

  export type RiskThresholdCountAggregateInputType = {
    id?: true
    factorName?: true
    weight?: true
    lowThreshold?: true
    highThreshold?: true
    description?: true
    isActive?: true
    _all?: true
  }

  export type RiskThresholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskThreshold to aggregate.
     */
    where?: RiskThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskThresholds to fetch.
     */
    orderBy?: RiskThresholdOrderByWithRelationInput | RiskThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskThresholds
    **/
    _count?: true | RiskThresholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskThresholdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskThresholdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskThresholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskThresholdMaxAggregateInputType
  }

  export type GetRiskThresholdAggregateType<T extends RiskThresholdAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskThreshold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskThreshold[P]>
      : GetScalarType<T[P], AggregateRiskThreshold[P]>
  }




  export type RiskThresholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskThresholdWhereInput
    orderBy?: RiskThresholdOrderByWithAggregationInput | RiskThresholdOrderByWithAggregationInput[]
    by: RiskThresholdScalarFieldEnum[] | RiskThresholdScalarFieldEnum
    having?: RiskThresholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskThresholdCountAggregateInputType | true
    _avg?: RiskThresholdAvgAggregateInputType
    _sum?: RiskThresholdSumAggregateInputType
    _min?: RiskThresholdMinAggregateInputType
    _max?: RiskThresholdMaxAggregateInputType
  }

  export type RiskThresholdGroupByOutputType = {
    id: string
    factorName: string
    weight: Decimal
    lowThreshold: Decimal
    highThreshold: Decimal
    description: string | null
    isActive: boolean
    _count: RiskThresholdCountAggregateOutputType | null
    _avg: RiskThresholdAvgAggregateOutputType | null
    _sum: RiskThresholdSumAggregateOutputType | null
    _min: RiskThresholdMinAggregateOutputType | null
    _max: RiskThresholdMaxAggregateOutputType | null
  }

  type GetRiskThresholdGroupByPayload<T extends RiskThresholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskThresholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskThresholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskThresholdGroupByOutputType[P]>
            : GetScalarType<T[P], RiskThresholdGroupByOutputType[P]>
        }
      >
    >


  export type RiskThresholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factorName?: boolean
    weight?: boolean
    lowThreshold?: boolean
    highThreshold?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["riskThreshold"]>

  export type RiskThresholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factorName?: boolean
    weight?: boolean
    lowThreshold?: boolean
    highThreshold?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["riskThreshold"]>

  export type RiskThresholdSelectScalar = {
    id?: boolean
    factorName?: boolean
    weight?: boolean
    lowThreshold?: boolean
    highThreshold?: boolean
    description?: boolean
    isActive?: boolean
  }


  export type $RiskThresholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskThreshold"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      factorName: string
      weight: Prisma.Decimal
      lowThreshold: Prisma.Decimal
      highThreshold: Prisma.Decimal
      description: string | null
      isActive: boolean
    }, ExtArgs["result"]["riskThreshold"]>
    composites: {}
  }

  type RiskThresholdGetPayload<S extends boolean | null | undefined | RiskThresholdDefaultArgs> = $Result.GetResult<Prisma.$RiskThresholdPayload, S>

  type RiskThresholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskThresholdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskThresholdCountAggregateInputType | true
    }

  export interface RiskThresholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskThreshold'], meta: { name: 'RiskThreshold' } }
    /**
     * Find zero or one RiskThreshold that matches the filter.
     * @param {RiskThresholdFindUniqueArgs} args - Arguments to find a RiskThreshold
     * @example
     * // Get one RiskThreshold
     * const riskThreshold = await prisma.riskThreshold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskThresholdFindUniqueArgs>(args: SelectSubset<T, RiskThresholdFindUniqueArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskThreshold that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskThresholdFindUniqueOrThrowArgs} args - Arguments to find a RiskThreshold
     * @example
     * // Get one RiskThreshold
     * const riskThreshold = await prisma.riskThreshold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskThresholdFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskThresholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskThreshold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdFindFirstArgs} args - Arguments to find a RiskThreshold
     * @example
     * // Get one RiskThreshold
     * const riskThreshold = await prisma.riskThreshold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskThresholdFindFirstArgs>(args?: SelectSubset<T, RiskThresholdFindFirstArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskThreshold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdFindFirstOrThrowArgs} args - Arguments to find a RiskThreshold
     * @example
     * // Get one RiskThreshold
     * const riskThreshold = await prisma.riskThreshold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskThresholdFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskThresholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskThresholds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskThresholds
     * const riskThresholds = await prisma.riskThreshold.findMany()
     * 
     * // Get first 10 RiskThresholds
     * const riskThresholds = await prisma.riskThreshold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskThresholdWithIdOnly = await prisma.riskThreshold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskThresholdFindManyArgs>(args?: SelectSubset<T, RiskThresholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskThreshold.
     * @param {RiskThresholdCreateArgs} args - Arguments to create a RiskThreshold.
     * @example
     * // Create one RiskThreshold
     * const RiskThreshold = await prisma.riskThreshold.create({
     *   data: {
     *     // ... data to create a RiskThreshold
     *   }
     * })
     * 
     */
    create<T extends RiskThresholdCreateArgs>(args: SelectSubset<T, RiskThresholdCreateArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskThresholds.
     * @param {RiskThresholdCreateManyArgs} args - Arguments to create many RiskThresholds.
     * @example
     * // Create many RiskThresholds
     * const riskThreshold = await prisma.riskThreshold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskThresholdCreateManyArgs>(args?: SelectSubset<T, RiskThresholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskThresholds and returns the data saved in the database.
     * @param {RiskThresholdCreateManyAndReturnArgs} args - Arguments to create many RiskThresholds.
     * @example
     * // Create many RiskThresholds
     * const riskThreshold = await prisma.riskThreshold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskThresholds and only return the `id`
     * const riskThresholdWithIdOnly = await prisma.riskThreshold.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskThresholdCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskThresholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskThreshold.
     * @param {RiskThresholdDeleteArgs} args - Arguments to delete one RiskThreshold.
     * @example
     * // Delete one RiskThreshold
     * const RiskThreshold = await prisma.riskThreshold.delete({
     *   where: {
     *     // ... filter to delete one RiskThreshold
     *   }
     * })
     * 
     */
    delete<T extends RiskThresholdDeleteArgs>(args: SelectSubset<T, RiskThresholdDeleteArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskThreshold.
     * @param {RiskThresholdUpdateArgs} args - Arguments to update one RiskThreshold.
     * @example
     * // Update one RiskThreshold
     * const riskThreshold = await prisma.riskThreshold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskThresholdUpdateArgs>(args: SelectSubset<T, RiskThresholdUpdateArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskThresholds.
     * @param {RiskThresholdDeleteManyArgs} args - Arguments to filter RiskThresholds to delete.
     * @example
     * // Delete a few RiskThresholds
     * const { count } = await prisma.riskThreshold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskThresholdDeleteManyArgs>(args?: SelectSubset<T, RiskThresholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskThresholds
     * const riskThreshold = await prisma.riskThreshold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskThresholdUpdateManyArgs>(args: SelectSubset<T, RiskThresholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskThreshold.
     * @param {RiskThresholdUpsertArgs} args - Arguments to update or create a RiskThreshold.
     * @example
     * // Update or create a RiskThreshold
     * const riskThreshold = await prisma.riskThreshold.upsert({
     *   create: {
     *     // ... data to create a RiskThreshold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskThreshold we want to update
     *   }
     * })
     */
    upsert<T extends RiskThresholdUpsertArgs>(args: SelectSubset<T, RiskThresholdUpsertArgs<ExtArgs>>): Prisma__RiskThresholdClient<$Result.GetResult<Prisma.$RiskThresholdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdCountArgs} args - Arguments to filter RiskThresholds to count.
     * @example
     * // Count the number of RiskThresholds
     * const count = await prisma.riskThreshold.count({
     *   where: {
     *     // ... the filter for the RiskThresholds we want to count
     *   }
     * })
    **/
    count<T extends RiskThresholdCountArgs>(
      args?: Subset<T, RiskThresholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskThresholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskThresholdAggregateArgs>(args: Subset<T, RiskThresholdAggregateArgs>): Prisma.PrismaPromise<GetRiskThresholdAggregateType<T>>

    /**
     * Group by RiskThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskThresholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskThresholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskThresholdGroupByArgs['orderBy'] }
        : { orderBy?: RiskThresholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskThresholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskThresholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskThreshold model
   */
  readonly fields: RiskThresholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskThreshold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskThresholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskThreshold model
   */ 
  interface RiskThresholdFieldRefs {
    readonly id: FieldRef<"RiskThreshold", 'String'>
    readonly factorName: FieldRef<"RiskThreshold", 'String'>
    readonly weight: FieldRef<"RiskThreshold", 'Decimal'>
    readonly lowThreshold: FieldRef<"RiskThreshold", 'Decimal'>
    readonly highThreshold: FieldRef<"RiskThreshold", 'Decimal'>
    readonly description: FieldRef<"RiskThreshold", 'String'>
    readonly isActive: FieldRef<"RiskThreshold", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RiskThreshold findUnique
   */
  export type RiskThresholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * Filter, which RiskThreshold to fetch.
     */
    where: RiskThresholdWhereUniqueInput
  }

  /**
   * RiskThreshold findUniqueOrThrow
   */
  export type RiskThresholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * Filter, which RiskThreshold to fetch.
     */
    where: RiskThresholdWhereUniqueInput
  }

  /**
   * RiskThreshold findFirst
   */
  export type RiskThresholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * Filter, which RiskThreshold to fetch.
     */
    where?: RiskThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskThresholds to fetch.
     */
    orderBy?: RiskThresholdOrderByWithRelationInput | RiskThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskThresholds.
     */
    cursor?: RiskThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskThresholds.
     */
    distinct?: RiskThresholdScalarFieldEnum | RiskThresholdScalarFieldEnum[]
  }

  /**
   * RiskThreshold findFirstOrThrow
   */
  export type RiskThresholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * Filter, which RiskThreshold to fetch.
     */
    where?: RiskThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskThresholds to fetch.
     */
    orderBy?: RiskThresholdOrderByWithRelationInput | RiskThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskThresholds.
     */
    cursor?: RiskThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskThresholds.
     */
    distinct?: RiskThresholdScalarFieldEnum | RiskThresholdScalarFieldEnum[]
  }

  /**
   * RiskThreshold findMany
   */
  export type RiskThresholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * Filter, which RiskThresholds to fetch.
     */
    where?: RiskThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskThresholds to fetch.
     */
    orderBy?: RiskThresholdOrderByWithRelationInput | RiskThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskThresholds.
     */
    cursor?: RiskThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskThresholds.
     */
    skip?: number
    distinct?: RiskThresholdScalarFieldEnum | RiskThresholdScalarFieldEnum[]
  }

  /**
   * RiskThreshold create
   */
  export type RiskThresholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * The data needed to create a RiskThreshold.
     */
    data: XOR<RiskThresholdCreateInput, RiskThresholdUncheckedCreateInput>
  }

  /**
   * RiskThreshold createMany
   */
  export type RiskThresholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskThresholds.
     */
    data: RiskThresholdCreateManyInput | RiskThresholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskThreshold createManyAndReturn
   */
  export type RiskThresholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskThresholds.
     */
    data: RiskThresholdCreateManyInput | RiskThresholdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskThreshold update
   */
  export type RiskThresholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * The data needed to update a RiskThreshold.
     */
    data: XOR<RiskThresholdUpdateInput, RiskThresholdUncheckedUpdateInput>
    /**
     * Choose, which RiskThreshold to update.
     */
    where: RiskThresholdWhereUniqueInput
  }

  /**
   * RiskThreshold updateMany
   */
  export type RiskThresholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskThresholds.
     */
    data: XOR<RiskThresholdUpdateManyMutationInput, RiskThresholdUncheckedUpdateManyInput>
    /**
     * Filter which RiskThresholds to update
     */
    where?: RiskThresholdWhereInput
  }

  /**
   * RiskThreshold upsert
   */
  export type RiskThresholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * The filter to search for the RiskThreshold to update in case it exists.
     */
    where: RiskThresholdWhereUniqueInput
    /**
     * In case the RiskThreshold found by the `where` argument doesn't exist, create a new RiskThreshold with this data.
     */
    create: XOR<RiskThresholdCreateInput, RiskThresholdUncheckedCreateInput>
    /**
     * In case the RiskThreshold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskThresholdUpdateInput, RiskThresholdUncheckedUpdateInput>
  }

  /**
   * RiskThreshold delete
   */
  export type RiskThresholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
    /**
     * Filter which RiskThreshold to delete.
     */
    where: RiskThresholdWhereUniqueInput
  }

  /**
   * RiskThreshold deleteMany
   */
  export type RiskThresholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskThresholds to delete
     */
    where?: RiskThresholdWhereInput
  }

  /**
   * RiskThreshold without action
   */
  export type RiskThresholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskThreshold
     */
    select?: RiskThresholdSelect<ExtArgs> | null
  }


  /**
   * Model SkuPerformance
   */

  export type AggregateSkuPerformance = {
    _count: SkuPerformanceCountAggregateOutputType | null
    _avg: SkuPerformanceAvgAggregateOutputType | null
    _sum: SkuPerformanceSumAggregateOutputType | null
    _min: SkuPerformanceMinAggregateOutputType | null
    _max: SkuPerformanceMaxAggregateOutputType | null
  }

  export type SkuPerformanceAvgAggregateOutputType = {
    fiscalYear: number | null
    quantityBought: number | null
    quantitySold: number | null
    sellThroughPct: Decimal | null
    avgSellingPrice: Decimal | null
    totalRevenue: Decimal | null
    grossMarginPct: Decimal | null
    markdownPct: Decimal | null
    weeksToSellThru: number | null
    performanceScore: number | null
    velocityScore: number | null
    marginScore: number | null
  }

  export type SkuPerformanceSumAggregateOutputType = {
    fiscalYear: number | null
    quantityBought: number | null
    quantitySold: number | null
    sellThroughPct: Decimal | null
    avgSellingPrice: Decimal | null
    totalRevenue: Decimal | null
    grossMarginPct: Decimal | null
    markdownPct: Decimal | null
    weeksToSellThru: number | null
    performanceScore: number | null
    velocityScore: number | null
    marginScore: number | null
  }

  export type SkuPerformanceMinAggregateOutputType = {
    id: string | null
    skuId: string | null
    skuCode: string | null
    seasonGroup: string | null
    fiscalYear: number | null
    storeId: string | null
    quantityBought: number | null
    quantitySold: number | null
    sellThroughPct: Decimal | null
    avgSellingPrice: Decimal | null
    totalRevenue: Decimal | null
    grossMarginPct: Decimal | null
    markdownPct: Decimal | null
    weeksToSellThru: number | null
    performanceScore: number | null
    velocityScore: number | null
    marginScore: number | null
    createdAt: Date | null
  }

  export type SkuPerformanceMaxAggregateOutputType = {
    id: string | null
    skuId: string | null
    skuCode: string | null
    seasonGroup: string | null
    fiscalYear: number | null
    storeId: string | null
    quantityBought: number | null
    quantitySold: number | null
    sellThroughPct: Decimal | null
    avgSellingPrice: Decimal | null
    totalRevenue: Decimal | null
    grossMarginPct: Decimal | null
    markdownPct: Decimal | null
    weeksToSellThru: number | null
    performanceScore: number | null
    velocityScore: number | null
    marginScore: number | null
    createdAt: Date | null
  }

  export type SkuPerformanceCountAggregateOutputType = {
    id: number
    skuId: number
    skuCode: number
    seasonGroup: number
    fiscalYear: number
    storeId: number
    quantityBought: number
    quantitySold: number
    sellThroughPct: number
    avgSellingPrice: number
    totalRevenue: number
    grossMarginPct: number
    markdownPct: number
    weeksToSellThru: number
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt: number
    _all: number
  }


  export type SkuPerformanceAvgAggregateInputType = {
    fiscalYear?: true
    quantityBought?: true
    quantitySold?: true
    sellThroughPct?: true
    avgSellingPrice?: true
    totalRevenue?: true
    grossMarginPct?: true
    markdownPct?: true
    weeksToSellThru?: true
    performanceScore?: true
    velocityScore?: true
    marginScore?: true
  }

  export type SkuPerformanceSumAggregateInputType = {
    fiscalYear?: true
    quantityBought?: true
    quantitySold?: true
    sellThroughPct?: true
    avgSellingPrice?: true
    totalRevenue?: true
    grossMarginPct?: true
    markdownPct?: true
    weeksToSellThru?: true
    performanceScore?: true
    velocityScore?: true
    marginScore?: true
  }

  export type SkuPerformanceMinAggregateInputType = {
    id?: true
    skuId?: true
    skuCode?: true
    seasonGroup?: true
    fiscalYear?: true
    storeId?: true
    quantityBought?: true
    quantitySold?: true
    sellThroughPct?: true
    avgSellingPrice?: true
    totalRevenue?: true
    grossMarginPct?: true
    markdownPct?: true
    weeksToSellThru?: true
    performanceScore?: true
    velocityScore?: true
    marginScore?: true
    createdAt?: true
  }

  export type SkuPerformanceMaxAggregateInputType = {
    id?: true
    skuId?: true
    skuCode?: true
    seasonGroup?: true
    fiscalYear?: true
    storeId?: true
    quantityBought?: true
    quantitySold?: true
    sellThroughPct?: true
    avgSellingPrice?: true
    totalRevenue?: true
    grossMarginPct?: true
    markdownPct?: true
    weeksToSellThru?: true
    performanceScore?: true
    velocityScore?: true
    marginScore?: true
    createdAt?: true
  }

  export type SkuPerformanceCountAggregateInputType = {
    id?: true
    skuId?: true
    skuCode?: true
    seasonGroup?: true
    fiscalYear?: true
    storeId?: true
    quantityBought?: true
    quantitySold?: true
    sellThroughPct?: true
    avgSellingPrice?: true
    totalRevenue?: true
    grossMarginPct?: true
    markdownPct?: true
    weeksToSellThru?: true
    performanceScore?: true
    velocityScore?: true
    marginScore?: true
    createdAt?: true
    _all?: true
  }

  export type SkuPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuPerformance to aggregate.
     */
    where?: SkuPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuPerformances to fetch.
     */
    orderBy?: SkuPerformanceOrderByWithRelationInput | SkuPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuPerformances
    **/
    _count?: true | SkuPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkuPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkuPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuPerformanceMaxAggregateInputType
  }

  export type GetSkuPerformanceAggregateType<T extends SkuPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuPerformance[P]>
      : GetScalarType<T[P], AggregateSkuPerformance[P]>
  }




  export type SkuPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuPerformanceWhereInput
    orderBy?: SkuPerformanceOrderByWithAggregationInput | SkuPerformanceOrderByWithAggregationInput[]
    by: SkuPerformanceScalarFieldEnum[] | SkuPerformanceScalarFieldEnum
    having?: SkuPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuPerformanceCountAggregateInputType | true
    _avg?: SkuPerformanceAvgAggregateInputType
    _sum?: SkuPerformanceSumAggregateInputType
    _min?: SkuPerformanceMinAggregateInputType
    _max?: SkuPerformanceMaxAggregateInputType
  }

  export type SkuPerformanceGroupByOutputType = {
    id: string
    skuId: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    storeId: string | null
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal
    avgSellingPrice: Decimal
    totalRevenue: Decimal
    grossMarginPct: Decimal
    markdownPct: Decimal
    weeksToSellThru: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt: Date
    _count: SkuPerformanceCountAggregateOutputType | null
    _avg: SkuPerformanceAvgAggregateOutputType | null
    _sum: SkuPerformanceSumAggregateOutputType | null
    _min: SkuPerformanceMinAggregateOutputType | null
    _max: SkuPerformanceMaxAggregateOutputType | null
  }

  type GetSkuPerformanceGroupByPayload<T extends SkuPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], SkuPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type SkuPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuId?: boolean
    skuCode?: boolean
    seasonGroup?: boolean
    fiscalYear?: boolean
    storeId?: boolean
    quantityBought?: boolean
    quantitySold?: boolean
    sellThroughPct?: boolean
    avgSellingPrice?: boolean
    totalRevenue?: boolean
    grossMarginPct?: boolean
    markdownPct?: boolean
    weeksToSellThru?: boolean
    performanceScore?: boolean
    velocityScore?: boolean
    marginScore?: boolean
    createdAt?: boolean
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | SkuPerformance$storeArgs<ExtArgs>
  }, ExtArgs["result"]["skuPerformance"]>

  export type SkuPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skuId?: boolean
    skuCode?: boolean
    seasonGroup?: boolean
    fiscalYear?: boolean
    storeId?: boolean
    quantityBought?: boolean
    quantitySold?: boolean
    sellThroughPct?: boolean
    avgSellingPrice?: boolean
    totalRevenue?: boolean
    grossMarginPct?: boolean
    markdownPct?: boolean
    weeksToSellThru?: boolean
    performanceScore?: boolean
    velocityScore?: boolean
    marginScore?: boolean
    createdAt?: boolean
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | SkuPerformance$storeArgs<ExtArgs>
  }, ExtArgs["result"]["skuPerformance"]>

  export type SkuPerformanceSelectScalar = {
    id?: boolean
    skuId?: boolean
    skuCode?: boolean
    seasonGroup?: boolean
    fiscalYear?: boolean
    storeId?: boolean
    quantityBought?: boolean
    quantitySold?: boolean
    sellThroughPct?: boolean
    avgSellingPrice?: boolean
    totalRevenue?: boolean
    grossMarginPct?: boolean
    markdownPct?: boolean
    weeksToSellThru?: boolean
    performanceScore?: boolean
    velocityScore?: boolean
    marginScore?: boolean
    createdAt?: boolean
  }

  export type SkuPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | SkuPerformance$storeArgs<ExtArgs>
  }
  export type SkuPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
    store?: boolean | SkuPerformance$storeArgs<ExtArgs>
  }

  export type $SkuPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuPerformance"
    objects: {
      sku: Prisma.$SkuCatalogPayload<ExtArgs>
      store: Prisma.$StorePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skuId: string
      skuCode: string
      seasonGroup: string
      fiscalYear: number
      storeId: string | null
      quantityBought: number
      quantitySold: number
      sellThroughPct: Prisma.Decimal
      avgSellingPrice: Prisma.Decimal
      totalRevenue: Prisma.Decimal
      grossMarginPct: Prisma.Decimal
      markdownPct: Prisma.Decimal
      weeksToSellThru: number | null
      performanceScore: number
      velocityScore: number
      marginScore: number
      createdAt: Date
    }, ExtArgs["result"]["skuPerformance"]>
    composites: {}
  }

  type SkuPerformanceGetPayload<S extends boolean | null | undefined | SkuPerformanceDefaultArgs> = $Result.GetResult<Prisma.$SkuPerformancePayload, S>

  type SkuPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkuPerformanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkuPerformanceCountAggregateInputType | true
    }

  export interface SkuPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuPerformance'], meta: { name: 'SkuPerformance' } }
    /**
     * Find zero or one SkuPerformance that matches the filter.
     * @param {SkuPerformanceFindUniqueArgs} args - Arguments to find a SkuPerformance
     * @example
     * // Get one SkuPerformance
     * const skuPerformance = await prisma.skuPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuPerformanceFindUniqueArgs>(args: SelectSubset<T, SkuPerformanceFindUniqueArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkuPerformance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkuPerformanceFindUniqueOrThrowArgs} args - Arguments to find a SkuPerformance
     * @example
     * // Get one SkuPerformance
     * const skuPerformance = await prisma.skuPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkuPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceFindFirstArgs} args - Arguments to find a SkuPerformance
     * @example
     * // Get one SkuPerformance
     * const skuPerformance = await prisma.skuPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuPerformanceFindFirstArgs>(args?: SelectSubset<T, SkuPerformanceFindFirstArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkuPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceFindFirstOrThrowArgs} args - Arguments to find a SkuPerformance
     * @example
     * // Get one SkuPerformance
     * const skuPerformance = await prisma.skuPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkuPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuPerformances
     * const skuPerformances = await prisma.skuPerformance.findMany()
     * 
     * // Get first 10 SkuPerformances
     * const skuPerformances = await prisma.skuPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuPerformanceWithIdOnly = await prisma.skuPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuPerformanceFindManyArgs>(args?: SelectSubset<T, SkuPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkuPerformance.
     * @param {SkuPerformanceCreateArgs} args - Arguments to create a SkuPerformance.
     * @example
     * // Create one SkuPerformance
     * const SkuPerformance = await prisma.skuPerformance.create({
     *   data: {
     *     // ... data to create a SkuPerformance
     *   }
     * })
     * 
     */
    create<T extends SkuPerformanceCreateArgs>(args: SelectSubset<T, SkuPerformanceCreateArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkuPerformances.
     * @param {SkuPerformanceCreateManyArgs} args - Arguments to create many SkuPerformances.
     * @example
     * // Create many SkuPerformances
     * const skuPerformance = await prisma.skuPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuPerformanceCreateManyArgs>(args?: SelectSubset<T, SkuPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuPerformances and returns the data saved in the database.
     * @param {SkuPerformanceCreateManyAndReturnArgs} args - Arguments to create many SkuPerformances.
     * @example
     * // Create many SkuPerformances
     * const skuPerformance = await prisma.skuPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuPerformances and only return the `id`
     * const skuPerformanceWithIdOnly = await prisma.skuPerformance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkuPerformance.
     * @param {SkuPerformanceDeleteArgs} args - Arguments to delete one SkuPerformance.
     * @example
     * // Delete one SkuPerformance
     * const SkuPerformance = await prisma.skuPerformance.delete({
     *   where: {
     *     // ... filter to delete one SkuPerformance
     *   }
     * })
     * 
     */
    delete<T extends SkuPerformanceDeleteArgs>(args: SelectSubset<T, SkuPerformanceDeleteArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkuPerformance.
     * @param {SkuPerformanceUpdateArgs} args - Arguments to update one SkuPerformance.
     * @example
     * // Update one SkuPerformance
     * const skuPerformance = await prisma.skuPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuPerformanceUpdateArgs>(args: SelectSubset<T, SkuPerformanceUpdateArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkuPerformances.
     * @param {SkuPerformanceDeleteManyArgs} args - Arguments to filter SkuPerformances to delete.
     * @example
     * // Delete a few SkuPerformances
     * const { count } = await prisma.skuPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuPerformanceDeleteManyArgs>(args?: SelectSubset<T, SkuPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuPerformances
     * const skuPerformance = await prisma.skuPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuPerformanceUpdateManyArgs>(args: SelectSubset<T, SkuPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkuPerformance.
     * @param {SkuPerformanceUpsertArgs} args - Arguments to update or create a SkuPerformance.
     * @example
     * // Update or create a SkuPerformance
     * const skuPerformance = await prisma.skuPerformance.upsert({
     *   create: {
     *     // ... data to create a SkuPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuPerformance we want to update
     *   }
     * })
     */
    upsert<T extends SkuPerformanceUpsertArgs>(args: SelectSubset<T, SkuPerformanceUpsertArgs<ExtArgs>>): Prisma__SkuPerformanceClient<$Result.GetResult<Prisma.$SkuPerformancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkuPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceCountArgs} args - Arguments to filter SkuPerformances to count.
     * @example
     * // Count the number of SkuPerformances
     * const count = await prisma.skuPerformance.count({
     *   where: {
     *     // ... the filter for the SkuPerformances we want to count
     *   }
     * })
    **/
    count<T extends SkuPerformanceCountArgs>(
      args?: Subset<T, SkuPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuPerformanceAggregateArgs>(args: Subset<T, SkuPerformanceAggregateArgs>): Prisma.PrismaPromise<GetSkuPerformanceAggregateType<T>>

    /**
     * Group by SkuPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: SkuPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuPerformance model
   */
  readonly fields: SkuPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sku<T extends SkuCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalogDefaultArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends SkuPerformance$storeArgs<ExtArgs> = {}>(args?: Subset<T, SkuPerformance$storeArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuPerformance model
   */ 
  interface SkuPerformanceFieldRefs {
    readonly id: FieldRef<"SkuPerformance", 'String'>
    readonly skuId: FieldRef<"SkuPerformance", 'String'>
    readonly skuCode: FieldRef<"SkuPerformance", 'String'>
    readonly seasonGroup: FieldRef<"SkuPerformance", 'String'>
    readonly fiscalYear: FieldRef<"SkuPerformance", 'Int'>
    readonly storeId: FieldRef<"SkuPerformance", 'String'>
    readonly quantityBought: FieldRef<"SkuPerformance", 'Int'>
    readonly quantitySold: FieldRef<"SkuPerformance", 'Int'>
    readonly sellThroughPct: FieldRef<"SkuPerformance", 'Decimal'>
    readonly avgSellingPrice: FieldRef<"SkuPerformance", 'Decimal'>
    readonly totalRevenue: FieldRef<"SkuPerformance", 'Decimal'>
    readonly grossMarginPct: FieldRef<"SkuPerformance", 'Decimal'>
    readonly markdownPct: FieldRef<"SkuPerformance", 'Decimal'>
    readonly weeksToSellThru: FieldRef<"SkuPerformance", 'Int'>
    readonly performanceScore: FieldRef<"SkuPerformance", 'Int'>
    readonly velocityScore: FieldRef<"SkuPerformance", 'Int'>
    readonly marginScore: FieldRef<"SkuPerformance", 'Int'>
    readonly createdAt: FieldRef<"SkuPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkuPerformance findUnique
   */
  export type SkuPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which SkuPerformance to fetch.
     */
    where: SkuPerformanceWhereUniqueInput
  }

  /**
   * SkuPerformance findUniqueOrThrow
   */
  export type SkuPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which SkuPerformance to fetch.
     */
    where: SkuPerformanceWhereUniqueInput
  }

  /**
   * SkuPerformance findFirst
   */
  export type SkuPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which SkuPerformance to fetch.
     */
    where?: SkuPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuPerformances to fetch.
     */
    orderBy?: SkuPerformanceOrderByWithRelationInput | SkuPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuPerformances.
     */
    cursor?: SkuPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuPerformances.
     */
    distinct?: SkuPerformanceScalarFieldEnum | SkuPerformanceScalarFieldEnum[]
  }

  /**
   * SkuPerformance findFirstOrThrow
   */
  export type SkuPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which SkuPerformance to fetch.
     */
    where?: SkuPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuPerformances to fetch.
     */
    orderBy?: SkuPerformanceOrderByWithRelationInput | SkuPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuPerformances.
     */
    cursor?: SkuPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuPerformances.
     */
    distinct?: SkuPerformanceScalarFieldEnum | SkuPerformanceScalarFieldEnum[]
  }

  /**
   * SkuPerformance findMany
   */
  export type SkuPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which SkuPerformances to fetch.
     */
    where?: SkuPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuPerformances to fetch.
     */
    orderBy?: SkuPerformanceOrderByWithRelationInput | SkuPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuPerformances.
     */
    cursor?: SkuPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuPerformances.
     */
    skip?: number
    distinct?: SkuPerformanceScalarFieldEnum | SkuPerformanceScalarFieldEnum[]
  }

  /**
   * SkuPerformance create
   */
  export type SkuPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuPerformance.
     */
    data: XOR<SkuPerformanceCreateInput, SkuPerformanceUncheckedCreateInput>
  }

  /**
   * SkuPerformance createMany
   */
  export type SkuPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuPerformances.
     */
    data: SkuPerformanceCreateManyInput | SkuPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuPerformance createManyAndReturn
   */
  export type SkuPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkuPerformances.
     */
    data: SkuPerformanceCreateManyInput | SkuPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuPerformance update
   */
  export type SkuPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuPerformance.
     */
    data: XOR<SkuPerformanceUpdateInput, SkuPerformanceUncheckedUpdateInput>
    /**
     * Choose, which SkuPerformance to update.
     */
    where: SkuPerformanceWhereUniqueInput
  }

  /**
   * SkuPerformance updateMany
   */
  export type SkuPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuPerformances.
     */
    data: XOR<SkuPerformanceUpdateManyMutationInput, SkuPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which SkuPerformances to update
     */
    where?: SkuPerformanceWhereInput
  }

  /**
   * SkuPerformance upsert
   */
  export type SkuPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuPerformance to update in case it exists.
     */
    where: SkuPerformanceWhereUniqueInput
    /**
     * In case the SkuPerformance found by the `where` argument doesn't exist, create a new SkuPerformance with this data.
     */
    create: XOR<SkuPerformanceCreateInput, SkuPerformanceUncheckedCreateInput>
    /**
     * In case the SkuPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuPerformanceUpdateInput, SkuPerformanceUncheckedUpdateInput>
  }

  /**
   * SkuPerformance delete
   */
  export type SkuPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
    /**
     * Filter which SkuPerformance to delete.
     */
    where: SkuPerformanceWhereUniqueInput
  }

  /**
   * SkuPerformance deleteMany
   */
  export type SkuPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuPerformances to delete
     */
    where?: SkuPerformanceWhereInput
  }

  /**
   * SkuPerformance.store
   */
  export type SkuPerformance$storeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreInclude<ExtArgs> | null
    where?: StoreWhereInput
  }

  /**
   * SkuPerformance without action
   */
  export type SkuPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuPerformance
     */
    select?: SkuPerformanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model AttributeTrend
   */

  export type AggregateAttributeTrend = {
    _count: AttributeTrendCountAggregateOutputType | null
    _avg: AttributeTrendAvgAggregateOutputType | null
    _sum: AttributeTrendSumAggregateOutputType | null
    _min: AttributeTrendMinAggregateOutputType | null
    _max: AttributeTrendMaxAggregateOutputType | null
  }

  export type AttributeTrendAvgAggregateOutputType = {
    fiscalYear: number | null
    totalSkus: number | null
    avgSellThrough: Decimal | null
    avgMargin: Decimal | null
    trendScore: number | null
    yoyGrowth: Decimal | null
  }

  export type AttributeTrendSumAggregateOutputType = {
    fiscalYear: number | null
    totalSkus: number | null
    avgSellThrough: Decimal | null
    avgMargin: Decimal | null
    trendScore: number | null
    yoyGrowth: Decimal | null
  }

  export type AttributeTrendMinAggregateOutputType = {
    id: string | null
    attributeType: string | null
    attributeValue: string | null
    category: string | null
    seasonGroup: string | null
    fiscalYear: number | null
    totalSkus: number | null
    avgSellThrough: Decimal | null
    avgMargin: Decimal | null
    trendScore: number | null
    yoyGrowth: Decimal | null
    createdAt: Date | null
  }

  export type AttributeTrendMaxAggregateOutputType = {
    id: string | null
    attributeType: string | null
    attributeValue: string | null
    category: string | null
    seasonGroup: string | null
    fiscalYear: number | null
    totalSkus: number | null
    avgSellThrough: Decimal | null
    avgMargin: Decimal | null
    trendScore: number | null
    yoyGrowth: Decimal | null
    createdAt: Date | null
  }

  export type AttributeTrendCountAggregateOutputType = {
    id: number
    attributeType: number
    attributeValue: number
    category: number
    seasonGroup: number
    fiscalYear: number
    totalSkus: number
    avgSellThrough: number
    avgMargin: number
    trendScore: number
    yoyGrowth: number
    createdAt: number
    _all: number
  }


  export type AttributeTrendAvgAggregateInputType = {
    fiscalYear?: true
    totalSkus?: true
    avgSellThrough?: true
    avgMargin?: true
    trendScore?: true
    yoyGrowth?: true
  }

  export type AttributeTrendSumAggregateInputType = {
    fiscalYear?: true
    totalSkus?: true
    avgSellThrough?: true
    avgMargin?: true
    trendScore?: true
    yoyGrowth?: true
  }

  export type AttributeTrendMinAggregateInputType = {
    id?: true
    attributeType?: true
    attributeValue?: true
    category?: true
    seasonGroup?: true
    fiscalYear?: true
    totalSkus?: true
    avgSellThrough?: true
    avgMargin?: true
    trendScore?: true
    yoyGrowth?: true
    createdAt?: true
  }

  export type AttributeTrendMaxAggregateInputType = {
    id?: true
    attributeType?: true
    attributeValue?: true
    category?: true
    seasonGroup?: true
    fiscalYear?: true
    totalSkus?: true
    avgSellThrough?: true
    avgMargin?: true
    trendScore?: true
    yoyGrowth?: true
    createdAt?: true
  }

  export type AttributeTrendCountAggregateInputType = {
    id?: true
    attributeType?: true
    attributeValue?: true
    category?: true
    seasonGroup?: true
    fiscalYear?: true
    totalSkus?: true
    avgSellThrough?: true
    avgMargin?: true
    trendScore?: true
    yoyGrowth?: true
    createdAt?: true
    _all?: true
  }

  export type AttributeTrendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttributeTrend to aggregate.
     */
    where?: AttributeTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeTrends to fetch.
     */
    orderBy?: AttributeTrendOrderByWithRelationInput | AttributeTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttributeTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttributeTrends
    **/
    _count?: true | AttributeTrendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttributeTrendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttributeTrendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttributeTrendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttributeTrendMaxAggregateInputType
  }

  export type GetAttributeTrendAggregateType<T extends AttributeTrendAggregateArgs> = {
        [P in keyof T & keyof AggregateAttributeTrend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttributeTrend[P]>
      : GetScalarType<T[P], AggregateAttributeTrend[P]>
  }




  export type AttributeTrendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttributeTrendWhereInput
    orderBy?: AttributeTrendOrderByWithAggregationInput | AttributeTrendOrderByWithAggregationInput[]
    by: AttributeTrendScalarFieldEnum[] | AttributeTrendScalarFieldEnum
    having?: AttributeTrendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttributeTrendCountAggregateInputType | true
    _avg?: AttributeTrendAvgAggregateInputType
    _sum?: AttributeTrendSumAggregateInputType
    _min?: AttributeTrendMinAggregateInputType
    _max?: AttributeTrendMaxAggregateInputType
  }

  export type AttributeTrendGroupByOutputType = {
    id: string
    attributeType: string
    attributeValue: string
    category: string | null
    seasonGroup: string
    fiscalYear: number
    totalSkus: number
    avgSellThrough: Decimal
    avgMargin: Decimal
    trendScore: number
    yoyGrowth: Decimal | null
    createdAt: Date
    _count: AttributeTrendCountAggregateOutputType | null
    _avg: AttributeTrendAvgAggregateOutputType | null
    _sum: AttributeTrendSumAggregateOutputType | null
    _min: AttributeTrendMinAggregateOutputType | null
    _max: AttributeTrendMaxAggregateOutputType | null
  }

  type GetAttributeTrendGroupByPayload<T extends AttributeTrendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttributeTrendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttributeTrendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttributeTrendGroupByOutputType[P]>
            : GetScalarType<T[P], AttributeTrendGroupByOutputType[P]>
        }
      >
    >


  export type AttributeTrendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    category?: boolean
    seasonGroup?: boolean
    fiscalYear?: boolean
    totalSkus?: boolean
    avgSellThrough?: boolean
    avgMargin?: boolean
    trendScore?: boolean
    yoyGrowth?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["attributeTrend"]>

  export type AttributeTrendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    category?: boolean
    seasonGroup?: boolean
    fiscalYear?: boolean
    totalSkus?: boolean
    avgSellThrough?: boolean
    avgMargin?: boolean
    trendScore?: boolean
    yoyGrowth?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["attributeTrend"]>

  export type AttributeTrendSelectScalar = {
    id?: boolean
    attributeType?: boolean
    attributeValue?: boolean
    category?: boolean
    seasonGroup?: boolean
    fiscalYear?: boolean
    totalSkus?: boolean
    avgSellThrough?: boolean
    avgMargin?: boolean
    trendScore?: boolean
    yoyGrowth?: boolean
    createdAt?: boolean
  }


  export type $AttributeTrendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttributeTrend"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attributeType: string
      attributeValue: string
      category: string | null
      seasonGroup: string
      fiscalYear: number
      totalSkus: number
      avgSellThrough: Prisma.Decimal
      avgMargin: Prisma.Decimal
      trendScore: number
      yoyGrowth: Prisma.Decimal | null
      createdAt: Date
    }, ExtArgs["result"]["attributeTrend"]>
    composites: {}
  }

  type AttributeTrendGetPayload<S extends boolean | null | undefined | AttributeTrendDefaultArgs> = $Result.GetResult<Prisma.$AttributeTrendPayload, S>

  type AttributeTrendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttributeTrendFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttributeTrendCountAggregateInputType | true
    }

  export interface AttributeTrendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttributeTrend'], meta: { name: 'AttributeTrend' } }
    /**
     * Find zero or one AttributeTrend that matches the filter.
     * @param {AttributeTrendFindUniqueArgs} args - Arguments to find a AttributeTrend
     * @example
     * // Get one AttributeTrend
     * const attributeTrend = await prisma.attributeTrend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttributeTrendFindUniqueArgs>(args: SelectSubset<T, AttributeTrendFindUniqueArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttributeTrend that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttributeTrendFindUniqueOrThrowArgs} args - Arguments to find a AttributeTrend
     * @example
     * // Get one AttributeTrend
     * const attributeTrend = await prisma.attributeTrend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttributeTrendFindUniqueOrThrowArgs>(args: SelectSubset<T, AttributeTrendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttributeTrend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendFindFirstArgs} args - Arguments to find a AttributeTrend
     * @example
     * // Get one AttributeTrend
     * const attributeTrend = await prisma.attributeTrend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttributeTrendFindFirstArgs>(args?: SelectSubset<T, AttributeTrendFindFirstArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttributeTrend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendFindFirstOrThrowArgs} args - Arguments to find a AttributeTrend
     * @example
     * // Get one AttributeTrend
     * const attributeTrend = await prisma.attributeTrend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttributeTrendFindFirstOrThrowArgs>(args?: SelectSubset<T, AttributeTrendFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttributeTrends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttributeTrends
     * const attributeTrends = await prisma.attributeTrend.findMany()
     * 
     * // Get first 10 AttributeTrends
     * const attributeTrends = await prisma.attributeTrend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attributeTrendWithIdOnly = await prisma.attributeTrend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttributeTrendFindManyArgs>(args?: SelectSubset<T, AttributeTrendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttributeTrend.
     * @param {AttributeTrendCreateArgs} args - Arguments to create a AttributeTrend.
     * @example
     * // Create one AttributeTrend
     * const AttributeTrend = await prisma.attributeTrend.create({
     *   data: {
     *     // ... data to create a AttributeTrend
     *   }
     * })
     * 
     */
    create<T extends AttributeTrendCreateArgs>(args: SelectSubset<T, AttributeTrendCreateArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttributeTrends.
     * @param {AttributeTrendCreateManyArgs} args - Arguments to create many AttributeTrends.
     * @example
     * // Create many AttributeTrends
     * const attributeTrend = await prisma.attributeTrend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttributeTrendCreateManyArgs>(args?: SelectSubset<T, AttributeTrendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttributeTrends and returns the data saved in the database.
     * @param {AttributeTrendCreateManyAndReturnArgs} args - Arguments to create many AttributeTrends.
     * @example
     * // Create many AttributeTrends
     * const attributeTrend = await prisma.attributeTrend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttributeTrends and only return the `id`
     * const attributeTrendWithIdOnly = await prisma.attributeTrend.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttributeTrendCreateManyAndReturnArgs>(args?: SelectSubset<T, AttributeTrendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttributeTrend.
     * @param {AttributeTrendDeleteArgs} args - Arguments to delete one AttributeTrend.
     * @example
     * // Delete one AttributeTrend
     * const AttributeTrend = await prisma.attributeTrend.delete({
     *   where: {
     *     // ... filter to delete one AttributeTrend
     *   }
     * })
     * 
     */
    delete<T extends AttributeTrendDeleteArgs>(args: SelectSubset<T, AttributeTrendDeleteArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttributeTrend.
     * @param {AttributeTrendUpdateArgs} args - Arguments to update one AttributeTrend.
     * @example
     * // Update one AttributeTrend
     * const attributeTrend = await prisma.attributeTrend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttributeTrendUpdateArgs>(args: SelectSubset<T, AttributeTrendUpdateArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttributeTrends.
     * @param {AttributeTrendDeleteManyArgs} args - Arguments to filter AttributeTrends to delete.
     * @example
     * // Delete a few AttributeTrends
     * const { count } = await prisma.attributeTrend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttributeTrendDeleteManyArgs>(args?: SelectSubset<T, AttributeTrendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttributeTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttributeTrends
     * const attributeTrend = await prisma.attributeTrend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttributeTrendUpdateManyArgs>(args: SelectSubset<T, AttributeTrendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttributeTrend.
     * @param {AttributeTrendUpsertArgs} args - Arguments to update or create a AttributeTrend.
     * @example
     * // Update or create a AttributeTrend
     * const attributeTrend = await prisma.attributeTrend.upsert({
     *   create: {
     *     // ... data to create a AttributeTrend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttributeTrend we want to update
     *   }
     * })
     */
    upsert<T extends AttributeTrendUpsertArgs>(args: SelectSubset<T, AttributeTrendUpsertArgs<ExtArgs>>): Prisma__AttributeTrendClient<$Result.GetResult<Prisma.$AttributeTrendPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttributeTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendCountArgs} args - Arguments to filter AttributeTrends to count.
     * @example
     * // Count the number of AttributeTrends
     * const count = await prisma.attributeTrend.count({
     *   where: {
     *     // ... the filter for the AttributeTrends we want to count
     *   }
     * })
    **/
    count<T extends AttributeTrendCountArgs>(
      args?: Subset<T, AttributeTrendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttributeTrendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttributeTrend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttributeTrendAggregateArgs>(args: Subset<T, AttributeTrendAggregateArgs>): Prisma.PrismaPromise<GetAttributeTrendAggregateType<T>>

    /**
     * Group by AttributeTrend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributeTrendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttributeTrendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttributeTrendGroupByArgs['orderBy'] }
        : { orderBy?: AttributeTrendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttributeTrendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttributeTrendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttributeTrend model
   */
  readonly fields: AttributeTrendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttributeTrend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttributeTrendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttributeTrend model
   */ 
  interface AttributeTrendFieldRefs {
    readonly id: FieldRef<"AttributeTrend", 'String'>
    readonly attributeType: FieldRef<"AttributeTrend", 'String'>
    readonly attributeValue: FieldRef<"AttributeTrend", 'String'>
    readonly category: FieldRef<"AttributeTrend", 'String'>
    readonly seasonGroup: FieldRef<"AttributeTrend", 'String'>
    readonly fiscalYear: FieldRef<"AttributeTrend", 'Int'>
    readonly totalSkus: FieldRef<"AttributeTrend", 'Int'>
    readonly avgSellThrough: FieldRef<"AttributeTrend", 'Decimal'>
    readonly avgMargin: FieldRef<"AttributeTrend", 'Decimal'>
    readonly trendScore: FieldRef<"AttributeTrend", 'Int'>
    readonly yoyGrowth: FieldRef<"AttributeTrend", 'Decimal'>
    readonly createdAt: FieldRef<"AttributeTrend", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttributeTrend findUnique
   */
  export type AttributeTrendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * Filter, which AttributeTrend to fetch.
     */
    where: AttributeTrendWhereUniqueInput
  }

  /**
   * AttributeTrend findUniqueOrThrow
   */
  export type AttributeTrendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * Filter, which AttributeTrend to fetch.
     */
    where: AttributeTrendWhereUniqueInput
  }

  /**
   * AttributeTrend findFirst
   */
  export type AttributeTrendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * Filter, which AttributeTrend to fetch.
     */
    where?: AttributeTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeTrends to fetch.
     */
    orderBy?: AttributeTrendOrderByWithRelationInput | AttributeTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttributeTrends.
     */
    cursor?: AttributeTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttributeTrends.
     */
    distinct?: AttributeTrendScalarFieldEnum | AttributeTrendScalarFieldEnum[]
  }

  /**
   * AttributeTrend findFirstOrThrow
   */
  export type AttributeTrendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * Filter, which AttributeTrend to fetch.
     */
    where?: AttributeTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeTrends to fetch.
     */
    orderBy?: AttributeTrendOrderByWithRelationInput | AttributeTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttributeTrends.
     */
    cursor?: AttributeTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttributeTrends.
     */
    distinct?: AttributeTrendScalarFieldEnum | AttributeTrendScalarFieldEnum[]
  }

  /**
   * AttributeTrend findMany
   */
  export type AttributeTrendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * Filter, which AttributeTrends to fetch.
     */
    where?: AttributeTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttributeTrends to fetch.
     */
    orderBy?: AttributeTrendOrderByWithRelationInput | AttributeTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttributeTrends.
     */
    cursor?: AttributeTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttributeTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttributeTrends.
     */
    skip?: number
    distinct?: AttributeTrendScalarFieldEnum | AttributeTrendScalarFieldEnum[]
  }

  /**
   * AttributeTrend create
   */
  export type AttributeTrendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * The data needed to create a AttributeTrend.
     */
    data: XOR<AttributeTrendCreateInput, AttributeTrendUncheckedCreateInput>
  }

  /**
   * AttributeTrend createMany
   */
  export type AttributeTrendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttributeTrends.
     */
    data: AttributeTrendCreateManyInput | AttributeTrendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttributeTrend createManyAndReturn
   */
  export type AttributeTrendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttributeTrends.
     */
    data: AttributeTrendCreateManyInput | AttributeTrendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttributeTrend update
   */
  export type AttributeTrendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * The data needed to update a AttributeTrend.
     */
    data: XOR<AttributeTrendUpdateInput, AttributeTrendUncheckedUpdateInput>
    /**
     * Choose, which AttributeTrend to update.
     */
    where: AttributeTrendWhereUniqueInput
  }

  /**
   * AttributeTrend updateMany
   */
  export type AttributeTrendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttributeTrends.
     */
    data: XOR<AttributeTrendUpdateManyMutationInput, AttributeTrendUncheckedUpdateManyInput>
    /**
     * Filter which AttributeTrends to update
     */
    where?: AttributeTrendWhereInput
  }

  /**
   * AttributeTrend upsert
   */
  export type AttributeTrendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * The filter to search for the AttributeTrend to update in case it exists.
     */
    where: AttributeTrendWhereUniqueInput
    /**
     * In case the AttributeTrend found by the `where` argument doesn't exist, create a new AttributeTrend with this data.
     */
    create: XOR<AttributeTrendCreateInput, AttributeTrendUncheckedCreateInput>
    /**
     * In case the AttributeTrend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttributeTrendUpdateInput, AttributeTrendUncheckedUpdateInput>
  }

  /**
   * AttributeTrend delete
   */
  export type AttributeTrendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
    /**
     * Filter which AttributeTrend to delete.
     */
    where: AttributeTrendWhereUniqueInput
  }

  /**
   * AttributeTrend deleteMany
   */
  export type AttributeTrendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttributeTrends to delete
     */
    where?: AttributeTrendWhereInput
  }

  /**
   * AttributeTrend without action
   */
  export type AttributeTrendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributeTrend
     */
    select?: AttributeTrendSelect<ExtArgs> | null
  }


  /**
   * Model SkuRecommendation
   */

  export type AggregateSkuRecommendation = {
    _count: SkuRecommendationCountAggregateOutputType | null
    _avg: SkuRecommendationAvgAggregateOutputType | null
    _sum: SkuRecommendationSumAggregateOutputType | null
    _min: SkuRecommendationMinAggregateOutputType | null
    _max: SkuRecommendationMaxAggregateOutputType | null
  }

  export type SkuRecommendationAvgAggregateOutputType = {
    recommendedQty: number | null
    recommendedValue: Decimal | null
    confidence: Decimal | null
    performanceScore: number | null
    trendScore: number | null
    assortmentScore: number | null
    priceScore: number | null
    overallScore: number | null
  }

  export type SkuRecommendationSumAggregateOutputType = {
    recommendedQty: number | null
    recommendedValue: Decimal | null
    confidence: Decimal | null
    performanceScore: number | null
    trendScore: number | null
    assortmentScore: number | null
    priceScore: number | null
    overallScore: number | null
  }

  export type SkuRecommendationMinAggregateOutputType = {
    id: string | null
    budgetDetailId: string | null
    category: string | null
    subCategory: string | null
    skuId: string | null
    skuCode: string | null
    productName: string | null
    recommendedQty: number | null
    recommendedValue: Decimal | null
    confidence: Decimal | null
    performanceScore: number | null
    trendScore: number | null
    assortmentScore: number | null
    priceScore: number | null
    overallScore: number | null
    riskLevel: string | null
    reasoning: string | null
    isSelected: boolean | null
    isRejected: boolean | null
    createdAt: Date | null
  }

  export type SkuRecommendationMaxAggregateOutputType = {
    id: string | null
    budgetDetailId: string | null
    category: string | null
    subCategory: string | null
    skuId: string | null
    skuCode: string | null
    productName: string | null
    recommendedQty: number | null
    recommendedValue: Decimal | null
    confidence: Decimal | null
    performanceScore: number | null
    trendScore: number | null
    assortmentScore: number | null
    priceScore: number | null
    overallScore: number | null
    riskLevel: string | null
    reasoning: string | null
    isSelected: boolean | null
    isRejected: boolean | null
    createdAt: Date | null
  }

  export type SkuRecommendationCountAggregateOutputType = {
    id: number
    budgetDetailId: number
    category: number
    subCategory: number
    skuId: number
    skuCode: number
    productName: number
    recommendedQty: number
    recommendedValue: number
    confidence: number
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: number
    reasoning: number
    isSelected: number
    isRejected: number
    createdAt: number
    _all: number
  }


  export type SkuRecommendationAvgAggregateInputType = {
    recommendedQty?: true
    recommendedValue?: true
    confidence?: true
    performanceScore?: true
    trendScore?: true
    assortmentScore?: true
    priceScore?: true
    overallScore?: true
  }

  export type SkuRecommendationSumAggregateInputType = {
    recommendedQty?: true
    recommendedValue?: true
    confidence?: true
    performanceScore?: true
    trendScore?: true
    assortmentScore?: true
    priceScore?: true
    overallScore?: true
  }

  export type SkuRecommendationMinAggregateInputType = {
    id?: true
    budgetDetailId?: true
    category?: true
    subCategory?: true
    skuId?: true
    skuCode?: true
    productName?: true
    recommendedQty?: true
    recommendedValue?: true
    confidence?: true
    performanceScore?: true
    trendScore?: true
    assortmentScore?: true
    priceScore?: true
    overallScore?: true
    riskLevel?: true
    reasoning?: true
    isSelected?: true
    isRejected?: true
    createdAt?: true
  }

  export type SkuRecommendationMaxAggregateInputType = {
    id?: true
    budgetDetailId?: true
    category?: true
    subCategory?: true
    skuId?: true
    skuCode?: true
    productName?: true
    recommendedQty?: true
    recommendedValue?: true
    confidence?: true
    performanceScore?: true
    trendScore?: true
    assortmentScore?: true
    priceScore?: true
    overallScore?: true
    riskLevel?: true
    reasoning?: true
    isSelected?: true
    isRejected?: true
    createdAt?: true
  }

  export type SkuRecommendationCountAggregateInputType = {
    id?: true
    budgetDetailId?: true
    category?: true
    subCategory?: true
    skuId?: true
    skuCode?: true
    productName?: true
    recommendedQty?: true
    recommendedValue?: true
    confidence?: true
    performanceScore?: true
    trendScore?: true
    assortmentScore?: true
    priceScore?: true
    overallScore?: true
    riskLevel?: true
    reasoning?: true
    isSelected?: true
    isRejected?: true
    createdAt?: true
    _all?: true
  }

  export type SkuRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuRecommendation to aggregate.
     */
    where?: SkuRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuRecommendations to fetch.
     */
    orderBy?: SkuRecommendationOrderByWithRelationInput | SkuRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkuRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkuRecommendations
    **/
    _count?: true | SkuRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkuRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkuRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkuRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkuRecommendationMaxAggregateInputType
  }

  export type GetSkuRecommendationAggregateType<T extends SkuRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateSkuRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkuRecommendation[P]>
      : GetScalarType<T[P], AggregateSkuRecommendation[P]>
  }




  export type SkuRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkuRecommendationWhereInput
    orderBy?: SkuRecommendationOrderByWithAggregationInput | SkuRecommendationOrderByWithAggregationInput[]
    by: SkuRecommendationScalarFieldEnum[] | SkuRecommendationScalarFieldEnum
    having?: SkuRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkuRecommendationCountAggregateInputType | true
    _avg?: SkuRecommendationAvgAggregateInputType
    _sum?: SkuRecommendationSumAggregateInputType
    _min?: SkuRecommendationMinAggregateInputType
    _max?: SkuRecommendationMaxAggregateInputType
  }

  export type SkuRecommendationGroupByOutputType = {
    id: string
    budgetDetailId: string
    category: string
    subCategory: string | null
    skuId: string
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal
    confidence: Decimal
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning: string | null
    isSelected: boolean
    isRejected: boolean
    createdAt: Date
    _count: SkuRecommendationCountAggregateOutputType | null
    _avg: SkuRecommendationAvgAggregateOutputType | null
    _sum: SkuRecommendationSumAggregateOutputType | null
    _min: SkuRecommendationMinAggregateOutputType | null
    _max: SkuRecommendationMaxAggregateOutputType | null
  }

  type GetSkuRecommendationGroupByPayload<T extends SkuRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkuRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkuRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkuRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], SkuRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type SkuRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetDetailId?: boolean
    category?: boolean
    subCategory?: boolean
    skuId?: boolean
    skuCode?: boolean
    productName?: boolean
    recommendedQty?: boolean
    recommendedValue?: boolean
    confidence?: boolean
    performanceScore?: boolean
    trendScore?: boolean
    assortmentScore?: boolean
    priceScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    reasoning?: boolean
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: boolean
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuRecommendation"]>

  export type SkuRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budgetDetailId?: boolean
    category?: boolean
    subCategory?: boolean
    skuId?: boolean
    skuCode?: boolean
    productName?: boolean
    recommendedQty?: boolean
    recommendedValue?: boolean
    confidence?: boolean
    performanceScore?: boolean
    trendScore?: boolean
    assortmentScore?: boolean
    priceScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    reasoning?: boolean
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: boolean
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skuRecommendation"]>

  export type SkuRecommendationSelectScalar = {
    id?: boolean
    budgetDetailId?: boolean
    category?: boolean
    subCategory?: boolean
    skuId?: boolean
    skuCode?: boolean
    productName?: boolean
    recommendedQty?: boolean
    recommendedValue?: boolean
    confidence?: boolean
    performanceScore?: boolean
    trendScore?: boolean
    assortmentScore?: boolean
    priceScore?: boolean
    overallScore?: boolean
    riskLevel?: boolean
    reasoning?: boolean
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: boolean
  }

  export type SkuRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
  }
  export type SkuRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budgetDetail?: boolean | BudgetDetailDefaultArgs<ExtArgs>
    sku?: boolean | SkuCatalogDefaultArgs<ExtArgs>
  }

  export type $SkuRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkuRecommendation"
    objects: {
      budgetDetail: Prisma.$BudgetDetailPayload<ExtArgs>
      sku: Prisma.$SkuCatalogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budgetDetailId: string
      category: string
      subCategory: string | null
      skuId: string
      skuCode: string
      productName: string
      recommendedQty: number
      recommendedValue: Prisma.Decimal
      confidence: Prisma.Decimal
      performanceScore: number
      trendScore: number
      assortmentScore: number
      priceScore: number
      overallScore: number
      riskLevel: string
      reasoning: string | null
      isSelected: boolean
      isRejected: boolean
      createdAt: Date
    }, ExtArgs["result"]["skuRecommendation"]>
    composites: {}
  }

  type SkuRecommendationGetPayload<S extends boolean | null | undefined | SkuRecommendationDefaultArgs> = $Result.GetResult<Prisma.$SkuRecommendationPayload, S>

  type SkuRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkuRecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkuRecommendationCountAggregateInputType | true
    }

  export interface SkuRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkuRecommendation'], meta: { name: 'SkuRecommendation' } }
    /**
     * Find zero or one SkuRecommendation that matches the filter.
     * @param {SkuRecommendationFindUniqueArgs} args - Arguments to find a SkuRecommendation
     * @example
     * // Get one SkuRecommendation
     * const skuRecommendation = await prisma.skuRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkuRecommendationFindUniqueArgs>(args: SelectSubset<T, SkuRecommendationFindUniqueArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SkuRecommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkuRecommendationFindUniqueOrThrowArgs} args - Arguments to find a SkuRecommendation
     * @example
     * // Get one SkuRecommendation
     * const skuRecommendation = await prisma.skuRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkuRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, SkuRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SkuRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationFindFirstArgs} args - Arguments to find a SkuRecommendation
     * @example
     * // Get one SkuRecommendation
     * const skuRecommendation = await prisma.skuRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkuRecommendationFindFirstArgs>(args?: SelectSubset<T, SkuRecommendationFindFirstArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SkuRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationFindFirstOrThrowArgs} args - Arguments to find a SkuRecommendation
     * @example
     * // Get one SkuRecommendation
     * const skuRecommendation = await prisma.skuRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkuRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, SkuRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SkuRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkuRecommendations
     * const skuRecommendations = await prisma.skuRecommendation.findMany()
     * 
     * // Get first 10 SkuRecommendations
     * const skuRecommendations = await prisma.skuRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skuRecommendationWithIdOnly = await prisma.skuRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkuRecommendationFindManyArgs>(args?: SelectSubset<T, SkuRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SkuRecommendation.
     * @param {SkuRecommendationCreateArgs} args - Arguments to create a SkuRecommendation.
     * @example
     * // Create one SkuRecommendation
     * const SkuRecommendation = await prisma.skuRecommendation.create({
     *   data: {
     *     // ... data to create a SkuRecommendation
     *   }
     * })
     * 
     */
    create<T extends SkuRecommendationCreateArgs>(args: SelectSubset<T, SkuRecommendationCreateArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SkuRecommendations.
     * @param {SkuRecommendationCreateManyArgs} args - Arguments to create many SkuRecommendations.
     * @example
     * // Create many SkuRecommendations
     * const skuRecommendation = await prisma.skuRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkuRecommendationCreateManyArgs>(args?: SelectSubset<T, SkuRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkuRecommendations and returns the data saved in the database.
     * @param {SkuRecommendationCreateManyAndReturnArgs} args - Arguments to create many SkuRecommendations.
     * @example
     * // Create many SkuRecommendations
     * const skuRecommendation = await prisma.skuRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkuRecommendations and only return the `id`
     * const skuRecommendationWithIdOnly = await prisma.skuRecommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkuRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, SkuRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SkuRecommendation.
     * @param {SkuRecommendationDeleteArgs} args - Arguments to delete one SkuRecommendation.
     * @example
     * // Delete one SkuRecommendation
     * const SkuRecommendation = await prisma.skuRecommendation.delete({
     *   where: {
     *     // ... filter to delete one SkuRecommendation
     *   }
     * })
     * 
     */
    delete<T extends SkuRecommendationDeleteArgs>(args: SelectSubset<T, SkuRecommendationDeleteArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SkuRecommendation.
     * @param {SkuRecommendationUpdateArgs} args - Arguments to update one SkuRecommendation.
     * @example
     * // Update one SkuRecommendation
     * const skuRecommendation = await prisma.skuRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkuRecommendationUpdateArgs>(args: SelectSubset<T, SkuRecommendationUpdateArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SkuRecommendations.
     * @param {SkuRecommendationDeleteManyArgs} args - Arguments to filter SkuRecommendations to delete.
     * @example
     * // Delete a few SkuRecommendations
     * const { count } = await prisma.skuRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkuRecommendationDeleteManyArgs>(args?: SelectSubset<T, SkuRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkuRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkuRecommendations
     * const skuRecommendation = await prisma.skuRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkuRecommendationUpdateManyArgs>(args: SelectSubset<T, SkuRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SkuRecommendation.
     * @param {SkuRecommendationUpsertArgs} args - Arguments to update or create a SkuRecommendation.
     * @example
     * // Update or create a SkuRecommendation
     * const skuRecommendation = await prisma.skuRecommendation.upsert({
     *   create: {
     *     // ... data to create a SkuRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkuRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends SkuRecommendationUpsertArgs>(args: SelectSubset<T, SkuRecommendationUpsertArgs<ExtArgs>>): Prisma__SkuRecommendationClient<$Result.GetResult<Prisma.$SkuRecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SkuRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationCountArgs} args - Arguments to filter SkuRecommendations to count.
     * @example
     * // Count the number of SkuRecommendations
     * const count = await prisma.skuRecommendation.count({
     *   where: {
     *     // ... the filter for the SkuRecommendations we want to count
     *   }
     * })
    **/
    count<T extends SkuRecommendationCountArgs>(
      args?: Subset<T, SkuRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkuRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkuRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkuRecommendationAggregateArgs>(args: Subset<T, SkuRecommendationAggregateArgs>): Prisma.PrismaPromise<GetSkuRecommendationAggregateType<T>>

    /**
     * Group by SkuRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkuRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkuRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkuRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: SkuRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkuRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkuRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkuRecommendation model
   */
  readonly fields: SkuRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkuRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkuRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budgetDetail<T extends BudgetDetailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BudgetDetailDefaultArgs<ExtArgs>>): Prisma__BudgetDetailClient<$Result.GetResult<Prisma.$BudgetDetailPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sku<T extends SkuCatalogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkuCatalogDefaultArgs<ExtArgs>>): Prisma__SkuCatalogClient<$Result.GetResult<Prisma.$SkuCatalogPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkuRecommendation model
   */ 
  interface SkuRecommendationFieldRefs {
    readonly id: FieldRef<"SkuRecommendation", 'String'>
    readonly budgetDetailId: FieldRef<"SkuRecommendation", 'String'>
    readonly category: FieldRef<"SkuRecommendation", 'String'>
    readonly subCategory: FieldRef<"SkuRecommendation", 'String'>
    readonly skuId: FieldRef<"SkuRecommendation", 'String'>
    readonly skuCode: FieldRef<"SkuRecommendation", 'String'>
    readonly productName: FieldRef<"SkuRecommendation", 'String'>
    readonly recommendedQty: FieldRef<"SkuRecommendation", 'Int'>
    readonly recommendedValue: FieldRef<"SkuRecommendation", 'Decimal'>
    readonly confidence: FieldRef<"SkuRecommendation", 'Decimal'>
    readonly performanceScore: FieldRef<"SkuRecommendation", 'Int'>
    readonly trendScore: FieldRef<"SkuRecommendation", 'Int'>
    readonly assortmentScore: FieldRef<"SkuRecommendation", 'Int'>
    readonly priceScore: FieldRef<"SkuRecommendation", 'Int'>
    readonly overallScore: FieldRef<"SkuRecommendation", 'Int'>
    readonly riskLevel: FieldRef<"SkuRecommendation", 'String'>
    readonly reasoning: FieldRef<"SkuRecommendation", 'String'>
    readonly isSelected: FieldRef<"SkuRecommendation", 'Boolean'>
    readonly isRejected: FieldRef<"SkuRecommendation", 'Boolean'>
    readonly createdAt: FieldRef<"SkuRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkuRecommendation findUnique
   */
  export type SkuRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuRecommendation to fetch.
     */
    where: SkuRecommendationWhereUniqueInput
  }

  /**
   * SkuRecommendation findUniqueOrThrow
   */
  export type SkuRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuRecommendation to fetch.
     */
    where: SkuRecommendationWhereUniqueInput
  }

  /**
   * SkuRecommendation findFirst
   */
  export type SkuRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuRecommendation to fetch.
     */
    where?: SkuRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuRecommendations to fetch.
     */
    orderBy?: SkuRecommendationOrderByWithRelationInput | SkuRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuRecommendations.
     */
    cursor?: SkuRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuRecommendations.
     */
    distinct?: SkuRecommendationScalarFieldEnum | SkuRecommendationScalarFieldEnum[]
  }

  /**
   * SkuRecommendation findFirstOrThrow
   */
  export type SkuRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuRecommendation to fetch.
     */
    where?: SkuRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuRecommendations to fetch.
     */
    orderBy?: SkuRecommendationOrderByWithRelationInput | SkuRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkuRecommendations.
     */
    cursor?: SkuRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkuRecommendations.
     */
    distinct?: SkuRecommendationScalarFieldEnum | SkuRecommendationScalarFieldEnum[]
  }

  /**
   * SkuRecommendation findMany
   */
  export type SkuRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which SkuRecommendations to fetch.
     */
    where?: SkuRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkuRecommendations to fetch.
     */
    orderBy?: SkuRecommendationOrderByWithRelationInput | SkuRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkuRecommendations.
     */
    cursor?: SkuRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkuRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkuRecommendations.
     */
    skip?: number
    distinct?: SkuRecommendationScalarFieldEnum | SkuRecommendationScalarFieldEnum[]
  }

  /**
   * SkuRecommendation create
   */
  export type SkuRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a SkuRecommendation.
     */
    data: XOR<SkuRecommendationCreateInput, SkuRecommendationUncheckedCreateInput>
  }

  /**
   * SkuRecommendation createMany
   */
  export type SkuRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkuRecommendations.
     */
    data: SkuRecommendationCreateManyInput | SkuRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkuRecommendation createManyAndReturn
   */
  export type SkuRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SkuRecommendations.
     */
    data: SkuRecommendationCreateManyInput | SkuRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkuRecommendation update
   */
  export type SkuRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a SkuRecommendation.
     */
    data: XOR<SkuRecommendationUpdateInput, SkuRecommendationUncheckedUpdateInput>
    /**
     * Choose, which SkuRecommendation to update.
     */
    where: SkuRecommendationWhereUniqueInput
  }

  /**
   * SkuRecommendation updateMany
   */
  export type SkuRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkuRecommendations.
     */
    data: XOR<SkuRecommendationUpdateManyMutationInput, SkuRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which SkuRecommendations to update
     */
    where?: SkuRecommendationWhereInput
  }

  /**
   * SkuRecommendation upsert
   */
  export type SkuRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the SkuRecommendation to update in case it exists.
     */
    where: SkuRecommendationWhereUniqueInput
    /**
     * In case the SkuRecommendation found by the `where` argument doesn't exist, create a new SkuRecommendation with this data.
     */
    create: XOR<SkuRecommendationCreateInput, SkuRecommendationUncheckedCreateInput>
    /**
     * In case the SkuRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkuRecommendationUpdateInput, SkuRecommendationUncheckedUpdateInput>
  }

  /**
   * SkuRecommendation delete
   */
  export type SkuRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
    /**
     * Filter which SkuRecommendation to delete.
     */
    where: SkuRecommendationWhereUniqueInput
  }

  /**
   * SkuRecommendation deleteMany
   */
  export type SkuRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkuRecommendations to delete
     */
    where?: SkuRecommendationWhereInput
  }

  /**
   * SkuRecommendation without action
   */
  export type SkuRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkuRecommendation
     */
    select?: SkuRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkuRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalWorkflowStep
   */

  export type AggregateApprovalWorkflowStep = {
    _count: ApprovalWorkflowStepCountAggregateOutputType | null
    _avg: ApprovalWorkflowStepAvgAggregateOutputType | null
    _sum: ApprovalWorkflowStepSumAggregateOutputType | null
    _min: ApprovalWorkflowStepMinAggregateOutputType | null
    _max: ApprovalWorkflowStepMaxAggregateOutputType | null
  }

  export type ApprovalWorkflowStepAvgAggregateOutputType = {
    stepNumber: number | null
  }

  export type ApprovalWorkflowStepSumAggregateOutputType = {
    stepNumber: number | null
  }

  export type ApprovalWorkflowStepMinAggregateOutputType = {
    id: string | null
    brandId: string | null
    stepNumber: number | null
    roleName: string | null
    roleCode: string | null
    userId: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalWorkflowStepMaxAggregateOutputType = {
    id: string | null
    brandId: string | null
    stepNumber: number | null
    roleName: string | null
    roleCode: string | null
    userId: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalWorkflowStepCountAggregateOutputType = {
    id: number
    brandId: number
    stepNumber: number
    roleName: number
    roleCode: number
    userId: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalWorkflowStepAvgAggregateInputType = {
    stepNumber?: true
  }

  export type ApprovalWorkflowStepSumAggregateInputType = {
    stepNumber?: true
  }

  export type ApprovalWorkflowStepMinAggregateInputType = {
    id?: true
    brandId?: true
    stepNumber?: true
    roleName?: true
    roleCode?: true
    userId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalWorkflowStepMaxAggregateInputType = {
    id?: true
    brandId?: true
    stepNumber?: true
    roleName?: true
    roleCode?: true
    userId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalWorkflowStepCountAggregateInputType = {
    id?: true
    brandId?: true
    stepNumber?: true
    roleName?: true
    roleCode?: true
    userId?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalWorkflowStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalWorkflowStep to aggregate.
     */
    where?: ApprovalWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflowSteps to fetch.
     */
    orderBy?: ApprovalWorkflowStepOrderByWithRelationInput | ApprovalWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalWorkflowSteps
    **/
    _count?: true | ApprovalWorkflowStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalWorkflowStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalWorkflowStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalWorkflowStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalWorkflowStepMaxAggregateInputType
  }

  export type GetApprovalWorkflowStepAggregateType<T extends ApprovalWorkflowStepAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalWorkflowStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalWorkflowStep[P]>
      : GetScalarType<T[P], AggregateApprovalWorkflowStep[P]>
  }




  export type ApprovalWorkflowStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWorkflowStepWhereInput
    orderBy?: ApprovalWorkflowStepOrderByWithAggregationInput | ApprovalWorkflowStepOrderByWithAggregationInput[]
    by: ApprovalWorkflowStepScalarFieldEnum[] | ApprovalWorkflowStepScalarFieldEnum
    having?: ApprovalWorkflowStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalWorkflowStepCountAggregateInputType | true
    _avg?: ApprovalWorkflowStepAvgAggregateInputType
    _sum?: ApprovalWorkflowStepSumAggregateInputType
    _min?: ApprovalWorkflowStepMinAggregateInputType
    _max?: ApprovalWorkflowStepMaxAggregateInputType
  }

  export type ApprovalWorkflowStepGroupByOutputType = {
    id: string
    brandId: string
    stepNumber: number
    roleName: string
    roleCode: string | null
    userId: string | null
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApprovalWorkflowStepCountAggregateOutputType | null
    _avg: ApprovalWorkflowStepAvgAggregateOutputType | null
    _sum: ApprovalWorkflowStepSumAggregateOutputType | null
    _min: ApprovalWorkflowStepMinAggregateOutputType | null
    _max: ApprovalWorkflowStepMaxAggregateOutputType | null
  }

  type GetApprovalWorkflowStepGroupByPayload<T extends ApprovalWorkflowStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalWorkflowStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalWorkflowStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalWorkflowStepGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalWorkflowStepGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalWorkflowStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    stepNumber?: boolean
    roleName?: boolean
    roleCode?: boolean
    userId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    user?: boolean | ApprovalWorkflowStep$userArgs<ExtArgs>
  }, ExtArgs["result"]["approvalWorkflowStep"]>

  export type ApprovalWorkflowStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    stepNumber?: boolean
    roleName?: boolean
    roleCode?: boolean
    userId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    user?: boolean | ApprovalWorkflowStep$userArgs<ExtArgs>
  }, ExtArgs["result"]["approvalWorkflowStep"]>

  export type ApprovalWorkflowStepSelectScalar = {
    id?: boolean
    brandId?: boolean
    stepNumber?: boolean
    roleName?: boolean
    roleCode?: boolean
    userId?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalWorkflowStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    user?: boolean | ApprovalWorkflowStep$userArgs<ExtArgs>
  }
  export type ApprovalWorkflowStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | GroupBrandDefaultArgs<ExtArgs>
    user?: boolean | ApprovalWorkflowStep$userArgs<ExtArgs>
  }

  export type $ApprovalWorkflowStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalWorkflowStep"
    objects: {
      brand: Prisma.$GroupBrandPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      brandId: string
      stepNumber: number
      roleName: string
      roleCode: string | null
      userId: string | null
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalWorkflowStep"]>
    composites: {}
  }

  type ApprovalWorkflowStepGetPayload<S extends boolean | null | undefined | ApprovalWorkflowStepDefaultArgs> = $Result.GetResult<Prisma.$ApprovalWorkflowStepPayload, S>

  type ApprovalWorkflowStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalWorkflowStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalWorkflowStepCountAggregateInputType | true
    }

  export interface ApprovalWorkflowStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalWorkflowStep'], meta: { name: 'ApprovalWorkflowStep' } }
    /**
     * Find zero or one ApprovalWorkflowStep that matches the filter.
     * @param {ApprovalWorkflowStepFindUniqueArgs} args - Arguments to find a ApprovalWorkflowStep
     * @example
     * // Get one ApprovalWorkflowStep
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalWorkflowStepFindUniqueArgs>(args: SelectSubset<T, ApprovalWorkflowStepFindUniqueArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalWorkflowStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalWorkflowStepFindUniqueOrThrowArgs} args - Arguments to find a ApprovalWorkflowStep
     * @example
     * // Get one ApprovalWorkflowStep
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalWorkflowStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalWorkflowStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalWorkflowStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepFindFirstArgs} args - Arguments to find a ApprovalWorkflowStep
     * @example
     * // Get one ApprovalWorkflowStep
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalWorkflowStepFindFirstArgs>(args?: SelectSubset<T, ApprovalWorkflowStepFindFirstArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalWorkflowStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepFindFirstOrThrowArgs} args - Arguments to find a ApprovalWorkflowStep
     * @example
     * // Get one ApprovalWorkflowStep
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalWorkflowStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalWorkflowStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalWorkflowSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalWorkflowSteps
     * const approvalWorkflowSteps = await prisma.approvalWorkflowStep.findMany()
     * 
     * // Get first 10 ApprovalWorkflowSteps
     * const approvalWorkflowSteps = await prisma.approvalWorkflowStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWorkflowStepWithIdOnly = await prisma.approvalWorkflowStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalWorkflowStepFindManyArgs>(args?: SelectSubset<T, ApprovalWorkflowStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalWorkflowStep.
     * @param {ApprovalWorkflowStepCreateArgs} args - Arguments to create a ApprovalWorkflowStep.
     * @example
     * // Create one ApprovalWorkflowStep
     * const ApprovalWorkflowStep = await prisma.approvalWorkflowStep.create({
     *   data: {
     *     // ... data to create a ApprovalWorkflowStep
     *   }
     * })
     * 
     */
    create<T extends ApprovalWorkflowStepCreateArgs>(args: SelectSubset<T, ApprovalWorkflowStepCreateArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalWorkflowSteps.
     * @param {ApprovalWorkflowStepCreateManyArgs} args - Arguments to create many ApprovalWorkflowSteps.
     * @example
     * // Create many ApprovalWorkflowSteps
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalWorkflowStepCreateManyArgs>(args?: SelectSubset<T, ApprovalWorkflowStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalWorkflowSteps and returns the data saved in the database.
     * @param {ApprovalWorkflowStepCreateManyAndReturnArgs} args - Arguments to create many ApprovalWorkflowSteps.
     * @example
     * // Create many ApprovalWorkflowSteps
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalWorkflowSteps and only return the `id`
     * const approvalWorkflowStepWithIdOnly = await prisma.approvalWorkflowStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalWorkflowStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalWorkflowStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalWorkflowStep.
     * @param {ApprovalWorkflowStepDeleteArgs} args - Arguments to delete one ApprovalWorkflowStep.
     * @example
     * // Delete one ApprovalWorkflowStep
     * const ApprovalWorkflowStep = await prisma.approvalWorkflowStep.delete({
     *   where: {
     *     // ... filter to delete one ApprovalWorkflowStep
     *   }
     * })
     * 
     */
    delete<T extends ApprovalWorkflowStepDeleteArgs>(args: SelectSubset<T, ApprovalWorkflowStepDeleteArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalWorkflowStep.
     * @param {ApprovalWorkflowStepUpdateArgs} args - Arguments to update one ApprovalWorkflowStep.
     * @example
     * // Update one ApprovalWorkflowStep
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalWorkflowStepUpdateArgs>(args: SelectSubset<T, ApprovalWorkflowStepUpdateArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalWorkflowSteps.
     * @param {ApprovalWorkflowStepDeleteManyArgs} args - Arguments to filter ApprovalWorkflowSteps to delete.
     * @example
     * // Delete a few ApprovalWorkflowSteps
     * const { count } = await prisma.approvalWorkflowStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalWorkflowStepDeleteManyArgs>(args?: SelectSubset<T, ApprovalWorkflowStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalWorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalWorkflowSteps
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalWorkflowStepUpdateManyArgs>(args: SelectSubset<T, ApprovalWorkflowStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalWorkflowStep.
     * @param {ApprovalWorkflowStepUpsertArgs} args - Arguments to update or create a ApprovalWorkflowStep.
     * @example
     * // Update or create a ApprovalWorkflowStep
     * const approvalWorkflowStep = await prisma.approvalWorkflowStep.upsert({
     *   create: {
     *     // ... data to create a ApprovalWorkflowStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalWorkflowStep we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalWorkflowStepUpsertArgs>(args: SelectSubset<T, ApprovalWorkflowStepUpsertArgs<ExtArgs>>): Prisma__ApprovalWorkflowStepClient<$Result.GetResult<Prisma.$ApprovalWorkflowStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalWorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepCountArgs} args - Arguments to filter ApprovalWorkflowSteps to count.
     * @example
     * // Count the number of ApprovalWorkflowSteps
     * const count = await prisma.approvalWorkflowStep.count({
     *   where: {
     *     // ... the filter for the ApprovalWorkflowSteps we want to count
     *   }
     * })
    **/
    count<T extends ApprovalWorkflowStepCountArgs>(
      args?: Subset<T, ApprovalWorkflowStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalWorkflowStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalWorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalWorkflowStepAggregateArgs>(args: Subset<T, ApprovalWorkflowStepAggregateArgs>): Prisma.PrismaPromise<GetApprovalWorkflowStepAggregateType<T>>

    /**
     * Group by ApprovalWorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalWorkflowStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalWorkflowStepGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalWorkflowStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalWorkflowStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalWorkflowStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalWorkflowStep model
   */
  readonly fields: ApprovalWorkflowStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalWorkflowStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalWorkflowStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends GroupBrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupBrandDefaultArgs<ExtArgs>>): Prisma__GroupBrandClient<$Result.GetResult<Prisma.$GroupBrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends ApprovalWorkflowStep$userArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalWorkflowStep$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalWorkflowStep model
   */ 
  interface ApprovalWorkflowStepFieldRefs {
    readonly id: FieldRef<"ApprovalWorkflowStep", 'String'>
    readonly brandId: FieldRef<"ApprovalWorkflowStep", 'String'>
    readonly stepNumber: FieldRef<"ApprovalWorkflowStep", 'Int'>
    readonly roleName: FieldRef<"ApprovalWorkflowStep", 'String'>
    readonly roleCode: FieldRef<"ApprovalWorkflowStep", 'String'>
    readonly userId: FieldRef<"ApprovalWorkflowStep", 'String'>
    readonly description: FieldRef<"ApprovalWorkflowStep", 'String'>
    readonly isActive: FieldRef<"ApprovalWorkflowStep", 'Boolean'>
    readonly createdAt: FieldRef<"ApprovalWorkflowStep", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalWorkflowStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalWorkflowStep findUnique
   */
  export type ApprovalWorkflowStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflowStep to fetch.
     */
    where: ApprovalWorkflowStepWhereUniqueInput
  }

  /**
   * ApprovalWorkflowStep findUniqueOrThrow
   */
  export type ApprovalWorkflowStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflowStep to fetch.
     */
    where: ApprovalWorkflowStepWhereUniqueInput
  }

  /**
   * ApprovalWorkflowStep findFirst
   */
  export type ApprovalWorkflowStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflowStep to fetch.
     */
    where?: ApprovalWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflowSteps to fetch.
     */
    orderBy?: ApprovalWorkflowStepOrderByWithRelationInput | ApprovalWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalWorkflowSteps.
     */
    cursor?: ApprovalWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalWorkflowSteps.
     */
    distinct?: ApprovalWorkflowStepScalarFieldEnum | ApprovalWorkflowStepScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflowStep findFirstOrThrow
   */
  export type ApprovalWorkflowStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflowStep to fetch.
     */
    where?: ApprovalWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflowSteps to fetch.
     */
    orderBy?: ApprovalWorkflowStepOrderByWithRelationInput | ApprovalWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalWorkflowSteps.
     */
    cursor?: ApprovalWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalWorkflowSteps.
     */
    distinct?: ApprovalWorkflowStepScalarFieldEnum | ApprovalWorkflowStepScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflowStep findMany
   */
  export type ApprovalWorkflowStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflowSteps to fetch.
     */
    where?: ApprovalWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflowSteps to fetch.
     */
    orderBy?: ApprovalWorkflowStepOrderByWithRelationInput | ApprovalWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalWorkflowSteps.
     */
    cursor?: ApprovalWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflowSteps.
     */
    skip?: number
    distinct?: ApprovalWorkflowStepScalarFieldEnum | ApprovalWorkflowStepScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflowStep create
   */
  export type ApprovalWorkflowStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalWorkflowStep.
     */
    data: XOR<ApprovalWorkflowStepCreateInput, ApprovalWorkflowStepUncheckedCreateInput>
  }

  /**
   * ApprovalWorkflowStep createMany
   */
  export type ApprovalWorkflowStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalWorkflowSteps.
     */
    data: ApprovalWorkflowStepCreateManyInput | ApprovalWorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalWorkflowStep createManyAndReturn
   */
  export type ApprovalWorkflowStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalWorkflowSteps.
     */
    data: ApprovalWorkflowStepCreateManyInput | ApprovalWorkflowStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalWorkflowStep update
   */
  export type ApprovalWorkflowStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalWorkflowStep.
     */
    data: XOR<ApprovalWorkflowStepUpdateInput, ApprovalWorkflowStepUncheckedUpdateInput>
    /**
     * Choose, which ApprovalWorkflowStep to update.
     */
    where: ApprovalWorkflowStepWhereUniqueInput
  }

  /**
   * ApprovalWorkflowStep updateMany
   */
  export type ApprovalWorkflowStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalWorkflowSteps.
     */
    data: XOR<ApprovalWorkflowStepUpdateManyMutationInput, ApprovalWorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalWorkflowSteps to update
     */
    where?: ApprovalWorkflowStepWhereInput
  }

  /**
   * ApprovalWorkflowStep upsert
   */
  export type ApprovalWorkflowStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalWorkflowStep to update in case it exists.
     */
    where: ApprovalWorkflowStepWhereUniqueInput
    /**
     * In case the ApprovalWorkflowStep found by the `where` argument doesn't exist, create a new ApprovalWorkflowStep with this data.
     */
    create: XOR<ApprovalWorkflowStepCreateInput, ApprovalWorkflowStepUncheckedCreateInput>
    /**
     * In case the ApprovalWorkflowStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalWorkflowStepUpdateInput, ApprovalWorkflowStepUncheckedUpdateInput>
  }

  /**
   * ApprovalWorkflowStep delete
   */
  export type ApprovalWorkflowStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter which ApprovalWorkflowStep to delete.
     */
    where: ApprovalWorkflowStepWhereUniqueInput
  }

  /**
   * ApprovalWorkflowStep deleteMany
   */
  export type ApprovalWorkflowStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalWorkflowSteps to delete
     */
    where?: ApprovalWorkflowStepWhereInput
  }

  /**
   * ApprovalWorkflowStep.user
   */
  export type ApprovalWorkflowStep$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ApprovalWorkflowStep without action
   */
  export type ApprovalWorkflowStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflowStep
     */
    select?: ApprovalWorkflowStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowStepInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    roleId: 'roleId',
    storeAccess: 'storeAccess',
    brandAccess: 'brandAccess',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const GroupBrandScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    groupId: 'groupId',
    colorConfig: 'colorConfig',
    isActive: 'isActive',
    sortOrder: 'sortOrder'
  };

  export type GroupBrandScalarFieldEnum = (typeof GroupBrandScalarFieldEnum)[keyof typeof GroupBrandScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    region: 'region',
    isActive: 'isActive'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const CollectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export const GenderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive'
  };

  export type GenderScalarFieldEnum = (typeof GenderScalarFieldEnum)[keyof typeof GenderScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genderId: 'genderId',
    isActive: 'isActive'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId',
    isActive: 'isActive'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const SkuCatalogScalarFieldEnum: {
    id: 'id',
    skuCode: 'skuCode',
    productName: 'productName',
    productType: 'productType',
    theme: 'theme',
    color: 'color',
    composition: 'composition',
    srp: 'srp',
    brandId: 'brandId',
    seasonGroupId: 'seasonGroupId',
    imageUrl: 'imageUrl',
    isActive: 'isActive'
  };

  export type SkuCatalogScalarFieldEnum = (typeof SkuCatalogScalarFieldEnum)[keyof typeof SkuCatalogScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    budgetCode: 'budgetCode',
    groupBrandId: 'groupBrandId',
    seasonGroupId: 'seasonGroupId',
    seasonType: 'seasonType',
    fiscalYear: 'fiscalYear',
    totalBudget: 'totalBudget',
    status: 'status',
    comment: 'comment',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const BudgetDetailScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    storeId: 'storeId',
    budgetAmount: 'budgetAmount'
  };

  export type BudgetDetailScalarFieldEnum = (typeof BudgetDetailScalarFieldEnum)[keyof typeof BudgetDetailScalarFieldEnum]


  export const PlanningVersionScalarFieldEnum: {
    id: 'id',
    planningCode: 'planningCode',
    budgetDetailId: 'budgetDetailId',
    versionNumber: 'versionNumber',
    versionName: 'versionName',
    status: 'status',
    isFinal: 'isFinal',
    snapshotData: 'snapshotData',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanningVersionScalarFieldEnum = (typeof PlanningVersionScalarFieldEnum)[keyof typeof PlanningVersionScalarFieldEnum]


  export const PlanningDetailScalarFieldEnum: {
    id: 'id',
    planningVersionId: 'planningVersionId',
    dimensionType: 'dimensionType',
    collectionId: 'collectionId',
    genderId: 'genderId',
    categoryId: 'categoryId',
    subCategoryId: 'subCategoryId',
    lastSeasonSales: 'lastSeasonSales',
    lastSeasonPct: 'lastSeasonPct',
    systemBuyPct: 'systemBuyPct',
    userBuyPct: 'userBuyPct',
    otbValue: 'otbValue',
    variancePct: 'variancePct',
    userComment: 'userComment'
  };

  export type PlanningDetailScalarFieldEnum = (typeof PlanningDetailScalarFieldEnum)[keyof typeof PlanningDetailScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    ticketName: 'ticketName',
    budgetId: 'budgetId',
    planningVersionId: 'planningVersionId',
    status: 'status',
    totalSkuCount: 'totalSkuCount',
    totalOrderQty: 'totalOrderQty',
    totalValue: 'totalValue',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const ProposalProductScalarFieldEnum: {
    id: 'id',
    proposalId: 'proposalId',
    skuId: 'skuId',
    skuCode: 'skuCode',
    productName: 'productName',
    collection: 'collection',
    gender: 'gender',
    category: 'category',
    subCategory: 'subCategory',
    theme: 'theme',
    color: 'color',
    composition: 'composition',
    unitCost: 'unitCost',
    srp: 'srp',
    orderQty: 'orderQty',
    totalValue: 'totalValue',
    customerTarget: 'customerTarget',
    imageUrl: 'imageUrl',
    sortOrder: 'sortOrder'
  };

  export type ProposalProductScalarFieldEnum = (typeof ProposalProductScalarFieldEnum)[keyof typeof ProposalProductScalarFieldEnum]


  export const ProductAllocationScalarFieldEnum: {
    id: 'id',
    proposalProductId: 'proposalProductId',
    storeId: 'storeId',
    quantity: 'quantity'
  };

  export type ProductAllocationScalarFieldEnum = (typeof ProductAllocationScalarFieldEnum)[keyof typeof ProductAllocationScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    level: 'level',
    deciderId: 'deciderId',
    action: 'action',
    comment: 'comment',
    decidedAt: 'decidedAt'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    changes: 'changes',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SalesHistoryScalarFieldEnum: {
    id: 'id',
    skuCode: 'skuCode',
    storeId: 'storeId',
    sizeCode: 'sizeCode',
    season: 'season',
    quantitySold: 'quantitySold',
    quantityBought: 'quantityBought',
    sellThroughPct: 'sellThroughPct',
    createdAt: 'createdAt'
  };

  export type SalesHistoryScalarFieldEnum = (typeof SalesHistoryScalarFieldEnum)[keyof typeof SalesHistoryScalarFieldEnum]


  export const SizeCurveRecommendationScalarFieldEnum: {
    id: 'id',
    skuId: 'skuId',
    storeId: 'storeId',
    category: 'category',
    sizeCode: 'sizeCode',
    recommendedPct: 'recommendedPct',
    confidence: 'confidence',
    basedOnSeasons: 'basedOnSeasons',
    reasoning: 'reasoning',
    createdAt: 'createdAt'
  };

  export type SizeCurveRecommendationScalarFieldEnum = (typeof SizeCurveRecommendationScalarFieldEnum)[keyof typeof SizeCurveRecommendationScalarFieldEnum]


  export const BudgetAlertScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    alertType: 'alertType',
    severity: 'severity',
    title: 'title',
    message: 'message',
    metricValue: 'metricValue',
    threshold: 'threshold',
    category: 'category',
    isRead: 'isRead',
    isDismissed: 'isDismissed',
    createdAt: 'createdAt'
  };

  export type BudgetAlertScalarFieldEnum = (typeof BudgetAlertScalarFieldEnum)[keyof typeof BudgetAlertScalarFieldEnum]


  export const BudgetSnapshotScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    snapshotDate: 'snapshotDate',
    totalCommitted: 'totalCommitted',
    totalPlanned: 'totalPlanned',
    utilizationPct: 'utilizationPct'
  };

  export type BudgetSnapshotScalarFieldEnum = (typeof BudgetSnapshotScalarFieldEnum)[keyof typeof BudgetSnapshotScalarFieldEnum]


  export const AllocationHistoryScalarFieldEnum: {
    id: 'id',
    budgetId: 'budgetId',
    seasonGroup: 'seasonGroup',
    seasonType: 'seasonType',
    fiscalYear: 'fiscalYear',
    dimensionType: 'dimensionType',
    dimensionValue: 'dimensionValue',
    allocatedPct: 'allocatedPct',
    allocatedAmount: 'allocatedAmount',
    actualSales: 'actualSales',
    sellThroughPct: 'sellThroughPct',
    createdAt: 'createdAt'
  };

  export type AllocationHistoryScalarFieldEnum = (typeof AllocationHistoryScalarFieldEnum)[keyof typeof AllocationHistoryScalarFieldEnum]


  export const AllocationRecommendationScalarFieldEnum: {
    id: 'id',
    budgetDetailId: 'budgetDetailId',
    dimensionType: 'dimensionType',
    dimensionValue: 'dimensionValue',
    recommendedPct: 'recommendedPct',
    recommendedAmt: 'recommendedAmt',
    confidence: 'confidence',
    reasoning: 'reasoning',
    basedOnSeasons: 'basedOnSeasons',
    factors: 'factors',
    isApplied: 'isApplied',
    createdAt: 'createdAt'
  };

  export type AllocationRecommendationScalarFieldEnum = (typeof AllocationRecommendationScalarFieldEnum)[keyof typeof AllocationRecommendationScalarFieldEnum]


  export const RiskAssessmentScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    overallScore: 'overallScore',
    riskLevel: 'riskLevel',
    budgetAlignmentScore: 'budgetAlignmentScore',
    skuDiversityScore: 'skuDiversityScore',
    sizeCurveScore: 'sizeCurveScore',
    vendorConcentrationScore: 'vendorConcentrationScore',
    categoryBalanceScore: 'categoryBalanceScore',
    marginImpactScore: 'marginImpactScore',
    factors: 'factors',
    warnings: 'warnings',
    recommendation: 'recommendation',
    calculatedAt: 'calculatedAt',
    calculatedBy: 'calculatedBy',
    isStale: 'isStale'
  };

  export type RiskAssessmentScalarFieldEnum = (typeof RiskAssessmentScalarFieldEnum)[keyof typeof RiskAssessmentScalarFieldEnum]


  export const RiskThresholdScalarFieldEnum: {
    id: 'id',
    factorName: 'factorName',
    weight: 'weight',
    lowThreshold: 'lowThreshold',
    highThreshold: 'highThreshold',
    description: 'description',
    isActive: 'isActive'
  };

  export type RiskThresholdScalarFieldEnum = (typeof RiskThresholdScalarFieldEnum)[keyof typeof RiskThresholdScalarFieldEnum]


  export const SkuPerformanceScalarFieldEnum: {
    id: 'id',
    skuId: 'skuId',
    skuCode: 'skuCode',
    seasonGroup: 'seasonGroup',
    fiscalYear: 'fiscalYear',
    storeId: 'storeId',
    quantityBought: 'quantityBought',
    quantitySold: 'quantitySold',
    sellThroughPct: 'sellThroughPct',
    avgSellingPrice: 'avgSellingPrice',
    totalRevenue: 'totalRevenue',
    grossMarginPct: 'grossMarginPct',
    markdownPct: 'markdownPct',
    weeksToSellThru: 'weeksToSellThru',
    performanceScore: 'performanceScore',
    velocityScore: 'velocityScore',
    marginScore: 'marginScore',
    createdAt: 'createdAt'
  };

  export type SkuPerformanceScalarFieldEnum = (typeof SkuPerformanceScalarFieldEnum)[keyof typeof SkuPerformanceScalarFieldEnum]


  export const AttributeTrendScalarFieldEnum: {
    id: 'id',
    attributeType: 'attributeType',
    attributeValue: 'attributeValue',
    category: 'category',
    seasonGroup: 'seasonGroup',
    fiscalYear: 'fiscalYear',
    totalSkus: 'totalSkus',
    avgSellThrough: 'avgSellThrough',
    avgMargin: 'avgMargin',
    trendScore: 'trendScore',
    yoyGrowth: 'yoyGrowth',
    createdAt: 'createdAt'
  };

  export type AttributeTrendScalarFieldEnum = (typeof AttributeTrendScalarFieldEnum)[keyof typeof AttributeTrendScalarFieldEnum]


  export const SkuRecommendationScalarFieldEnum: {
    id: 'id',
    budgetDetailId: 'budgetDetailId',
    category: 'category',
    subCategory: 'subCategory',
    skuId: 'skuId',
    skuCode: 'skuCode',
    productName: 'productName',
    recommendedQty: 'recommendedQty',
    recommendedValue: 'recommendedValue',
    confidence: 'confidence',
    performanceScore: 'performanceScore',
    trendScore: 'trendScore',
    assortmentScore: 'assortmentScore',
    priceScore: 'priceScore',
    overallScore: 'overallScore',
    riskLevel: 'riskLevel',
    reasoning: 'reasoning',
    isSelected: 'isSelected',
    isRejected: 'isRejected',
    createdAt: 'createdAt'
  };

  export type SkuRecommendationScalarFieldEnum = (typeof SkuRecommendationScalarFieldEnum)[keyof typeof SkuRecommendationScalarFieldEnum]


  export const ApprovalWorkflowStepScalarFieldEnum: {
    id: 'id',
    brandId: 'brandId',
    stepNumber: 'stepNumber',
    roleName: 'roleName',
    roleCode: 'roleCode',
    userId: 'userId',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalWorkflowStepScalarFieldEnum = (typeof ApprovalWorkflowStepScalarFieldEnum)[keyof typeof ApprovalWorkflowStepScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BudgetStatus'
   */
  export type EnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus'>
    


  /**
   * Reference to a field of type 'BudgetStatus[]'
   */
  export type ListEnumBudgetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetStatus[]'>
    


  /**
   * Reference to a field of type 'PlanningStatus'
   */
  export type EnumPlanningStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanningStatus'>
    


  /**
   * Reference to a field of type 'PlanningStatus[]'
   */
  export type ListEnumPlanningStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanningStatus[]'>
    


  /**
   * Reference to a field of type 'ProposalStatus'
   */
  export type EnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus'>
    


  /**
   * Reference to a field of type 'ProposalStatus[]'
   */
  export type ListEnumProposalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProposalStatus[]'>
    


  /**
   * Reference to a field of type 'ApprovalAction'
   */
  export type EnumApprovalActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalAction'>
    


  /**
   * Reference to a field of type 'ApprovalAction[]'
   */
  export type ListEnumApprovalActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalAction[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    storeAccess?: StringNullableListFilter<"User">
    brandAccess?: StringNullableListFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    createdBudgets?: BudgetListRelationFilter
    createdPlannings?: PlanningVersionListRelationFilter
    createdProposals?: ProposalListRelationFilter
    approvalDecisions?: ApprovalListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    workflowSteps?: ApprovalWorkflowStepListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    storeAccess?: SortOrder
    brandAccess?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    createdBudgets?: BudgetOrderByRelationAggregateInput
    createdPlannings?: PlanningVersionOrderByRelationAggregateInput
    createdProposals?: ProposalOrderByRelationAggregateInput
    approvalDecisions?: ApprovalOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    workflowSteps?: ApprovalWorkflowStepOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    storeAccess?: StringNullableListFilter<"User">
    brandAccess?: StringNullableListFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    createdBudgets?: BudgetListRelationFilter
    createdPlannings?: PlanningVersionListRelationFilter
    createdProposals?: ProposalListRelationFilter
    approvalDecisions?: ApprovalListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    workflowSteps?: ApprovalWorkflowStepListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    storeAccess?: SortOrder
    brandAccess?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    roleId?: StringWithAggregatesFilter<"User"> | string
    storeAccess?: StringNullableListFilter<"User">
    brandAccess?: StringNullableListFilter<"User">
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: JsonFilter<"Role">
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: JsonFilter<"Role">
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    permissions?: JsonWithAggregatesFilter<"Role">
  }

  export type GroupBrandWhereInput = {
    AND?: GroupBrandWhereInput | GroupBrandWhereInput[]
    OR?: GroupBrandWhereInput[]
    NOT?: GroupBrandWhereInput | GroupBrandWhereInput[]
    id?: StringFilter<"GroupBrand"> | string
    code?: StringFilter<"GroupBrand"> | string
    name?: StringFilter<"GroupBrand"> | string
    groupId?: StringFilter<"GroupBrand"> | string
    colorConfig?: JsonNullableFilter<"GroupBrand">
    isActive?: BoolFilter<"GroupBrand"> | boolean
    sortOrder?: IntFilter<"GroupBrand"> | number
    budgets?: BudgetListRelationFilter
    skuCatalog?: SkuCatalogListRelationFilter
    workflowSteps?: ApprovalWorkflowStepListRelationFilter
  }

  export type GroupBrandOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    colorConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    budgets?: BudgetOrderByRelationAggregateInput
    skuCatalog?: SkuCatalogOrderByRelationAggregateInput
    workflowSteps?: ApprovalWorkflowStepOrderByRelationAggregateInput
  }

  export type GroupBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: GroupBrandWhereInput | GroupBrandWhereInput[]
    OR?: GroupBrandWhereInput[]
    NOT?: GroupBrandWhereInput | GroupBrandWhereInput[]
    name?: StringFilter<"GroupBrand"> | string
    groupId?: StringFilter<"GroupBrand"> | string
    colorConfig?: JsonNullableFilter<"GroupBrand">
    isActive?: BoolFilter<"GroupBrand"> | boolean
    sortOrder?: IntFilter<"GroupBrand"> | number
    budgets?: BudgetListRelationFilter
    skuCatalog?: SkuCatalogListRelationFilter
    workflowSteps?: ApprovalWorkflowStepListRelationFilter
  }, "id" | "code">

  export type GroupBrandOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    colorConfig?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    _count?: GroupBrandCountOrderByAggregateInput
    _avg?: GroupBrandAvgOrderByAggregateInput
    _max?: GroupBrandMaxOrderByAggregateInput
    _min?: GroupBrandMinOrderByAggregateInput
    _sum?: GroupBrandSumOrderByAggregateInput
  }

  export type GroupBrandScalarWhereWithAggregatesInput = {
    AND?: GroupBrandScalarWhereWithAggregatesInput | GroupBrandScalarWhereWithAggregatesInput[]
    OR?: GroupBrandScalarWhereWithAggregatesInput[]
    NOT?: GroupBrandScalarWhereWithAggregatesInput | GroupBrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupBrand"> | string
    code?: StringWithAggregatesFilter<"GroupBrand"> | string
    name?: StringWithAggregatesFilter<"GroupBrand"> | string
    groupId?: StringWithAggregatesFilter<"GroupBrand"> | string
    colorConfig?: JsonNullableWithAggregatesFilter<"GroupBrand">
    isActive?: BoolWithAggregatesFilter<"GroupBrand"> | boolean
    sortOrder?: IntWithAggregatesFilter<"GroupBrand"> | number
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    code?: StringFilter<"Store"> | string
    name?: StringFilter<"Store"> | string
    region?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    budgetDetails?: BudgetDetailListRelationFilter
    productAllocations?: ProductAllocationListRelationFilter
    salesHistory?: SalesHistoryListRelationFilter
    sizeCurveRecommendations?: SizeCurveRecommendationListRelationFilter
    skuPerformance?: SkuPerformanceListRelationFilter
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    budgetDetails?: BudgetDetailOrderByRelationAggregateInput
    productAllocations?: ProductAllocationOrderByRelationAggregateInput
    salesHistory?: SalesHistoryOrderByRelationAggregateInput
    sizeCurveRecommendations?: SizeCurveRecommendationOrderByRelationAggregateInput
    skuPerformance?: SkuPerformanceOrderByRelationAggregateInput
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    name?: StringFilter<"Store"> | string
    region?: StringNullableFilter<"Store"> | string | null
    isActive?: BoolFilter<"Store"> | boolean
    budgetDetails?: BudgetDetailListRelationFilter
    productAllocations?: ProductAllocationListRelationFilter
    salesHistory?: SalesHistoryListRelationFilter
    sizeCurveRecommendations?: SizeCurveRecommendationListRelationFilter
    skuPerformance?: SkuPerformanceListRelationFilter
  }, "id" | "code">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    region?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    code?: StringWithAggregatesFilter<"Store"> | string
    name?: StringWithAggregatesFilter<"Store"> | string
    region?: StringNullableWithAggregatesFilter<"Store"> | string | null
    isActive?: BoolWithAggregatesFilter<"Store"> | boolean
  }

  export type CollectionWhereInput = {
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    id?: StringFilter<"Collection"> | string
    name?: StringFilter<"Collection"> | string
    isActive?: BoolFilter<"Collection"> | boolean
    planningDetails?: PlanningDetailListRelationFilter
  }

  export type CollectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    planningDetails?: PlanningDetailOrderByRelationAggregateInput
  }

  export type CollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    isActive?: BoolFilter<"Collection"> | boolean
    planningDetails?: PlanningDetailListRelationFilter
  }, "id" | "name">

  export type CollectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    _count?: CollectionCountOrderByAggregateInput
    _max?: CollectionMaxOrderByAggregateInput
    _min?: CollectionMinOrderByAggregateInput
  }

  export type CollectionScalarWhereWithAggregatesInput = {
    AND?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    OR?: CollectionScalarWhereWithAggregatesInput[]
    NOT?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Collection"> | string
    name?: StringWithAggregatesFilter<"Collection"> | string
    isActive?: BoolWithAggregatesFilter<"Collection"> | boolean
  }

  export type GenderWhereInput = {
    AND?: GenderWhereInput | GenderWhereInput[]
    OR?: GenderWhereInput[]
    NOT?: GenderWhereInput | GenderWhereInput[]
    id?: StringFilter<"Gender"> | string
    name?: StringFilter<"Gender"> | string
    isActive?: BoolFilter<"Gender"> | boolean
    categories?: CategoryListRelationFilter
    planningDetails?: PlanningDetailListRelationFilter
  }

  export type GenderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
    planningDetails?: PlanningDetailOrderByRelationAggregateInput
  }

  export type GenderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: GenderWhereInput | GenderWhereInput[]
    OR?: GenderWhereInput[]
    NOT?: GenderWhereInput | GenderWhereInput[]
    isActive?: BoolFilter<"Gender"> | boolean
    categories?: CategoryListRelationFilter
    planningDetails?: PlanningDetailListRelationFilter
  }, "id" | "name">

  export type GenderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    _count?: GenderCountOrderByAggregateInput
    _max?: GenderMaxOrderByAggregateInput
    _min?: GenderMinOrderByAggregateInput
  }

  export type GenderScalarWhereWithAggregatesInput = {
    AND?: GenderScalarWhereWithAggregatesInput | GenderScalarWhereWithAggregatesInput[]
    OR?: GenderScalarWhereWithAggregatesInput[]
    NOT?: GenderScalarWhereWithAggregatesInput | GenderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gender"> | string
    name?: StringWithAggregatesFilter<"Gender"> | string
    isActive?: BoolWithAggregatesFilter<"Gender"> | boolean
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    genderId?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
    gender?: XOR<GenderRelationFilter, GenderWhereInput>
    subCategories?: SubCategoryListRelationFilter
    planningDetails?: PlanningDetailListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    gender?: GenderOrderByWithRelationInput
    subCategories?: SubCategoryOrderByRelationAggregateInput
    planningDetails?: PlanningDetailOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    genderId?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
    gender?: XOR<GenderRelationFilter, GenderWhereInput>
    subCategories?: SubCategoryListRelationFilter
    planningDetails?: PlanningDetailListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    genderId?: StringWithAggregatesFilter<"Category"> | string
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
  }

  export type SubCategoryWhereInput = {
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    id?: StringFilter<"SubCategory"> | string
    name?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    isActive?: BoolFilter<"SubCategory"> | boolean
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    planningDetails?: PlanningDetailListRelationFilter
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    isActive?: SortOrder
    category?: CategoryOrderByWithRelationInput
    planningDetails?: PlanningDetailOrderByRelationAggregateInput
  }

  export type SubCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubCategoryWhereInput | SubCategoryWhereInput[]
    OR?: SubCategoryWhereInput[]
    NOT?: SubCategoryWhereInput | SubCategoryWhereInput[]
    name?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    isActive?: BoolFilter<"SubCategory"> | boolean
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    planningDetails?: PlanningDetailListRelationFilter
  }, "id">

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    isActive?: SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    OR?: SubCategoryScalarWhereWithAggregatesInput[]
    NOT?: SubCategoryScalarWhereWithAggregatesInput | SubCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubCategory"> | string
    name?: StringWithAggregatesFilter<"SubCategory"> | string
    categoryId?: StringWithAggregatesFilter<"SubCategory"> | string
    isActive?: BoolWithAggregatesFilter<"SubCategory"> | boolean
  }

  export type SkuCatalogWhereInput = {
    AND?: SkuCatalogWhereInput | SkuCatalogWhereInput[]
    OR?: SkuCatalogWhereInput[]
    NOT?: SkuCatalogWhereInput | SkuCatalogWhereInput[]
    id?: StringFilter<"SkuCatalog"> | string
    skuCode?: StringFilter<"SkuCatalog"> | string
    productName?: StringFilter<"SkuCatalog"> | string
    productType?: StringFilter<"SkuCatalog"> | string
    theme?: StringNullableFilter<"SkuCatalog"> | string | null
    color?: StringNullableFilter<"SkuCatalog"> | string | null
    composition?: StringNullableFilter<"SkuCatalog"> | string | null
    srp?: DecimalFilter<"SkuCatalog"> | Decimal | DecimalJsLike | number | string
    brandId?: StringNullableFilter<"SkuCatalog"> | string | null
    seasonGroupId?: StringNullableFilter<"SkuCatalog"> | string | null
    imageUrl?: StringNullableFilter<"SkuCatalog"> | string | null
    isActive?: BoolFilter<"SkuCatalog"> | boolean
    brand?: XOR<GroupBrandNullableRelationFilter, GroupBrandWhereInput> | null
    products?: ProposalProductListRelationFilter
    sizeCurveRecommendations?: SizeCurveRecommendationListRelationFilter
    skuPerformance?: SkuPerformanceListRelationFilter
    skuRecommendations?: SkuRecommendationListRelationFilter
  }

  export type SkuCatalogOrderByWithRelationInput = {
    id?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    productType?: SortOrder
    theme?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    composition?: SortOrderInput | SortOrder
    srp?: SortOrder
    brandId?: SortOrderInput | SortOrder
    seasonGroupId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    brand?: GroupBrandOrderByWithRelationInput
    products?: ProposalProductOrderByRelationAggregateInput
    sizeCurveRecommendations?: SizeCurveRecommendationOrderByRelationAggregateInput
    skuPerformance?: SkuPerformanceOrderByRelationAggregateInput
    skuRecommendations?: SkuRecommendationOrderByRelationAggregateInput
  }

  export type SkuCatalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    skuCode?: string
    AND?: SkuCatalogWhereInput | SkuCatalogWhereInput[]
    OR?: SkuCatalogWhereInput[]
    NOT?: SkuCatalogWhereInput | SkuCatalogWhereInput[]
    productName?: StringFilter<"SkuCatalog"> | string
    productType?: StringFilter<"SkuCatalog"> | string
    theme?: StringNullableFilter<"SkuCatalog"> | string | null
    color?: StringNullableFilter<"SkuCatalog"> | string | null
    composition?: StringNullableFilter<"SkuCatalog"> | string | null
    srp?: DecimalFilter<"SkuCatalog"> | Decimal | DecimalJsLike | number | string
    brandId?: StringNullableFilter<"SkuCatalog"> | string | null
    seasonGroupId?: StringNullableFilter<"SkuCatalog"> | string | null
    imageUrl?: StringNullableFilter<"SkuCatalog"> | string | null
    isActive?: BoolFilter<"SkuCatalog"> | boolean
    brand?: XOR<GroupBrandNullableRelationFilter, GroupBrandWhereInput> | null
    products?: ProposalProductListRelationFilter
    sizeCurveRecommendations?: SizeCurveRecommendationListRelationFilter
    skuPerformance?: SkuPerformanceListRelationFilter
    skuRecommendations?: SkuRecommendationListRelationFilter
  }, "id" | "skuCode">

  export type SkuCatalogOrderByWithAggregationInput = {
    id?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    productType?: SortOrder
    theme?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    composition?: SortOrderInput | SortOrder
    srp?: SortOrder
    brandId?: SortOrderInput | SortOrder
    seasonGroupId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: SkuCatalogCountOrderByAggregateInput
    _avg?: SkuCatalogAvgOrderByAggregateInput
    _max?: SkuCatalogMaxOrderByAggregateInput
    _min?: SkuCatalogMinOrderByAggregateInput
    _sum?: SkuCatalogSumOrderByAggregateInput
  }

  export type SkuCatalogScalarWhereWithAggregatesInput = {
    AND?: SkuCatalogScalarWhereWithAggregatesInput | SkuCatalogScalarWhereWithAggregatesInput[]
    OR?: SkuCatalogScalarWhereWithAggregatesInput[]
    NOT?: SkuCatalogScalarWhereWithAggregatesInput | SkuCatalogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuCatalog"> | string
    skuCode?: StringWithAggregatesFilter<"SkuCatalog"> | string
    productName?: StringWithAggregatesFilter<"SkuCatalog"> | string
    productType?: StringWithAggregatesFilter<"SkuCatalog"> | string
    theme?: StringNullableWithAggregatesFilter<"SkuCatalog"> | string | null
    color?: StringNullableWithAggregatesFilter<"SkuCatalog"> | string | null
    composition?: StringNullableWithAggregatesFilter<"SkuCatalog"> | string | null
    srp?: DecimalWithAggregatesFilter<"SkuCatalog"> | Decimal | DecimalJsLike | number | string
    brandId?: StringNullableWithAggregatesFilter<"SkuCatalog"> | string | null
    seasonGroupId?: StringNullableWithAggregatesFilter<"SkuCatalog"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"SkuCatalog"> | string | null
    isActive?: BoolWithAggregatesFilter<"SkuCatalog"> | boolean
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    budgetCode?: StringFilter<"Budget"> | string
    groupBrandId?: StringFilter<"Budget"> | string
    seasonGroupId?: StringFilter<"Budget"> | string
    seasonType?: StringFilter<"Budget"> | string
    fiscalYear?: IntFilter<"Budget"> | number
    totalBudget?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    comment?: StringNullableFilter<"Budget"> | string | null
    createdById?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    groupBrand?: XOR<GroupBrandRelationFilter, GroupBrandWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    details?: BudgetDetailListRelationFilter
    proposals?: ProposalListRelationFilter
    budgetAlerts?: BudgetAlertListRelationFilter
    budgetSnapshots?: BudgetSnapshotListRelationFilter
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    budgetCode?: SortOrder
    groupBrandId?: SortOrder
    seasonGroupId?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groupBrand?: GroupBrandOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    details?: BudgetDetailOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
    budgetAlerts?: BudgetAlertOrderByRelationAggregateInput
    budgetSnapshots?: BudgetSnapshotOrderByRelationAggregateInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetCode?: string
    groupBrandId_seasonGroupId_seasonType_fiscalYear?: BudgetGroupBrandIdSeasonGroupIdSeasonTypeFiscalYearCompoundUniqueInput
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    groupBrandId?: StringFilter<"Budget"> | string
    seasonGroupId?: StringFilter<"Budget"> | string
    seasonType?: StringFilter<"Budget"> | string
    fiscalYear?: IntFilter<"Budget"> | number
    totalBudget?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    comment?: StringNullableFilter<"Budget"> | string | null
    createdById?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
    groupBrand?: XOR<GroupBrandRelationFilter, GroupBrandWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    details?: BudgetDetailListRelationFilter
    proposals?: ProposalListRelationFilter
    budgetAlerts?: BudgetAlertListRelationFilter
    budgetSnapshots?: BudgetSnapshotListRelationFilter
  }, "id" | "budgetCode" | "groupBrandId_seasonGroupId_seasonType_fiscalYear">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    budgetCode?: SortOrder
    groupBrandId?: SortOrder
    seasonGroupId?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    budgetCode?: StringWithAggregatesFilter<"Budget"> | string
    groupBrandId?: StringWithAggregatesFilter<"Budget"> | string
    seasonGroupId?: StringWithAggregatesFilter<"Budget"> | string
    seasonType?: StringWithAggregatesFilter<"Budget"> | string
    fiscalYear?: IntWithAggregatesFilter<"Budget"> | number
    totalBudget?: DecimalWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusWithAggregatesFilter<"Budget"> | $Enums.BudgetStatus
    comment?: StringNullableWithAggregatesFilter<"Budget"> | string | null
    createdById?: StringWithAggregatesFilter<"Budget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type BudgetDetailWhereInput = {
    AND?: BudgetDetailWhereInput | BudgetDetailWhereInput[]
    OR?: BudgetDetailWhereInput[]
    NOT?: BudgetDetailWhereInput | BudgetDetailWhereInput[]
    id?: StringFilter<"BudgetDetail"> | string
    budgetId?: StringFilter<"BudgetDetail"> | string
    storeId?: StringFilter<"BudgetDetail"> | string
    budgetAmount?: DecimalFilter<"BudgetDetail"> | Decimal | DecimalJsLike | number | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    planningVersions?: PlanningVersionListRelationFilter
    allocationRecommendations?: AllocationRecommendationListRelationFilter
    skuRecommendations?: SkuRecommendationListRelationFilter
  }

  export type BudgetDetailOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    storeId?: SortOrder
    budgetAmount?: SortOrder
    budget?: BudgetOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
    planningVersions?: PlanningVersionOrderByRelationAggregateInput
    allocationRecommendations?: AllocationRecommendationOrderByRelationAggregateInput
    skuRecommendations?: SkuRecommendationOrderByRelationAggregateInput
  }

  export type BudgetDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetId_storeId?: BudgetDetailBudgetIdStoreIdCompoundUniqueInput
    AND?: BudgetDetailWhereInput | BudgetDetailWhereInput[]
    OR?: BudgetDetailWhereInput[]
    NOT?: BudgetDetailWhereInput | BudgetDetailWhereInput[]
    budgetId?: StringFilter<"BudgetDetail"> | string
    storeId?: StringFilter<"BudgetDetail"> | string
    budgetAmount?: DecimalFilter<"BudgetDetail"> | Decimal | DecimalJsLike | number | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
    planningVersions?: PlanningVersionListRelationFilter
    allocationRecommendations?: AllocationRecommendationListRelationFilter
    skuRecommendations?: SkuRecommendationListRelationFilter
  }, "id" | "budgetId_storeId">

  export type BudgetDetailOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    storeId?: SortOrder
    budgetAmount?: SortOrder
    _count?: BudgetDetailCountOrderByAggregateInput
    _avg?: BudgetDetailAvgOrderByAggregateInput
    _max?: BudgetDetailMaxOrderByAggregateInput
    _min?: BudgetDetailMinOrderByAggregateInput
    _sum?: BudgetDetailSumOrderByAggregateInput
  }

  export type BudgetDetailScalarWhereWithAggregatesInput = {
    AND?: BudgetDetailScalarWhereWithAggregatesInput | BudgetDetailScalarWhereWithAggregatesInput[]
    OR?: BudgetDetailScalarWhereWithAggregatesInput[]
    NOT?: BudgetDetailScalarWhereWithAggregatesInput | BudgetDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetDetail"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetDetail"> | string
    storeId?: StringWithAggregatesFilter<"BudgetDetail"> | string
    budgetAmount?: DecimalWithAggregatesFilter<"BudgetDetail"> | Decimal | DecimalJsLike | number | string
  }

  export type PlanningVersionWhereInput = {
    AND?: PlanningVersionWhereInput | PlanningVersionWhereInput[]
    OR?: PlanningVersionWhereInput[]
    NOT?: PlanningVersionWhereInput | PlanningVersionWhereInput[]
    id?: StringFilter<"PlanningVersion"> | string
    planningCode?: StringFilter<"PlanningVersion"> | string
    budgetDetailId?: StringFilter<"PlanningVersion"> | string
    versionNumber?: IntFilter<"PlanningVersion"> | number
    versionName?: StringNullableFilter<"PlanningVersion"> | string | null
    status?: EnumPlanningStatusFilter<"PlanningVersion"> | $Enums.PlanningStatus
    isFinal?: BoolFilter<"PlanningVersion"> | boolean
    snapshotData?: JsonNullableFilter<"PlanningVersion">
    createdById?: StringFilter<"PlanningVersion"> | string
    createdAt?: DateTimeFilter<"PlanningVersion"> | Date | string
    updatedAt?: DateTimeFilter<"PlanningVersion"> | Date | string
    budgetDetail?: XOR<BudgetDetailRelationFilter, BudgetDetailWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    details?: PlanningDetailListRelationFilter
    proposals?: ProposalListRelationFilter
  }

  export type PlanningVersionOrderByWithRelationInput = {
    id?: SortOrder
    planningCode?: SortOrder
    budgetDetailId?: SortOrder
    versionNumber?: SortOrder
    versionName?: SortOrderInput | SortOrder
    status?: SortOrder
    isFinal?: SortOrder
    snapshotData?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budgetDetail?: BudgetDetailOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    details?: PlanningDetailOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type PlanningVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    planningCode?: string
    budgetDetailId_versionNumber?: PlanningVersionBudgetDetailIdVersionNumberCompoundUniqueInput
    AND?: PlanningVersionWhereInput | PlanningVersionWhereInput[]
    OR?: PlanningVersionWhereInput[]
    NOT?: PlanningVersionWhereInput | PlanningVersionWhereInput[]
    budgetDetailId?: StringFilter<"PlanningVersion"> | string
    versionNumber?: IntFilter<"PlanningVersion"> | number
    versionName?: StringNullableFilter<"PlanningVersion"> | string | null
    status?: EnumPlanningStatusFilter<"PlanningVersion"> | $Enums.PlanningStatus
    isFinal?: BoolFilter<"PlanningVersion"> | boolean
    snapshotData?: JsonNullableFilter<"PlanningVersion">
    createdById?: StringFilter<"PlanningVersion"> | string
    createdAt?: DateTimeFilter<"PlanningVersion"> | Date | string
    updatedAt?: DateTimeFilter<"PlanningVersion"> | Date | string
    budgetDetail?: XOR<BudgetDetailRelationFilter, BudgetDetailWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    details?: PlanningDetailListRelationFilter
    proposals?: ProposalListRelationFilter
  }, "id" | "planningCode" | "budgetDetailId_versionNumber">

  export type PlanningVersionOrderByWithAggregationInput = {
    id?: SortOrder
    planningCode?: SortOrder
    budgetDetailId?: SortOrder
    versionNumber?: SortOrder
    versionName?: SortOrderInput | SortOrder
    status?: SortOrder
    isFinal?: SortOrder
    snapshotData?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanningVersionCountOrderByAggregateInput
    _avg?: PlanningVersionAvgOrderByAggregateInput
    _max?: PlanningVersionMaxOrderByAggregateInput
    _min?: PlanningVersionMinOrderByAggregateInput
    _sum?: PlanningVersionSumOrderByAggregateInput
  }

  export type PlanningVersionScalarWhereWithAggregatesInput = {
    AND?: PlanningVersionScalarWhereWithAggregatesInput | PlanningVersionScalarWhereWithAggregatesInput[]
    OR?: PlanningVersionScalarWhereWithAggregatesInput[]
    NOT?: PlanningVersionScalarWhereWithAggregatesInput | PlanningVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanningVersion"> | string
    planningCode?: StringWithAggregatesFilter<"PlanningVersion"> | string
    budgetDetailId?: StringWithAggregatesFilter<"PlanningVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"PlanningVersion"> | number
    versionName?: StringNullableWithAggregatesFilter<"PlanningVersion"> | string | null
    status?: EnumPlanningStatusWithAggregatesFilter<"PlanningVersion"> | $Enums.PlanningStatus
    isFinal?: BoolWithAggregatesFilter<"PlanningVersion"> | boolean
    snapshotData?: JsonNullableWithAggregatesFilter<"PlanningVersion">
    createdById?: StringWithAggregatesFilter<"PlanningVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlanningVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanningVersion"> | Date | string
  }

  export type PlanningDetailWhereInput = {
    AND?: PlanningDetailWhereInput | PlanningDetailWhereInput[]
    OR?: PlanningDetailWhereInput[]
    NOT?: PlanningDetailWhereInput | PlanningDetailWhereInput[]
    id?: StringFilter<"PlanningDetail"> | string
    planningVersionId?: StringFilter<"PlanningDetail"> | string
    dimensionType?: StringFilter<"PlanningDetail"> | string
    collectionId?: StringNullableFilter<"PlanningDetail"> | string | null
    genderId?: StringNullableFilter<"PlanningDetail"> | string | null
    categoryId?: StringNullableFilter<"PlanningDetail"> | string | null
    subCategoryId?: StringNullableFilter<"PlanningDetail"> | string | null
    lastSeasonSales?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userComment?: StringNullableFilter<"PlanningDetail"> | string | null
    planningVersion?: XOR<PlanningVersionRelationFilter, PlanningVersionWhereInput>
    collection?: XOR<CollectionNullableRelationFilter, CollectionWhereInput> | null
    gender?: XOR<GenderNullableRelationFilter, GenderWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    subCategory?: XOR<SubCategoryNullableRelationFilter, SubCategoryWhereInput> | null
  }

  export type PlanningDetailOrderByWithRelationInput = {
    id?: SortOrder
    planningVersionId?: SortOrder
    dimensionType?: SortOrder
    collectionId?: SortOrderInput | SortOrder
    genderId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    subCategoryId?: SortOrderInput | SortOrder
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
    userComment?: SortOrderInput | SortOrder
    planningVersion?: PlanningVersionOrderByWithRelationInput
    collection?: CollectionOrderByWithRelationInput
    gender?: GenderOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    subCategory?: SubCategoryOrderByWithRelationInput
  }

  export type PlanningDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanningDetailWhereInput | PlanningDetailWhereInput[]
    OR?: PlanningDetailWhereInput[]
    NOT?: PlanningDetailWhereInput | PlanningDetailWhereInput[]
    planningVersionId?: StringFilter<"PlanningDetail"> | string
    dimensionType?: StringFilter<"PlanningDetail"> | string
    collectionId?: StringNullableFilter<"PlanningDetail"> | string | null
    genderId?: StringNullableFilter<"PlanningDetail"> | string | null
    categoryId?: StringNullableFilter<"PlanningDetail"> | string | null
    subCategoryId?: StringNullableFilter<"PlanningDetail"> | string | null
    lastSeasonSales?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userComment?: StringNullableFilter<"PlanningDetail"> | string | null
    planningVersion?: XOR<PlanningVersionRelationFilter, PlanningVersionWhereInput>
    collection?: XOR<CollectionNullableRelationFilter, CollectionWhereInput> | null
    gender?: XOR<GenderNullableRelationFilter, GenderWhereInput> | null
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    subCategory?: XOR<SubCategoryNullableRelationFilter, SubCategoryWhereInput> | null
  }, "id">

  export type PlanningDetailOrderByWithAggregationInput = {
    id?: SortOrder
    planningVersionId?: SortOrder
    dimensionType?: SortOrder
    collectionId?: SortOrderInput | SortOrder
    genderId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    subCategoryId?: SortOrderInput | SortOrder
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
    userComment?: SortOrderInput | SortOrder
    _count?: PlanningDetailCountOrderByAggregateInput
    _avg?: PlanningDetailAvgOrderByAggregateInput
    _max?: PlanningDetailMaxOrderByAggregateInput
    _min?: PlanningDetailMinOrderByAggregateInput
    _sum?: PlanningDetailSumOrderByAggregateInput
  }

  export type PlanningDetailScalarWhereWithAggregatesInput = {
    AND?: PlanningDetailScalarWhereWithAggregatesInput | PlanningDetailScalarWhereWithAggregatesInput[]
    OR?: PlanningDetailScalarWhereWithAggregatesInput[]
    NOT?: PlanningDetailScalarWhereWithAggregatesInput | PlanningDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlanningDetail"> | string
    planningVersionId?: StringWithAggregatesFilter<"PlanningDetail"> | string
    dimensionType?: StringWithAggregatesFilter<"PlanningDetail"> | string
    collectionId?: StringNullableWithAggregatesFilter<"PlanningDetail"> | string | null
    genderId?: StringNullableWithAggregatesFilter<"PlanningDetail"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"PlanningDetail"> | string | null
    subCategoryId?: StringNullableWithAggregatesFilter<"PlanningDetail"> | string | null
    lastSeasonSales?: DecimalWithAggregatesFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalWithAggregatesFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalWithAggregatesFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalWithAggregatesFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalWithAggregatesFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalWithAggregatesFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userComment?: StringNullableWithAggregatesFilter<"PlanningDetail"> | string | null
  }

  export type ProposalWhereInput = {
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    id?: StringFilter<"Proposal"> | string
    ticketName?: StringFilter<"Proposal"> | string
    budgetId?: StringFilter<"Proposal"> | string
    planningVersionId?: StringNullableFilter<"Proposal"> | string | null
    status?: EnumProposalStatusFilter<"Proposal"> | $Enums.ProposalStatus
    totalSkuCount?: IntFilter<"Proposal"> | number
    totalOrderQty?: IntFilter<"Proposal"> | number
    totalValue?: DecimalFilter<"Proposal"> | Decimal | DecimalJsLike | number | string
    createdById?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
    planningVersion?: XOR<PlanningVersionNullableRelationFilter, PlanningVersionWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    products?: ProposalProductListRelationFilter
  }

  export type ProposalOrderByWithRelationInput = {
    id?: SortOrder
    ticketName?: SortOrder
    budgetId?: SortOrder
    planningVersionId?: SortOrderInput | SortOrder
    status?: SortOrder
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    budget?: BudgetOrderByWithRelationInput
    planningVersion?: PlanningVersionOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    products?: ProposalProductOrderByRelationAggregateInput
  }

  export type ProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    ticketName?: StringFilter<"Proposal"> | string
    budgetId?: StringFilter<"Proposal"> | string
    planningVersionId?: StringNullableFilter<"Proposal"> | string | null
    status?: EnumProposalStatusFilter<"Proposal"> | $Enums.ProposalStatus
    totalSkuCount?: IntFilter<"Proposal"> | number
    totalOrderQty?: IntFilter<"Proposal"> | number
    totalValue?: DecimalFilter<"Proposal"> | Decimal | DecimalJsLike | number | string
    createdById?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
    planningVersion?: XOR<PlanningVersionNullableRelationFilter, PlanningVersionWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    products?: ProposalProductListRelationFilter
  }, "id">

  export type ProposalOrderByWithAggregationInput = {
    id?: SortOrder
    ticketName?: SortOrder
    budgetId?: SortOrder
    planningVersionId?: SortOrderInput | SortOrder
    status?: SortOrder
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProposalCountOrderByAggregateInput
    _avg?: ProposalAvgOrderByAggregateInput
    _max?: ProposalMaxOrderByAggregateInput
    _min?: ProposalMinOrderByAggregateInput
    _sum?: ProposalSumOrderByAggregateInput
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    OR?: ProposalScalarWhereWithAggregatesInput[]
    NOT?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proposal"> | string
    ticketName?: StringWithAggregatesFilter<"Proposal"> | string
    budgetId?: StringWithAggregatesFilter<"Proposal"> | string
    planningVersionId?: StringNullableWithAggregatesFilter<"Proposal"> | string | null
    status?: EnumProposalStatusWithAggregatesFilter<"Proposal"> | $Enums.ProposalStatus
    totalSkuCount?: IntWithAggregatesFilter<"Proposal"> | number
    totalOrderQty?: IntWithAggregatesFilter<"Proposal"> | number
    totalValue?: DecimalWithAggregatesFilter<"Proposal"> | Decimal | DecimalJsLike | number | string
    createdById?: StringWithAggregatesFilter<"Proposal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
  }

  export type ProposalProductWhereInput = {
    AND?: ProposalProductWhereInput | ProposalProductWhereInput[]
    OR?: ProposalProductWhereInput[]
    NOT?: ProposalProductWhereInput | ProposalProductWhereInput[]
    id?: StringFilter<"ProposalProduct"> | string
    proposalId?: StringFilter<"ProposalProduct"> | string
    skuId?: StringFilter<"ProposalProduct"> | string
    skuCode?: StringFilter<"ProposalProduct"> | string
    productName?: StringFilter<"ProposalProduct"> | string
    collection?: StringNullableFilter<"ProposalProduct"> | string | null
    gender?: StringNullableFilter<"ProposalProduct"> | string | null
    category?: StringNullableFilter<"ProposalProduct"> | string | null
    subCategory?: StringNullableFilter<"ProposalProduct"> | string | null
    theme?: StringNullableFilter<"ProposalProduct"> | string | null
    color?: StringNullableFilter<"ProposalProduct"> | string | null
    composition?: StringNullableFilter<"ProposalProduct"> | string | null
    unitCost?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    srp?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    orderQty?: IntFilter<"ProposalProduct"> | number
    totalValue?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    customerTarget?: StringNullableFilter<"ProposalProduct"> | string | null
    imageUrl?: StringNullableFilter<"ProposalProduct"> | string | null
    sortOrder?: IntFilter<"ProposalProduct"> | number
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
    allocations?: ProductAllocationListRelationFilter
  }

  export type ProposalProductOrderByWithRelationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    collection?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subCategory?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    composition?: SortOrderInput | SortOrder
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    customerTarget?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    proposal?: ProposalOrderByWithRelationInput
    sku?: SkuCatalogOrderByWithRelationInput
    allocations?: ProductAllocationOrderByRelationAggregateInput
  }

  export type ProposalProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalProductWhereInput | ProposalProductWhereInput[]
    OR?: ProposalProductWhereInput[]
    NOT?: ProposalProductWhereInput | ProposalProductWhereInput[]
    proposalId?: StringFilter<"ProposalProduct"> | string
    skuId?: StringFilter<"ProposalProduct"> | string
    skuCode?: StringFilter<"ProposalProduct"> | string
    productName?: StringFilter<"ProposalProduct"> | string
    collection?: StringNullableFilter<"ProposalProduct"> | string | null
    gender?: StringNullableFilter<"ProposalProduct"> | string | null
    category?: StringNullableFilter<"ProposalProduct"> | string | null
    subCategory?: StringNullableFilter<"ProposalProduct"> | string | null
    theme?: StringNullableFilter<"ProposalProduct"> | string | null
    color?: StringNullableFilter<"ProposalProduct"> | string | null
    composition?: StringNullableFilter<"ProposalProduct"> | string | null
    unitCost?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    srp?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    orderQty?: IntFilter<"ProposalProduct"> | number
    totalValue?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    customerTarget?: StringNullableFilter<"ProposalProduct"> | string | null
    imageUrl?: StringNullableFilter<"ProposalProduct"> | string | null
    sortOrder?: IntFilter<"ProposalProduct"> | number
    proposal?: XOR<ProposalRelationFilter, ProposalWhereInput>
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
    allocations?: ProductAllocationListRelationFilter
  }, "id">

  export type ProposalProductOrderByWithAggregationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    collection?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    subCategory?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    composition?: SortOrderInput | SortOrder
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    customerTarget?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    _count?: ProposalProductCountOrderByAggregateInput
    _avg?: ProposalProductAvgOrderByAggregateInput
    _max?: ProposalProductMaxOrderByAggregateInput
    _min?: ProposalProductMinOrderByAggregateInput
    _sum?: ProposalProductSumOrderByAggregateInput
  }

  export type ProposalProductScalarWhereWithAggregatesInput = {
    AND?: ProposalProductScalarWhereWithAggregatesInput | ProposalProductScalarWhereWithAggregatesInput[]
    OR?: ProposalProductScalarWhereWithAggregatesInput[]
    NOT?: ProposalProductScalarWhereWithAggregatesInput | ProposalProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalProduct"> | string
    proposalId?: StringWithAggregatesFilter<"ProposalProduct"> | string
    skuId?: StringWithAggregatesFilter<"ProposalProduct"> | string
    skuCode?: StringWithAggregatesFilter<"ProposalProduct"> | string
    productName?: StringWithAggregatesFilter<"ProposalProduct"> | string
    collection?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    gender?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    category?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    subCategory?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    theme?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    composition?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    unitCost?: DecimalWithAggregatesFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    srp?: DecimalWithAggregatesFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    orderQty?: IntWithAggregatesFilter<"ProposalProduct"> | number
    totalValue?: DecimalWithAggregatesFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    customerTarget?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ProposalProduct"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ProposalProduct"> | number
  }

  export type ProductAllocationWhereInput = {
    AND?: ProductAllocationWhereInput | ProductAllocationWhereInput[]
    OR?: ProductAllocationWhereInput[]
    NOT?: ProductAllocationWhereInput | ProductAllocationWhereInput[]
    id?: StringFilter<"ProductAllocation"> | string
    proposalProductId?: StringFilter<"ProductAllocation"> | string
    storeId?: StringFilter<"ProductAllocation"> | string
    quantity?: IntFilter<"ProductAllocation"> | number
    proposalProduct?: XOR<ProposalProductRelationFilter, ProposalProductWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type ProductAllocationOrderByWithRelationInput = {
    id?: SortOrder
    proposalProductId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    proposalProduct?: ProposalProductOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type ProductAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    proposalProductId_storeId?: ProductAllocationProposalProductIdStoreIdCompoundUniqueInput
    AND?: ProductAllocationWhereInput | ProductAllocationWhereInput[]
    OR?: ProductAllocationWhereInput[]
    NOT?: ProductAllocationWhereInput | ProductAllocationWhereInput[]
    proposalProductId?: StringFilter<"ProductAllocation"> | string
    storeId?: StringFilter<"ProductAllocation"> | string
    quantity?: IntFilter<"ProductAllocation"> | number
    proposalProduct?: XOR<ProposalProductRelationFilter, ProposalProductWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id" | "proposalProductId_storeId">

  export type ProductAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    proposalProductId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    _count?: ProductAllocationCountOrderByAggregateInput
    _avg?: ProductAllocationAvgOrderByAggregateInput
    _max?: ProductAllocationMaxOrderByAggregateInput
    _min?: ProductAllocationMinOrderByAggregateInput
    _sum?: ProductAllocationSumOrderByAggregateInput
  }

  export type ProductAllocationScalarWhereWithAggregatesInput = {
    AND?: ProductAllocationScalarWhereWithAggregatesInput | ProductAllocationScalarWhereWithAggregatesInput[]
    OR?: ProductAllocationScalarWhereWithAggregatesInput[]
    NOT?: ProductAllocationScalarWhereWithAggregatesInput | ProductAllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductAllocation"> | string
    proposalProductId?: StringWithAggregatesFilter<"ProductAllocation"> | string
    storeId?: StringWithAggregatesFilter<"ProductAllocation"> | string
    quantity?: IntWithAggregatesFilter<"ProductAllocation"> | number
  }

  export type ApprovalWhereInput = {
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    id?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    level?: IntFilter<"Approval"> | number
    deciderId?: StringFilter<"Approval"> | string
    action?: EnumApprovalActionFilter<"Approval"> | $Enums.ApprovalAction
    comment?: StringNullableFilter<"Approval"> | string | null
    decidedAt?: DateTimeFilter<"Approval"> | Date | string
    decider?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApprovalOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    level?: SortOrder
    deciderId?: SortOrder
    action?: SortOrder
    comment?: SortOrderInput | SortOrder
    decidedAt?: SortOrder
    decider?: UserOrderByWithRelationInput
  }

  export type ApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    level?: IntFilter<"Approval"> | number
    deciderId?: StringFilter<"Approval"> | string
    action?: EnumApprovalActionFilter<"Approval"> | $Enums.ApprovalAction
    comment?: StringNullableFilter<"Approval"> | string | null
    decidedAt?: DateTimeFilter<"Approval"> | Date | string
    decider?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    level?: SortOrder
    deciderId?: SortOrder
    action?: SortOrder
    comment?: SortOrderInput | SortOrder
    decidedAt?: SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _avg?: ApprovalAvgOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
    _sum?: ApprovalSumOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    OR?: ApprovalScalarWhereWithAggregatesInput[]
    NOT?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Approval"> | string
    entityType?: StringWithAggregatesFilter<"Approval"> | string
    entityId?: StringWithAggregatesFilter<"Approval"> | string
    level?: IntWithAggregatesFilter<"Approval"> | number
    deciderId?: StringWithAggregatesFilter<"Approval"> | string
    action?: EnumApprovalActionWithAggregatesFilter<"Approval"> | $Enums.ApprovalAction
    comment?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    decidedAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SalesHistoryWhereInput = {
    AND?: SalesHistoryWhereInput | SalesHistoryWhereInput[]
    OR?: SalesHistoryWhereInput[]
    NOT?: SalesHistoryWhereInput | SalesHistoryWhereInput[]
    id?: StringFilter<"SalesHistory"> | string
    skuCode?: StringFilter<"SalesHistory"> | string
    storeId?: StringFilter<"SalesHistory"> | string
    sizeCode?: StringFilter<"SalesHistory"> | string
    season?: StringFilter<"SalesHistory"> | string
    quantitySold?: IntFilter<"SalesHistory"> | number
    quantityBought?: IntFilter<"SalesHistory"> | number
    sellThroughPct?: DecimalFilter<"SalesHistory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesHistory"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type SalesHistoryOrderByWithRelationInput = {
    id?: SortOrder
    skuCode?: SortOrder
    storeId?: SortOrder
    sizeCode?: SortOrder
    season?: SortOrder
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
    store?: StoreOrderByWithRelationInput
  }

  export type SalesHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesHistoryWhereInput | SalesHistoryWhereInput[]
    OR?: SalesHistoryWhereInput[]
    NOT?: SalesHistoryWhereInput | SalesHistoryWhereInput[]
    skuCode?: StringFilter<"SalesHistory"> | string
    storeId?: StringFilter<"SalesHistory"> | string
    sizeCode?: StringFilter<"SalesHistory"> | string
    season?: StringFilter<"SalesHistory"> | string
    quantitySold?: IntFilter<"SalesHistory"> | number
    quantityBought?: IntFilter<"SalesHistory"> | number
    sellThroughPct?: DecimalFilter<"SalesHistory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesHistory"> | Date | string
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id">

  export type SalesHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    skuCode?: SortOrder
    storeId?: SortOrder
    sizeCode?: SortOrder
    season?: SortOrder
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
    _count?: SalesHistoryCountOrderByAggregateInput
    _avg?: SalesHistoryAvgOrderByAggregateInput
    _max?: SalesHistoryMaxOrderByAggregateInput
    _min?: SalesHistoryMinOrderByAggregateInput
    _sum?: SalesHistorySumOrderByAggregateInput
  }

  export type SalesHistoryScalarWhereWithAggregatesInput = {
    AND?: SalesHistoryScalarWhereWithAggregatesInput | SalesHistoryScalarWhereWithAggregatesInput[]
    OR?: SalesHistoryScalarWhereWithAggregatesInput[]
    NOT?: SalesHistoryScalarWhereWithAggregatesInput | SalesHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesHistory"> | string
    skuCode?: StringWithAggregatesFilter<"SalesHistory"> | string
    storeId?: StringWithAggregatesFilter<"SalesHistory"> | string
    sizeCode?: StringWithAggregatesFilter<"SalesHistory"> | string
    season?: StringWithAggregatesFilter<"SalesHistory"> | string
    quantitySold?: IntWithAggregatesFilter<"SalesHistory"> | number
    quantityBought?: IntWithAggregatesFilter<"SalesHistory"> | number
    sellThroughPct?: DecimalWithAggregatesFilter<"SalesHistory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesHistory"> | Date | string
  }

  export type SizeCurveRecommendationWhereInput = {
    AND?: SizeCurveRecommendationWhereInput | SizeCurveRecommendationWhereInput[]
    OR?: SizeCurveRecommendationWhereInput[]
    NOT?: SizeCurveRecommendationWhereInput | SizeCurveRecommendationWhereInput[]
    id?: StringFilter<"SizeCurveRecommendation"> | string
    skuId?: StringFilter<"SizeCurveRecommendation"> | string
    storeId?: StringFilter<"SizeCurveRecommendation"> | string
    category?: StringFilter<"SizeCurveRecommendation"> | string
    sizeCode?: StringFilter<"SizeCurveRecommendation"> | string
    recommendedPct?: DecimalFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFilter<"SizeCurveRecommendation"> | number
    reasoning?: StringNullableFilter<"SizeCurveRecommendation"> | string | null
    createdAt?: DateTimeFilter<"SizeCurveRecommendation"> | Date | string
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type SizeCurveRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    skuId?: SortOrder
    storeId?: SortOrder
    category?: SortOrder
    sizeCode?: SortOrder
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sku?: SkuCatalogOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type SizeCurveRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    skuId_storeId_sizeCode?: SizeCurveRecommendationSkuIdStoreIdSizeCodeCompoundUniqueInput
    AND?: SizeCurveRecommendationWhereInput | SizeCurveRecommendationWhereInput[]
    OR?: SizeCurveRecommendationWhereInput[]
    NOT?: SizeCurveRecommendationWhereInput | SizeCurveRecommendationWhereInput[]
    skuId?: StringFilter<"SizeCurveRecommendation"> | string
    storeId?: StringFilter<"SizeCurveRecommendation"> | string
    category?: StringFilter<"SizeCurveRecommendation"> | string
    sizeCode?: StringFilter<"SizeCurveRecommendation"> | string
    recommendedPct?: DecimalFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFilter<"SizeCurveRecommendation"> | number
    reasoning?: StringNullableFilter<"SizeCurveRecommendation"> | string | null
    createdAt?: DateTimeFilter<"SizeCurveRecommendation"> | Date | string
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
    store?: XOR<StoreRelationFilter, StoreWhereInput>
  }, "id" | "skuId_storeId_sizeCode">

  export type SizeCurveRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    skuId?: SortOrder
    storeId?: SortOrder
    category?: SortOrder
    sizeCode?: SortOrder
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SizeCurveRecommendationCountOrderByAggregateInput
    _avg?: SizeCurveRecommendationAvgOrderByAggregateInput
    _max?: SizeCurveRecommendationMaxOrderByAggregateInput
    _min?: SizeCurveRecommendationMinOrderByAggregateInput
    _sum?: SizeCurveRecommendationSumOrderByAggregateInput
  }

  export type SizeCurveRecommendationScalarWhereWithAggregatesInput = {
    AND?: SizeCurveRecommendationScalarWhereWithAggregatesInput | SizeCurveRecommendationScalarWhereWithAggregatesInput[]
    OR?: SizeCurveRecommendationScalarWhereWithAggregatesInput[]
    NOT?: SizeCurveRecommendationScalarWhereWithAggregatesInput | SizeCurveRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SizeCurveRecommendation"> | string
    skuId?: StringWithAggregatesFilter<"SizeCurveRecommendation"> | string
    storeId?: StringWithAggregatesFilter<"SizeCurveRecommendation"> | string
    category?: StringWithAggregatesFilter<"SizeCurveRecommendation"> | string
    sizeCode?: StringWithAggregatesFilter<"SizeCurveRecommendation"> | string
    recommendedPct?: DecimalWithAggregatesFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalWithAggregatesFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntWithAggregatesFilter<"SizeCurveRecommendation"> | number
    reasoning?: StringNullableWithAggregatesFilter<"SizeCurveRecommendation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SizeCurveRecommendation"> | Date | string
  }

  export type BudgetAlertWhereInput = {
    AND?: BudgetAlertWhereInput | BudgetAlertWhereInput[]
    OR?: BudgetAlertWhereInput[]
    NOT?: BudgetAlertWhereInput | BudgetAlertWhereInput[]
    id?: StringFilter<"BudgetAlert"> | string
    budgetId?: StringFilter<"BudgetAlert"> | string
    alertType?: StringFilter<"BudgetAlert"> | string
    severity?: StringFilter<"BudgetAlert"> | string
    title?: StringFilter<"BudgetAlert"> | string
    message?: StringFilter<"BudgetAlert"> | string
    metricValue?: DecimalFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableFilter<"BudgetAlert"> | string | null
    isRead?: BoolFilter<"BudgetAlert"> | boolean
    isDismissed?: BoolFilter<"BudgetAlert"> | boolean
    createdAt?: DateTimeFilter<"BudgetAlert"> | Date | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }

  export type BudgetAlertOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    metricValue?: SortOrder
    threshold?: SortOrder
    category?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isDismissed?: SortOrder
    createdAt?: SortOrder
    budget?: BudgetOrderByWithRelationInput
  }

  export type BudgetAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetAlertWhereInput | BudgetAlertWhereInput[]
    OR?: BudgetAlertWhereInput[]
    NOT?: BudgetAlertWhereInput | BudgetAlertWhereInput[]
    budgetId?: StringFilter<"BudgetAlert"> | string
    alertType?: StringFilter<"BudgetAlert"> | string
    severity?: StringFilter<"BudgetAlert"> | string
    title?: StringFilter<"BudgetAlert"> | string
    message?: StringFilter<"BudgetAlert"> | string
    metricValue?: DecimalFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableFilter<"BudgetAlert"> | string | null
    isRead?: BoolFilter<"BudgetAlert"> | boolean
    isDismissed?: BoolFilter<"BudgetAlert"> | boolean
    createdAt?: DateTimeFilter<"BudgetAlert"> | Date | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }, "id">

  export type BudgetAlertOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    metricValue?: SortOrder
    threshold?: SortOrder
    category?: SortOrderInput | SortOrder
    isRead?: SortOrder
    isDismissed?: SortOrder
    createdAt?: SortOrder
    _count?: BudgetAlertCountOrderByAggregateInput
    _avg?: BudgetAlertAvgOrderByAggregateInput
    _max?: BudgetAlertMaxOrderByAggregateInput
    _min?: BudgetAlertMinOrderByAggregateInput
    _sum?: BudgetAlertSumOrderByAggregateInput
  }

  export type BudgetAlertScalarWhereWithAggregatesInput = {
    AND?: BudgetAlertScalarWhereWithAggregatesInput | BudgetAlertScalarWhereWithAggregatesInput[]
    OR?: BudgetAlertScalarWhereWithAggregatesInput[]
    NOT?: BudgetAlertScalarWhereWithAggregatesInput | BudgetAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetAlert"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetAlert"> | string
    alertType?: StringWithAggregatesFilter<"BudgetAlert"> | string
    severity?: StringWithAggregatesFilter<"BudgetAlert"> | string
    title?: StringWithAggregatesFilter<"BudgetAlert"> | string
    message?: StringWithAggregatesFilter<"BudgetAlert"> | string
    metricValue?: DecimalWithAggregatesFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalWithAggregatesFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableWithAggregatesFilter<"BudgetAlert"> | string | null
    isRead?: BoolWithAggregatesFilter<"BudgetAlert"> | boolean
    isDismissed?: BoolWithAggregatesFilter<"BudgetAlert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BudgetAlert"> | Date | string
  }

  export type BudgetSnapshotWhereInput = {
    AND?: BudgetSnapshotWhereInput | BudgetSnapshotWhereInput[]
    OR?: BudgetSnapshotWhereInput[]
    NOT?: BudgetSnapshotWhereInput | BudgetSnapshotWhereInput[]
    id?: StringFilter<"BudgetSnapshot"> | string
    budgetId?: StringFilter<"BudgetSnapshot"> | string
    snapshotDate?: DateTimeFilter<"BudgetSnapshot"> | Date | string
    totalCommitted?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }

  export type BudgetSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    snapshotDate?: SortOrder
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
    budget?: BudgetOrderByWithRelationInput
  }

  export type BudgetSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetId_snapshotDate?: BudgetSnapshotBudgetIdSnapshotDateCompoundUniqueInput
    AND?: BudgetSnapshotWhereInput | BudgetSnapshotWhereInput[]
    OR?: BudgetSnapshotWhereInput[]
    NOT?: BudgetSnapshotWhereInput | BudgetSnapshotWhereInput[]
    budgetId?: StringFilter<"BudgetSnapshot"> | string
    snapshotDate?: DateTimeFilter<"BudgetSnapshot"> | Date | string
    totalCommitted?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    budget?: XOR<BudgetRelationFilter, BudgetWhereInput>
  }, "id" | "budgetId_snapshotDate">

  export type BudgetSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    snapshotDate?: SortOrder
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
    _count?: BudgetSnapshotCountOrderByAggregateInput
    _avg?: BudgetSnapshotAvgOrderByAggregateInput
    _max?: BudgetSnapshotMaxOrderByAggregateInput
    _min?: BudgetSnapshotMinOrderByAggregateInput
    _sum?: BudgetSnapshotSumOrderByAggregateInput
  }

  export type BudgetSnapshotScalarWhereWithAggregatesInput = {
    AND?: BudgetSnapshotScalarWhereWithAggregatesInput | BudgetSnapshotScalarWhereWithAggregatesInput[]
    OR?: BudgetSnapshotScalarWhereWithAggregatesInput[]
    NOT?: BudgetSnapshotScalarWhereWithAggregatesInput | BudgetSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BudgetSnapshot"> | string
    budgetId?: StringWithAggregatesFilter<"BudgetSnapshot"> | string
    snapshotDate?: DateTimeWithAggregatesFilter<"BudgetSnapshot"> | Date | string
    totalCommitted?: DecimalWithAggregatesFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalWithAggregatesFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalWithAggregatesFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
  }

  export type AllocationHistoryWhereInput = {
    AND?: AllocationHistoryWhereInput | AllocationHistoryWhereInput[]
    OR?: AllocationHistoryWhereInput[]
    NOT?: AllocationHistoryWhereInput | AllocationHistoryWhereInput[]
    id?: StringFilter<"AllocationHistory"> | string
    budgetId?: StringFilter<"AllocationHistory"> | string
    seasonGroup?: StringFilter<"AllocationHistory"> | string
    seasonType?: StringFilter<"AllocationHistory"> | string
    fiscalYear?: IntFilter<"AllocationHistory"> | number
    dimensionType?: StringFilter<"AllocationHistory"> | string
    dimensionValue?: StringFilter<"AllocationHistory"> | string
    allocatedPct?: DecimalFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string
    actualSales?: DecimalNullableFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: DecimalNullableFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AllocationHistory"> | Date | string
  }

  export type AllocationHistoryOrderByWithRelationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    seasonGroup?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrderInput | SortOrder
    sellThroughPct?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AllocationHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllocationHistoryWhereInput | AllocationHistoryWhereInput[]
    OR?: AllocationHistoryWhereInput[]
    NOT?: AllocationHistoryWhereInput | AllocationHistoryWhereInput[]
    budgetId?: StringFilter<"AllocationHistory"> | string
    seasonGroup?: StringFilter<"AllocationHistory"> | string
    seasonType?: StringFilter<"AllocationHistory"> | string
    fiscalYear?: IntFilter<"AllocationHistory"> | number
    dimensionType?: StringFilter<"AllocationHistory"> | string
    dimensionValue?: StringFilter<"AllocationHistory"> | string
    allocatedPct?: DecimalFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string
    actualSales?: DecimalNullableFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: DecimalNullableFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AllocationHistory"> | Date | string
  }, "id">

  export type AllocationHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    budgetId?: SortOrder
    seasonGroup?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrderInput | SortOrder
    sellThroughPct?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AllocationHistoryCountOrderByAggregateInput
    _avg?: AllocationHistoryAvgOrderByAggregateInput
    _max?: AllocationHistoryMaxOrderByAggregateInput
    _min?: AllocationHistoryMinOrderByAggregateInput
    _sum?: AllocationHistorySumOrderByAggregateInput
  }

  export type AllocationHistoryScalarWhereWithAggregatesInput = {
    AND?: AllocationHistoryScalarWhereWithAggregatesInput | AllocationHistoryScalarWhereWithAggregatesInput[]
    OR?: AllocationHistoryScalarWhereWithAggregatesInput[]
    NOT?: AllocationHistoryScalarWhereWithAggregatesInput | AllocationHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AllocationHistory"> | string
    budgetId?: StringWithAggregatesFilter<"AllocationHistory"> | string
    seasonGroup?: StringWithAggregatesFilter<"AllocationHistory"> | string
    seasonType?: StringWithAggregatesFilter<"AllocationHistory"> | string
    fiscalYear?: IntWithAggregatesFilter<"AllocationHistory"> | number
    dimensionType?: StringWithAggregatesFilter<"AllocationHistory"> | string
    dimensionValue?: StringWithAggregatesFilter<"AllocationHistory"> | string
    allocatedPct?: DecimalWithAggregatesFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalWithAggregatesFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string
    actualSales?: DecimalNullableWithAggregatesFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: DecimalNullableWithAggregatesFilter<"AllocationHistory"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AllocationHistory"> | Date | string
  }

  export type AllocationRecommendationWhereInput = {
    AND?: AllocationRecommendationWhereInput | AllocationRecommendationWhereInput[]
    OR?: AllocationRecommendationWhereInput[]
    NOT?: AllocationRecommendationWhereInput | AllocationRecommendationWhereInput[]
    id?: StringFilter<"AllocationRecommendation"> | string
    budgetDetailId?: StringFilter<"AllocationRecommendation"> | string
    dimensionType?: StringFilter<"AllocationRecommendation"> | string
    dimensionValue?: StringFilter<"AllocationRecommendation"> | string
    recommendedPct?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringNullableFilter<"AllocationRecommendation"> | string | null
    basedOnSeasons?: IntFilter<"AllocationRecommendation"> | number
    factors?: JsonNullableFilter<"AllocationRecommendation">
    isApplied?: BoolFilter<"AllocationRecommendation"> | boolean
    createdAt?: DateTimeFilter<"AllocationRecommendation"> | Date | string
    budgetDetail?: XOR<BudgetDetailRelationFilter, BudgetDetailWhereInput>
  }

  export type AllocationRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    basedOnSeasons?: SortOrder
    factors?: SortOrderInput | SortOrder
    isApplied?: SortOrder
    createdAt?: SortOrder
    budgetDetail?: BudgetDetailOrderByWithRelationInput
  }

  export type AllocationRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budgetDetailId_dimensionType_dimensionValue?: AllocationRecommendationBudgetDetailIdDimensionTypeDimensionValueCompoundUniqueInput
    AND?: AllocationRecommendationWhereInput | AllocationRecommendationWhereInput[]
    OR?: AllocationRecommendationWhereInput[]
    NOT?: AllocationRecommendationWhereInput | AllocationRecommendationWhereInput[]
    budgetDetailId?: StringFilter<"AllocationRecommendation"> | string
    dimensionType?: StringFilter<"AllocationRecommendation"> | string
    dimensionValue?: StringFilter<"AllocationRecommendation"> | string
    recommendedPct?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringNullableFilter<"AllocationRecommendation"> | string | null
    basedOnSeasons?: IntFilter<"AllocationRecommendation"> | number
    factors?: JsonNullableFilter<"AllocationRecommendation">
    isApplied?: BoolFilter<"AllocationRecommendation"> | boolean
    createdAt?: DateTimeFilter<"AllocationRecommendation"> | Date | string
    budgetDetail?: XOR<BudgetDetailRelationFilter, BudgetDetailWhereInput>
  }, "id" | "budgetDetailId_dimensionType_dimensionValue">

  export type AllocationRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    basedOnSeasons?: SortOrder
    factors?: SortOrderInput | SortOrder
    isApplied?: SortOrder
    createdAt?: SortOrder
    _count?: AllocationRecommendationCountOrderByAggregateInput
    _avg?: AllocationRecommendationAvgOrderByAggregateInput
    _max?: AllocationRecommendationMaxOrderByAggregateInput
    _min?: AllocationRecommendationMinOrderByAggregateInput
    _sum?: AllocationRecommendationSumOrderByAggregateInput
  }

  export type AllocationRecommendationScalarWhereWithAggregatesInput = {
    AND?: AllocationRecommendationScalarWhereWithAggregatesInput | AllocationRecommendationScalarWhereWithAggregatesInput[]
    OR?: AllocationRecommendationScalarWhereWithAggregatesInput[]
    NOT?: AllocationRecommendationScalarWhereWithAggregatesInput | AllocationRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AllocationRecommendation"> | string
    budgetDetailId?: StringWithAggregatesFilter<"AllocationRecommendation"> | string
    dimensionType?: StringWithAggregatesFilter<"AllocationRecommendation"> | string
    dimensionValue?: StringWithAggregatesFilter<"AllocationRecommendation"> | string
    recommendedPct?: DecimalWithAggregatesFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalWithAggregatesFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalWithAggregatesFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringNullableWithAggregatesFilter<"AllocationRecommendation"> | string | null
    basedOnSeasons?: IntWithAggregatesFilter<"AllocationRecommendation"> | number
    factors?: JsonNullableWithAggregatesFilter<"AllocationRecommendation">
    isApplied?: BoolWithAggregatesFilter<"AllocationRecommendation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AllocationRecommendation"> | Date | string
  }

  export type RiskAssessmentWhereInput = {
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    id?: StringFilter<"RiskAssessment"> | string
    entityType?: StringFilter<"RiskAssessment"> | string
    entityId?: StringFilter<"RiskAssessment"> | string
    overallScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    riskLevel?: StringFilter<"RiskAssessment"> | string
    budgetAlignmentScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    factors?: JsonNullableFilter<"RiskAssessment">
    warnings?: JsonNullableFilter<"RiskAssessment">
    recommendation?: StringNullableFilter<"RiskAssessment"> | string | null
    calculatedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    calculatedBy?: StringNullableFilter<"RiskAssessment"> | string | null
    isStale?: BoolFilter<"RiskAssessment"> | boolean
  }

  export type RiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
    factors?: SortOrderInput | SortOrder
    warnings?: SortOrderInput | SortOrder
    recommendation?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrderInput | SortOrder
    isStale?: SortOrder
  }

  export type RiskAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityType_entityId?: RiskAssessmentEntityTypeEntityIdCompoundUniqueInput
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    entityType?: StringFilter<"RiskAssessment"> | string
    entityId?: StringFilter<"RiskAssessment"> | string
    overallScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    riskLevel?: StringFilter<"RiskAssessment"> | string
    budgetAlignmentScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    factors?: JsonNullableFilter<"RiskAssessment">
    warnings?: JsonNullableFilter<"RiskAssessment">
    recommendation?: StringNullableFilter<"RiskAssessment"> | string | null
    calculatedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    calculatedBy?: StringNullableFilter<"RiskAssessment"> | string | null
    isStale?: BoolFilter<"RiskAssessment"> | boolean
  }, "id" | "entityType_entityId">

  export type RiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
    factors?: SortOrderInput | SortOrder
    warnings?: SortOrderInput | SortOrder
    recommendation?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrderInput | SortOrder
    isStale?: SortOrder
    _count?: RiskAssessmentCountOrderByAggregateInput
    _avg?: RiskAssessmentAvgOrderByAggregateInput
    _max?: RiskAssessmentMaxOrderByAggregateInput
    _min?: RiskAssessmentMinOrderByAggregateInput
    _sum?: RiskAssessmentSumOrderByAggregateInput
  }

  export type RiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: RiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAssessment"> | string
    entityType?: StringWithAggregatesFilter<"RiskAssessment"> | string
    entityId?: StringWithAggregatesFilter<"RiskAssessment"> | string
    overallScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    riskLevel?: StringWithAggregatesFilter<"RiskAssessment"> | string
    budgetAlignmentScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalWithAggregatesFilter<"RiskAssessment"> | Decimal | DecimalJsLike | number | string
    factors?: JsonNullableWithAggregatesFilter<"RiskAssessment">
    warnings?: JsonNullableWithAggregatesFilter<"RiskAssessment">
    recommendation?: StringNullableWithAggregatesFilter<"RiskAssessment"> | string | null
    calculatedAt?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
    calculatedBy?: StringNullableWithAggregatesFilter<"RiskAssessment"> | string | null
    isStale?: BoolWithAggregatesFilter<"RiskAssessment"> | boolean
  }

  export type RiskThresholdWhereInput = {
    AND?: RiskThresholdWhereInput | RiskThresholdWhereInput[]
    OR?: RiskThresholdWhereInput[]
    NOT?: RiskThresholdWhereInput | RiskThresholdWhereInput[]
    id?: StringFilter<"RiskThreshold"> | string
    factorName?: StringFilter<"RiskThreshold"> | string
    weight?: DecimalFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"RiskThreshold"> | string | null
    isActive?: BoolFilter<"RiskThreshold"> | boolean
  }

  export type RiskThresholdOrderByWithRelationInput = {
    id?: SortOrder
    factorName?: SortOrder
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
  }

  export type RiskThresholdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    factorName?: string
    AND?: RiskThresholdWhereInput | RiskThresholdWhereInput[]
    OR?: RiskThresholdWhereInput[]
    NOT?: RiskThresholdWhereInput | RiskThresholdWhereInput[]
    weight?: DecimalFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"RiskThreshold"> | string | null
    isActive?: BoolFilter<"RiskThreshold"> | boolean
  }, "id" | "factorName">

  export type RiskThresholdOrderByWithAggregationInput = {
    id?: SortOrder
    factorName?: SortOrder
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: RiskThresholdCountOrderByAggregateInput
    _avg?: RiskThresholdAvgOrderByAggregateInput
    _max?: RiskThresholdMaxOrderByAggregateInput
    _min?: RiskThresholdMinOrderByAggregateInput
    _sum?: RiskThresholdSumOrderByAggregateInput
  }

  export type RiskThresholdScalarWhereWithAggregatesInput = {
    AND?: RiskThresholdScalarWhereWithAggregatesInput | RiskThresholdScalarWhereWithAggregatesInput[]
    OR?: RiskThresholdScalarWhereWithAggregatesInput[]
    NOT?: RiskThresholdScalarWhereWithAggregatesInput | RiskThresholdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskThreshold"> | string
    factorName?: StringWithAggregatesFilter<"RiskThreshold"> | string
    weight?: DecimalWithAggregatesFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalWithAggregatesFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalWithAggregatesFilter<"RiskThreshold"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"RiskThreshold"> | string | null
    isActive?: BoolWithAggregatesFilter<"RiskThreshold"> | boolean
  }

  export type SkuPerformanceWhereInput = {
    AND?: SkuPerformanceWhereInput | SkuPerformanceWhereInput[]
    OR?: SkuPerformanceWhereInput[]
    NOT?: SkuPerformanceWhereInput | SkuPerformanceWhereInput[]
    id?: StringFilter<"SkuPerformance"> | string
    skuId?: StringFilter<"SkuPerformance"> | string
    skuCode?: StringFilter<"SkuPerformance"> | string
    seasonGroup?: StringFilter<"SkuPerformance"> | string
    fiscalYear?: IntFilter<"SkuPerformance"> | number
    storeId?: StringNullableFilter<"SkuPerformance"> | string | null
    quantityBought?: IntFilter<"SkuPerformance"> | number
    quantitySold?: IntFilter<"SkuPerformance"> | number
    sellThroughPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: IntNullableFilter<"SkuPerformance"> | number | null
    performanceScore?: IntFilter<"SkuPerformance"> | number
    velocityScore?: IntFilter<"SkuPerformance"> | number
    marginScore?: IntFilter<"SkuPerformance"> | number
    createdAt?: DateTimeFilter<"SkuPerformance"> | Date | string
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
    store?: XOR<StoreNullableRelationFilter, StoreWhereInput> | null
  }

  export type SkuPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    storeId?: SortOrderInput | SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrderInput | SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
    createdAt?: SortOrder
    sku?: SkuCatalogOrderByWithRelationInput
    store?: StoreOrderByWithRelationInput
  }

  export type SkuPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    skuId_seasonGroup_fiscalYear_storeId?: SkuPerformanceSkuIdSeasonGroupFiscalYearStoreIdCompoundUniqueInput
    AND?: SkuPerformanceWhereInput | SkuPerformanceWhereInput[]
    OR?: SkuPerformanceWhereInput[]
    NOT?: SkuPerformanceWhereInput | SkuPerformanceWhereInput[]
    skuId?: StringFilter<"SkuPerformance"> | string
    skuCode?: StringFilter<"SkuPerformance"> | string
    seasonGroup?: StringFilter<"SkuPerformance"> | string
    fiscalYear?: IntFilter<"SkuPerformance"> | number
    storeId?: StringNullableFilter<"SkuPerformance"> | string | null
    quantityBought?: IntFilter<"SkuPerformance"> | number
    quantitySold?: IntFilter<"SkuPerformance"> | number
    sellThroughPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: IntNullableFilter<"SkuPerformance"> | number | null
    performanceScore?: IntFilter<"SkuPerformance"> | number
    velocityScore?: IntFilter<"SkuPerformance"> | number
    marginScore?: IntFilter<"SkuPerformance"> | number
    createdAt?: DateTimeFilter<"SkuPerformance"> | Date | string
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
    store?: XOR<StoreNullableRelationFilter, StoreWhereInput> | null
  }, "id" | "skuId_seasonGroup_fiscalYear_storeId">

  export type SkuPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    storeId?: SortOrderInput | SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrderInput | SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
    createdAt?: SortOrder
    _count?: SkuPerformanceCountOrderByAggregateInput
    _avg?: SkuPerformanceAvgOrderByAggregateInput
    _max?: SkuPerformanceMaxOrderByAggregateInput
    _min?: SkuPerformanceMinOrderByAggregateInput
    _sum?: SkuPerformanceSumOrderByAggregateInput
  }

  export type SkuPerformanceScalarWhereWithAggregatesInput = {
    AND?: SkuPerformanceScalarWhereWithAggregatesInput | SkuPerformanceScalarWhereWithAggregatesInput[]
    OR?: SkuPerformanceScalarWhereWithAggregatesInput[]
    NOT?: SkuPerformanceScalarWhereWithAggregatesInput | SkuPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuPerformance"> | string
    skuId?: StringWithAggregatesFilter<"SkuPerformance"> | string
    skuCode?: StringWithAggregatesFilter<"SkuPerformance"> | string
    seasonGroup?: StringWithAggregatesFilter<"SkuPerformance"> | string
    fiscalYear?: IntWithAggregatesFilter<"SkuPerformance"> | number
    storeId?: StringNullableWithAggregatesFilter<"SkuPerformance"> | string | null
    quantityBought?: IntWithAggregatesFilter<"SkuPerformance"> | number
    quantitySold?: IntWithAggregatesFilter<"SkuPerformance"> | number
    sellThroughPct?: DecimalWithAggregatesFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalWithAggregatesFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalWithAggregatesFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalWithAggregatesFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalWithAggregatesFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: IntNullableWithAggregatesFilter<"SkuPerformance"> | number | null
    performanceScore?: IntWithAggregatesFilter<"SkuPerformance"> | number
    velocityScore?: IntWithAggregatesFilter<"SkuPerformance"> | number
    marginScore?: IntWithAggregatesFilter<"SkuPerformance"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SkuPerformance"> | Date | string
  }

  export type AttributeTrendWhereInput = {
    AND?: AttributeTrendWhereInput | AttributeTrendWhereInput[]
    OR?: AttributeTrendWhereInput[]
    NOT?: AttributeTrendWhereInput | AttributeTrendWhereInput[]
    id?: StringFilter<"AttributeTrend"> | string
    attributeType?: StringFilter<"AttributeTrend"> | string
    attributeValue?: StringFilter<"AttributeTrend"> | string
    category?: StringNullableFilter<"AttributeTrend"> | string | null
    seasonGroup?: StringFilter<"AttributeTrend"> | string
    fiscalYear?: IntFilter<"AttributeTrend"> | number
    totalSkus?: IntFilter<"AttributeTrend"> | number
    avgSellThrough?: DecimalFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string
    trendScore?: IntFilter<"AttributeTrend"> | number
    yoyGrowth?: DecimalNullableFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AttributeTrend"> | Date | string
  }

  export type AttributeTrendOrderByWithRelationInput = {
    id?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    category?: SortOrderInput | SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AttributeTrendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    attributeType_attributeValue_category_seasonGroup_fiscalYear?: AttributeTrendAttributeTypeAttributeValueCategorySeasonGroupFiscalYearCompoundUniqueInput
    AND?: AttributeTrendWhereInput | AttributeTrendWhereInput[]
    OR?: AttributeTrendWhereInput[]
    NOT?: AttributeTrendWhereInput | AttributeTrendWhereInput[]
    attributeType?: StringFilter<"AttributeTrend"> | string
    attributeValue?: StringFilter<"AttributeTrend"> | string
    category?: StringNullableFilter<"AttributeTrend"> | string | null
    seasonGroup?: StringFilter<"AttributeTrend"> | string
    fiscalYear?: IntFilter<"AttributeTrend"> | number
    totalSkus?: IntFilter<"AttributeTrend"> | number
    avgSellThrough?: DecimalFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string
    trendScore?: IntFilter<"AttributeTrend"> | number
    yoyGrowth?: DecimalNullableFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"AttributeTrend"> | Date | string
  }, "id" | "attributeType_attributeValue_category_seasonGroup_fiscalYear">

  export type AttributeTrendOrderByWithAggregationInput = {
    id?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    category?: SortOrderInput | SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttributeTrendCountOrderByAggregateInput
    _avg?: AttributeTrendAvgOrderByAggregateInput
    _max?: AttributeTrendMaxOrderByAggregateInput
    _min?: AttributeTrendMinOrderByAggregateInput
    _sum?: AttributeTrendSumOrderByAggregateInput
  }

  export type AttributeTrendScalarWhereWithAggregatesInput = {
    AND?: AttributeTrendScalarWhereWithAggregatesInput | AttributeTrendScalarWhereWithAggregatesInput[]
    OR?: AttributeTrendScalarWhereWithAggregatesInput[]
    NOT?: AttributeTrendScalarWhereWithAggregatesInput | AttributeTrendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttributeTrend"> | string
    attributeType?: StringWithAggregatesFilter<"AttributeTrend"> | string
    attributeValue?: StringWithAggregatesFilter<"AttributeTrend"> | string
    category?: StringNullableWithAggregatesFilter<"AttributeTrend"> | string | null
    seasonGroup?: StringWithAggregatesFilter<"AttributeTrend"> | string
    fiscalYear?: IntWithAggregatesFilter<"AttributeTrend"> | number
    totalSkus?: IntWithAggregatesFilter<"AttributeTrend"> | number
    avgSellThrough?: DecimalWithAggregatesFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalWithAggregatesFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string
    trendScore?: IntWithAggregatesFilter<"AttributeTrend"> | number
    yoyGrowth?: DecimalNullableWithAggregatesFilter<"AttributeTrend"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttributeTrend"> | Date | string
  }

  export type SkuRecommendationWhereInput = {
    AND?: SkuRecommendationWhereInput | SkuRecommendationWhereInput[]
    OR?: SkuRecommendationWhereInput[]
    NOT?: SkuRecommendationWhereInput | SkuRecommendationWhereInput[]
    id?: StringFilter<"SkuRecommendation"> | string
    budgetDetailId?: StringFilter<"SkuRecommendation"> | string
    category?: StringFilter<"SkuRecommendation"> | string
    subCategory?: StringNullableFilter<"SkuRecommendation"> | string | null
    skuId?: StringFilter<"SkuRecommendation"> | string
    skuCode?: StringFilter<"SkuRecommendation"> | string
    productName?: StringFilter<"SkuRecommendation"> | string
    recommendedQty?: IntFilter<"SkuRecommendation"> | number
    recommendedValue?: DecimalFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFilter<"SkuRecommendation"> | number
    trendScore?: IntFilter<"SkuRecommendation"> | number
    assortmentScore?: IntFilter<"SkuRecommendation"> | number
    priceScore?: IntFilter<"SkuRecommendation"> | number
    overallScore?: IntFilter<"SkuRecommendation"> | number
    riskLevel?: StringFilter<"SkuRecommendation"> | string
    reasoning?: StringNullableFilter<"SkuRecommendation"> | string | null
    isSelected?: BoolFilter<"SkuRecommendation"> | boolean
    isRejected?: BoolFilter<"SkuRecommendation"> | boolean
    createdAt?: DateTimeFilter<"SkuRecommendation"> | Date | string
    budgetDetail?: XOR<BudgetDetailRelationFilter, BudgetDetailWhereInput>
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
  }

  export type SkuRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    isRejected?: SortOrder
    createdAt?: SortOrder
    budgetDetail?: BudgetDetailOrderByWithRelationInput
    sku?: SkuCatalogOrderByWithRelationInput
  }

  export type SkuRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkuRecommendationWhereInput | SkuRecommendationWhereInput[]
    OR?: SkuRecommendationWhereInput[]
    NOT?: SkuRecommendationWhereInput | SkuRecommendationWhereInput[]
    budgetDetailId?: StringFilter<"SkuRecommendation"> | string
    category?: StringFilter<"SkuRecommendation"> | string
    subCategory?: StringNullableFilter<"SkuRecommendation"> | string | null
    skuId?: StringFilter<"SkuRecommendation"> | string
    skuCode?: StringFilter<"SkuRecommendation"> | string
    productName?: StringFilter<"SkuRecommendation"> | string
    recommendedQty?: IntFilter<"SkuRecommendation"> | number
    recommendedValue?: DecimalFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFilter<"SkuRecommendation"> | number
    trendScore?: IntFilter<"SkuRecommendation"> | number
    assortmentScore?: IntFilter<"SkuRecommendation"> | number
    priceScore?: IntFilter<"SkuRecommendation"> | number
    overallScore?: IntFilter<"SkuRecommendation"> | number
    riskLevel?: StringFilter<"SkuRecommendation"> | string
    reasoning?: StringNullableFilter<"SkuRecommendation"> | string | null
    isSelected?: BoolFilter<"SkuRecommendation"> | boolean
    isRejected?: BoolFilter<"SkuRecommendation"> | boolean
    createdAt?: DateTimeFilter<"SkuRecommendation"> | Date | string
    budgetDetail?: XOR<BudgetDetailRelationFilter, BudgetDetailWhereInput>
    sku?: XOR<SkuCatalogRelationFilter, SkuCatalogWhereInput>
  }, "id">

  export type SkuRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrderInput | SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    reasoning?: SortOrderInput | SortOrder
    isSelected?: SortOrder
    isRejected?: SortOrder
    createdAt?: SortOrder
    _count?: SkuRecommendationCountOrderByAggregateInput
    _avg?: SkuRecommendationAvgOrderByAggregateInput
    _max?: SkuRecommendationMaxOrderByAggregateInput
    _min?: SkuRecommendationMinOrderByAggregateInput
    _sum?: SkuRecommendationSumOrderByAggregateInput
  }

  export type SkuRecommendationScalarWhereWithAggregatesInput = {
    AND?: SkuRecommendationScalarWhereWithAggregatesInput | SkuRecommendationScalarWhereWithAggregatesInput[]
    OR?: SkuRecommendationScalarWhereWithAggregatesInput[]
    NOT?: SkuRecommendationScalarWhereWithAggregatesInput | SkuRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    budgetDetailId?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    category?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    subCategory?: StringNullableWithAggregatesFilter<"SkuRecommendation"> | string | null
    skuId?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    skuCode?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    productName?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    recommendedQty?: IntWithAggregatesFilter<"SkuRecommendation"> | number
    recommendedValue?: DecimalWithAggregatesFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalWithAggregatesFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    performanceScore?: IntWithAggregatesFilter<"SkuRecommendation"> | number
    trendScore?: IntWithAggregatesFilter<"SkuRecommendation"> | number
    assortmentScore?: IntWithAggregatesFilter<"SkuRecommendation"> | number
    priceScore?: IntWithAggregatesFilter<"SkuRecommendation"> | number
    overallScore?: IntWithAggregatesFilter<"SkuRecommendation"> | number
    riskLevel?: StringWithAggregatesFilter<"SkuRecommendation"> | string
    reasoning?: StringNullableWithAggregatesFilter<"SkuRecommendation"> | string | null
    isSelected?: BoolWithAggregatesFilter<"SkuRecommendation"> | boolean
    isRejected?: BoolWithAggregatesFilter<"SkuRecommendation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SkuRecommendation"> | Date | string
  }

  export type ApprovalWorkflowStepWhereInput = {
    AND?: ApprovalWorkflowStepWhereInput | ApprovalWorkflowStepWhereInput[]
    OR?: ApprovalWorkflowStepWhereInput[]
    NOT?: ApprovalWorkflowStepWhereInput | ApprovalWorkflowStepWhereInput[]
    id?: StringFilter<"ApprovalWorkflowStep"> | string
    brandId?: StringFilter<"ApprovalWorkflowStep"> | string
    stepNumber?: IntFilter<"ApprovalWorkflowStep"> | number
    roleName?: StringFilter<"ApprovalWorkflowStep"> | string
    roleCode?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    userId?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    description?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    isActive?: BoolFilter<"ApprovalWorkflowStep"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflowStep"> | Date | string
    brand?: XOR<GroupBrandRelationFilter, GroupBrandWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ApprovalWorkflowStepOrderByWithRelationInput = {
    id?: SortOrder
    brandId?: SortOrder
    stepNumber?: SortOrder
    roleName?: SortOrder
    roleCode?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: GroupBrandOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ApprovalWorkflowStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    brandId_stepNumber?: ApprovalWorkflowStepBrandIdStepNumberCompoundUniqueInput
    AND?: ApprovalWorkflowStepWhereInput | ApprovalWorkflowStepWhereInput[]
    OR?: ApprovalWorkflowStepWhereInput[]
    NOT?: ApprovalWorkflowStepWhereInput | ApprovalWorkflowStepWhereInput[]
    brandId?: StringFilter<"ApprovalWorkflowStep"> | string
    stepNumber?: IntFilter<"ApprovalWorkflowStep"> | number
    roleName?: StringFilter<"ApprovalWorkflowStep"> | string
    roleCode?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    userId?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    description?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    isActive?: BoolFilter<"ApprovalWorkflowStep"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflowStep"> | Date | string
    brand?: XOR<GroupBrandRelationFilter, GroupBrandWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "brandId_stepNumber">

  export type ApprovalWorkflowStepOrderByWithAggregationInput = {
    id?: SortOrder
    brandId?: SortOrder
    stepNumber?: SortOrder
    roleName?: SortOrder
    roleCode?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalWorkflowStepCountOrderByAggregateInput
    _avg?: ApprovalWorkflowStepAvgOrderByAggregateInput
    _max?: ApprovalWorkflowStepMaxOrderByAggregateInput
    _min?: ApprovalWorkflowStepMinOrderByAggregateInput
    _sum?: ApprovalWorkflowStepSumOrderByAggregateInput
  }

  export type ApprovalWorkflowStepScalarWhereWithAggregatesInput = {
    AND?: ApprovalWorkflowStepScalarWhereWithAggregatesInput | ApprovalWorkflowStepScalarWhereWithAggregatesInput[]
    OR?: ApprovalWorkflowStepScalarWhereWithAggregatesInput[]
    NOT?: ApprovalWorkflowStepScalarWhereWithAggregatesInput | ApprovalWorkflowStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalWorkflowStep"> | string
    brandId?: StringWithAggregatesFilter<"ApprovalWorkflowStep"> | string
    stepNumber?: IntWithAggregatesFilter<"ApprovalWorkflowStep"> | number
    roleName?: StringWithAggregatesFilter<"ApprovalWorkflowStep"> | string
    roleCode?: StringNullableWithAggregatesFilter<"ApprovalWorkflowStep"> | string | null
    userId?: StringNullableWithAggregatesFilter<"ApprovalWorkflowStep"> | string | null
    description?: StringNullableWithAggregatesFilter<"ApprovalWorkflowStep"> | string | null
    isActive?: BoolWithAggregatesFilter<"ApprovalWorkflowStep"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalWorkflowStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalWorkflowStep"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type GroupBrandCreateInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    budgets?: BudgetCreateNestedManyWithoutGroupBrandInput
    skuCatalog?: SkuCatalogCreateNestedManyWithoutBrandInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    budgets?: BudgetUncheckedCreateNestedManyWithoutGroupBrandInput
    skuCatalog?: SkuCatalogUncheckedCreateNestedManyWithoutBrandInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    budgets?: BudgetUpdateManyWithoutGroupBrandNestedInput
    skuCatalog?: SkuCatalogUpdateManyWithoutBrandNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutBrandNestedInput
  }

  export type GroupBrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    budgets?: BudgetUncheckedUpdateManyWithoutGroupBrandNestedInput
    skuCatalog?: SkuCatalogUncheckedUpdateManyWithoutBrandNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type GroupBrandCreateManyInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
  }

  export type GroupBrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type GroupBrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StoreCreateInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailUncheckedCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationUncheckedCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryUncheckedCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUncheckedUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUncheckedUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUncheckedUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CollectionCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    planningDetails?: PlanningDetailCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUncheckedCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type CollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type CollectionCreateManyInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type CollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenderCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    categories?: CategoryCreateNestedManyWithoutGenderInput
    planningDetails?: PlanningDetailCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    categories?: CategoryUncheckedCreateNestedManyWithoutGenderInput
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categories?: CategoryUpdateManyWithoutGenderNestedInput
    planningDetails?: PlanningDetailUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categories?: CategoryUncheckedUpdateManyWithoutGenderNestedInput
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type GenderCreateManyInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type GenderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    gender: GenderCreateNestedOneWithoutCategoriesInput
    subCategories?: SubCategoryCreateNestedManyWithoutCategoryInput
    planningDetails?: PlanningDetailCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    genderId: string
    isActive?: boolean
    subCategories?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    gender?: GenderUpdateOneRequiredWithoutCategoriesNestedInput
    subCategories?: SubCategoryUpdateManyWithoutCategoryNestedInput
    planningDetails?: PlanningDetailUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genderId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategories?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    genderId: string
    isActive?: boolean
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genderId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubCategoryCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    category: CategoryCreateNestedOneWithoutSubCategoriesInput
    planningDetails?: PlanningDetailCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id?: string
    name: string
    categoryId: string
    isActive?: boolean
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput
    planningDetails?: PlanningDetailUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryCreateManyInput = {
    id?: string
    name: string
    categoryId: string
    isActive?: boolean
  }

  export type SubCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkuCatalogCreateInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    brand?: GroupBrandCreateNestedOneWithoutSkuCatalogInput
    products?: ProposalProductCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUncheckedCreateInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    brandId?: string | null
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    products?: ProposalProductUncheckedCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    brand?: GroupBrandUpdateOneWithoutSkuCatalogNestedInput
    products?: ProposalProductUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: ProposalProductUncheckedUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogCreateManyInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    brandId?: string | null
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
  }

  export type SkuCatalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkuCatalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BudgetCreateInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupBrand: GroupBrandCreateNestedOneWithoutBudgetsInput
    createdBy: UserCreateNestedOneWithoutCreatedBudgetsInput
    details?: BudgetDetailCreateNestedManyWithoutBudgetInput
    proposals?: ProposalCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupBrand?: GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput
    details?: BudgetDetailUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateManyInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetDetailCreateInput = {
    id?: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    budget: BudgetCreateNestedOneWithoutDetailsInput
    store: StoreCreateNestedOneWithoutBudgetDetailsInput
    planningVersions?: PlanningVersionCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUncheckedCreateInput = {
    id?: string
    budgetId: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    budget?: BudgetUpdateOneRequiredWithoutDetailsNestedInput
    store?: StoreUpdateOneRequiredWithoutBudgetDetailsNestedInput
    planningVersions?: PlanningVersionUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailCreateManyInput = {
    id?: string
    budgetId: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PlanningVersionCreateInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutPlanningVersionsInput
    createdBy: UserCreateNestedOneWithoutCreatedPlanningsInput
    details?: PlanningDetailCreateNestedManyWithoutPlanningVersionInput
    proposals?: ProposalCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionUncheckedCreateInput = {
    id?: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: PlanningDetailUncheckedCreateNestedManyWithoutPlanningVersionInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutPlanningVersionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPlanningsNestedInput
    details?: PlanningDetailUpdateManyWithoutPlanningVersionNestedInput
    proposals?: ProposalUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: PlanningDetailUncheckedUpdateManyWithoutPlanningVersionNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionCreateManyInput = {
    id?: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanningVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningDetailCreateInput = {
    id?: string
    dimensionType: string
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
    planningVersion: PlanningVersionCreateNestedOneWithoutDetailsInput
    collection?: CollectionCreateNestedOneWithoutPlanningDetailsInput
    gender?: GenderCreateNestedOneWithoutPlanningDetailsInput
    category?: CategoryCreateNestedOneWithoutPlanningDetailsInput
    subCategory?: SubCategoryCreateNestedOneWithoutPlanningDetailsInput
  }

  export type PlanningDetailUncheckedCreateInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
    planningVersion?: PlanningVersionUpdateOneRequiredWithoutDetailsNestedInput
    collection?: CollectionUpdateOneWithoutPlanningDetailsNestedInput
    gender?: GenderUpdateOneWithoutPlanningDetailsNestedInput
    category?: CategoryUpdateOneWithoutPlanningDetailsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutPlanningDetailsNestedInput
  }

  export type PlanningDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailCreateManyInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProposalCreateInput = {
    id?: string
    ticketName: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutProposalsInput
    planningVersion?: PlanningVersionCreateNestedOneWithoutProposalsInput
    createdBy: UserCreateNestedOneWithoutCreatedProposalsInput
    products?: ProposalProductCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: string
    ticketName: string
    budgetId: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProposalProductUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutProposalsNestedInput
    planningVersion?: PlanningVersionUpdateOneWithoutProposalsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProposalsNestedInput
    products?: ProposalProductUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProposalProductUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalCreateManyInput = {
    id?: string
    ticketName: string
    budgetId: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalProductCreateInput = {
    id?: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    proposal: ProposalCreateNestedOneWithoutProductsInput
    sku: SkuCatalogCreateNestedOneWithoutProductsInput
    allocations?: ProductAllocationCreateNestedManyWithoutProposalProductInput
  }

  export type ProposalProductUncheckedCreateInput = {
    id?: string
    proposalId: string
    skuId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    allocations?: ProductAllocationUncheckedCreateNestedManyWithoutProposalProductInput
  }

  export type ProposalProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    proposal?: ProposalUpdateOneRequiredWithoutProductsNestedInput
    sku?: SkuCatalogUpdateOneRequiredWithoutProductsNestedInput
    allocations?: ProductAllocationUpdateManyWithoutProposalProductNestedInput
  }

  export type ProposalProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    allocations?: ProductAllocationUncheckedUpdateManyWithoutProposalProductNestedInput
  }

  export type ProposalProductCreateManyInput = {
    id?: string
    proposalId: string
    skuId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
  }

  export type ProposalProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProposalProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductAllocationCreateInput = {
    id?: string
    quantity?: number
    proposalProduct: ProposalProductCreateNestedOneWithoutAllocationsInput
    store: StoreCreateNestedOneWithoutProductAllocationsInput
  }

  export type ProductAllocationUncheckedCreateInput = {
    id?: string
    proposalProductId: string
    storeId: string
    quantity?: number
  }

  export type ProductAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    proposalProduct?: ProposalProductUpdateOneRequiredWithoutAllocationsNestedInput
    store?: StoreUpdateOneRequiredWithoutProductAllocationsNestedInput
  }

  export type ProductAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalProductId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductAllocationCreateManyInput = {
    id?: string
    proposalProductId: string
    storeId: string
    quantity?: number
  }

  export type ProductAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalProductId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ApprovalCreateInput = {
    id?: string
    entityType: string
    entityId: string
    level: number
    action: $Enums.ApprovalAction
    comment?: string | null
    decidedAt?: Date | string
    decider: UserCreateNestedOneWithoutApprovalDecisionsInput
  }

  export type ApprovalUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    level: number
    deciderId: string
    action: $Enums.ApprovalAction
    comment?: string | null
    decidedAt?: Date | string
  }

  export type ApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decider?: UserUpdateOneRequiredWithoutApprovalDecisionsNestedInput
  }

  export type ApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deciderId?: StringFieldUpdateOperationsInput | string
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    level: number
    deciderId: string
    action: $Enums.ApprovalAction
    comment?: string | null
    decidedAt?: Date | string
  }

  export type ApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    deciderId?: StringFieldUpdateOperationsInput | string
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    entityType: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesHistoryCreateInput = {
    id?: string
    skuCode: string
    sizeCode: string
    season: string
    quantitySold?: number
    quantityBought?: number
    sellThroughPct?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutSalesHistoryInput
  }

  export type SalesHistoryUncheckedCreateInput = {
    id?: string
    skuCode: string
    storeId: string
    sizeCode: string
    season: string
    quantitySold?: number
    quantityBought?: number
    sellThroughPct?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalesHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSalesHistoryNestedInput
  }

  export type SalesHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesHistoryCreateManyInput = {
    id?: string
    skuCode: string
    storeId: string
    sizeCode: string
    season: string
    quantitySold?: number
    quantityBought?: number
    sellThroughPct?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalesHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeCurveRecommendationCreateInput = {
    id?: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
    sku: SkuCatalogCreateNestedOneWithoutSizeCurveRecommendationsInput
    store: StoreCreateNestedOneWithoutSizeCurveRecommendationsInput
  }

  export type SizeCurveRecommendationUncheckedCreateInput = {
    id?: string
    skuId: string
    storeId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
  }

  export type SizeCurveRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: SkuCatalogUpdateOneRequiredWithoutSizeCurveRecommendationsNestedInput
    store?: StoreUpdateOneRequiredWithoutSizeCurveRecommendationsNestedInput
  }

  export type SizeCurveRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeCurveRecommendationCreateManyInput = {
    id?: string
    skuId: string
    storeId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
  }

  export type SizeCurveRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeCurveRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetAlertCreateInput = {
    id?: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    category?: string | null
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: Date | string
    budget: BudgetCreateNestedOneWithoutBudgetAlertsInput
  }

  export type BudgetAlertUncheckedCreateInput = {
    id?: string
    budgetId: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    category?: string | null
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: Date | string
  }

  export type BudgetAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutBudgetAlertsNestedInput
  }

  export type BudgetAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetAlertCreateManyInput = {
    id?: string
    budgetId: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    category?: string | null
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: Date | string
  }

  export type BudgetAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetSnapshotCreateInput = {
    id?: string
    snapshotDate: Date | string
    totalCommitted?: Decimal | DecimalJsLike | number | string
    totalPlanned?: Decimal | DecimalJsLike | number | string
    utilizationPct?: Decimal | DecimalJsLike | number | string
    budget: BudgetCreateNestedOneWithoutBudgetSnapshotsInput
  }

  export type BudgetSnapshotUncheckedCreateInput = {
    id?: string
    budgetId: string
    snapshotDate: Date | string
    totalCommitted?: Decimal | DecimalJsLike | number | string
    totalPlanned?: Decimal | DecimalJsLike | number | string
    utilizationPct?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    budget?: BudgetUpdateOneRequiredWithoutBudgetSnapshotsNestedInput
  }

  export type BudgetSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotCreateManyInput = {
    id?: string
    budgetId: string
    snapshotDate: Date | string
    totalCommitted?: Decimal | DecimalJsLike | number | string
    totalPlanned?: Decimal | DecimalJsLike | number | string
    utilizationPct?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AllocationHistoryCreateInput = {
    id?: string
    budgetId: string
    seasonGroup: string
    seasonType: string
    fiscalYear: number
    dimensionType: string
    dimensionValue: string
    allocatedPct: Decimal | DecimalJsLike | number | string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    actualSales?: Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AllocationHistoryUncheckedCreateInput = {
    id?: string
    budgetId: string
    seasonGroup: string
    seasonType: string
    fiscalYear: number
    dimensionType: string
    dimensionValue: string
    allocatedPct: Decimal | DecimalJsLike | number | string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    actualSales?: Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AllocationHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    allocatedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    allocatedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationHistoryCreateManyInput = {
    id?: string
    budgetId: string
    seasonGroup: string
    seasonType: string
    fiscalYear: number
    dimensionType: string
    dimensionValue: string
    allocatedPct: Decimal | DecimalJsLike | number | string
    allocatedAmount: Decimal | DecimalJsLike | number | string
    actualSales?: Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AllocationHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    allocatedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    allocatedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocatedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actualSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    sellThroughPct?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationRecommendationCreateInput = {
    id?: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    recommendedAmt: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    reasoning?: string | null
    basedOnSeasons: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: boolean
    createdAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutAllocationRecommendationsInput
  }

  export type AllocationRecommendationUncheckedCreateInput = {
    id?: string
    budgetDetailId: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    recommendedAmt: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    reasoning?: string | null
    basedOnSeasons: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: boolean
    createdAt?: Date | string
  }

  export type AllocationRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutAllocationRecommendationsNestedInput
  }

  export type AllocationRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationRecommendationCreateManyInput = {
    id?: string
    budgetDetailId: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    recommendedAmt: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    reasoning?: string | null
    basedOnSeasons: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: boolean
    createdAt?: Date | string
  }

  export type AllocationRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateInput = {
    id?: string
    entityType: string
    entityId: string
    overallScore: Decimal | DecimalJsLike | number | string
    riskLevel: string
    budgetAlignmentScore: Decimal | DecimalJsLike | number | string
    skuDiversityScore: Decimal | DecimalJsLike | number | string
    sizeCurveScore: Decimal | DecimalJsLike | number | string
    vendorConcentrationScore: Decimal | DecimalJsLike | number | string
    categoryBalanceScore: Decimal | DecimalJsLike | number | string
    marginImpactScore: Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isStale?: boolean
  }

  export type RiskAssessmentUncheckedCreateInput = {
    id?: string
    entityType: string
    entityId: string
    overallScore: Decimal | DecimalJsLike | number | string
    riskLevel: string
    budgetAlignmentScore: Decimal | DecimalJsLike | number | string
    skuDiversityScore: Decimal | DecimalJsLike | number | string
    sizeCurveScore: Decimal | DecimalJsLike | number | string
    vendorConcentrationScore: Decimal | DecimalJsLike | number | string
    categoryBalanceScore: Decimal | DecimalJsLike | number | string
    marginImpactScore: Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isStale?: boolean
  }

  export type RiskAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    overallScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    budgetAlignmentScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isStale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    overallScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    budgetAlignmentScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isStale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskAssessmentCreateManyInput = {
    id?: string
    entityType: string
    entityId: string
    overallScore: Decimal | DecimalJsLike | number | string
    riskLevel: string
    budgetAlignmentScore: Decimal | DecimalJsLike | number | string
    skuDiversityScore: Decimal | DecimalJsLike | number | string
    sizeCurveScore: Decimal | DecimalJsLike | number | string
    vendorConcentrationScore: Decimal | DecimalJsLike | number | string
    categoryBalanceScore: Decimal | DecimalJsLike | number | string
    marginImpactScore: Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: string | null
    calculatedAt?: Date | string
    calculatedBy?: string | null
    isStale?: boolean
  }

  export type RiskAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    overallScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    budgetAlignmentScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isStale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    overallScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    riskLevel?: StringFieldUpdateOperationsInput | string
    budgetAlignmentScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    skuDiversityScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sizeCurveScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    vendorConcentrationScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    categoryBalanceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginImpactScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    factors?: NullableJsonNullValueInput | InputJsonValue
    warnings?: NullableJsonNullValueInput | InputJsonValue
    recommendation?: NullableStringFieldUpdateOperationsInput | string | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    isStale?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskThresholdCreateInput = {
    id?: string
    factorName: string
    weight: Decimal | DecimalJsLike | number | string
    lowThreshold: Decimal | DecimalJsLike | number | string
    highThreshold: Decimal | DecimalJsLike | number | string
    description?: string | null
    isActive?: boolean
  }

  export type RiskThresholdUncheckedCreateInput = {
    id?: string
    factorName: string
    weight: Decimal | DecimalJsLike | number | string
    lowThreshold: Decimal | DecimalJsLike | number | string
    highThreshold: Decimal | DecimalJsLike | number | string
    description?: string | null
    isActive?: boolean
  }

  export type RiskThresholdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factorName?: StringFieldUpdateOperationsInput | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskThresholdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factorName?: StringFieldUpdateOperationsInput | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskThresholdCreateManyInput = {
    id?: string
    factorName: string
    weight: Decimal | DecimalJsLike | number | string
    lowThreshold: Decimal | DecimalJsLike | number | string
    highThreshold: Decimal | DecimalJsLike | number | string
    description?: string | null
    isActive?: boolean
  }

  export type RiskThresholdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    factorName?: StringFieldUpdateOperationsInput | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RiskThresholdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    factorName?: StringFieldUpdateOperationsInput | string
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lowThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highThreshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkuPerformanceCreateInput = {
    id?: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
    sku: SkuCatalogCreateNestedOneWithoutSkuPerformanceInput
    store?: StoreCreateNestedOneWithoutSkuPerformanceInput
  }

  export type SkuPerformanceUncheckedCreateInput = {
    id?: string
    skuId: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    storeId?: string | null
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
  }

  export type SkuPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: SkuCatalogUpdateOneRequiredWithoutSkuPerformanceNestedInput
    store?: StoreUpdateOneWithoutSkuPerformanceNestedInput
  }

  export type SkuPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuPerformanceCreateManyInput = {
    id?: string
    skuId: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    storeId?: string | null
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
  }

  export type SkuPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttributeTrendCreateInput = {
    id?: string
    attributeType: string
    attributeValue: string
    category?: string | null
    seasonGroup: string
    fiscalYear: number
    totalSkus: number
    avgSellThrough: Decimal | DecimalJsLike | number | string
    avgMargin: Decimal | DecimalJsLike | number | string
    trendScore: number
    yoyGrowth?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AttributeTrendUncheckedCreateInput = {
    id?: string
    attributeType: string
    attributeValue: string
    category?: string | null
    seasonGroup: string
    fiscalYear: number
    totalSkus: number
    avgSellThrough: Decimal | DecimalJsLike | number | string
    avgMargin: Decimal | DecimalJsLike | number | string
    trendScore: number
    yoyGrowth?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AttributeTrendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeType?: StringFieldUpdateOperationsInput | string
    attributeValue?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalSkus?: IntFieldUpdateOperationsInput | number
    avgSellThrough?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trendScore?: IntFieldUpdateOperationsInput | number
    yoyGrowth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttributeTrendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeType?: StringFieldUpdateOperationsInput | string
    attributeValue?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalSkus?: IntFieldUpdateOperationsInput | number
    avgSellThrough?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trendScore?: IntFieldUpdateOperationsInput | number
    yoyGrowth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttributeTrendCreateManyInput = {
    id?: string
    attributeType: string
    attributeValue: string
    category?: string | null
    seasonGroup: string
    fiscalYear: number
    totalSkus: number
    avgSellThrough: Decimal | DecimalJsLike | number | string
    avgMargin: Decimal | DecimalJsLike | number | string
    trendScore: number
    yoyGrowth?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type AttributeTrendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeType?: StringFieldUpdateOperationsInput | string
    attributeValue?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalSkus?: IntFieldUpdateOperationsInput | number
    avgSellThrough?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trendScore?: IntFieldUpdateOperationsInput | number
    yoyGrowth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttributeTrendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attributeType?: StringFieldUpdateOperationsInput | string
    attributeValue?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalSkus?: IntFieldUpdateOperationsInput | number
    avgSellThrough?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgMargin?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    trendScore?: IntFieldUpdateOperationsInput | number
    yoyGrowth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationCreateInput = {
    id?: string
    category: string
    subCategory?: string | null
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutSkuRecommendationsInput
    sku: SkuCatalogCreateNestedOneWithoutSkuRecommendationsInput
  }

  export type SkuRecommendationUncheckedCreateInput = {
    id?: string
    budgetDetailId: string
    category: string
    subCategory?: string | null
    skuId: string
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
  }

  export type SkuRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutSkuRecommendationsNestedInput
    sku?: SkuCatalogUpdateOneRequiredWithoutSkuRecommendationsNestedInput
  }

  export type SkuRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationCreateManyInput = {
    id?: string
    budgetDetailId: string
    category: string
    subCategory?: string | null
    skuId: string
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
  }

  export type SkuRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowStepCreateInput = {
    id?: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: GroupBrandCreateNestedOneWithoutWorkflowStepsInput
    user?: UserCreateNestedOneWithoutWorkflowStepsInput
  }

  export type ApprovalWorkflowStepUncheckedCreateInput = {
    id?: string
    brandId: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    userId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: GroupBrandUpdateOneRequiredWithoutWorkflowStepsNestedInput
    user?: UserUpdateOneWithoutWorkflowStepsNestedInput
  }

  export type ApprovalWorkflowStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowStepCreateManyInput = {
    id?: string
    brandId: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    userId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type PlanningVersionListRelationFilter = {
    every?: PlanningVersionWhereInput
    some?: PlanningVersionWhereInput
    none?: PlanningVersionWhereInput
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ApprovalWorkflowStepListRelationFilter = {
    every?: ApprovalWorkflowStepWhereInput
    some?: ApprovalWorkflowStepWhereInput
    none?: ApprovalWorkflowStepWhereInput
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanningVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalWorkflowStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    storeAccess?: SortOrder
    brandAccess?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SkuCatalogListRelationFilter = {
    every?: SkuCatalogWhereInput
    some?: SkuCatalogWhereInput
    none?: SkuCatalogWhereInput
  }

  export type SkuCatalogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupBrandCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    colorConfig?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
  }

  export type GroupBrandAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type GroupBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
  }

  export type GroupBrandMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    groupId?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
  }

  export type GroupBrandSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BudgetDetailListRelationFilter = {
    every?: BudgetDetailWhereInput
    some?: BudgetDetailWhereInput
    none?: BudgetDetailWhereInput
  }

  export type ProductAllocationListRelationFilter = {
    every?: ProductAllocationWhereInput
    some?: ProductAllocationWhereInput
    none?: ProductAllocationWhereInput
  }

  export type SalesHistoryListRelationFilter = {
    every?: SalesHistoryWhereInput
    some?: SalesHistoryWhereInput
    none?: SalesHistoryWhereInput
  }

  export type SizeCurveRecommendationListRelationFilter = {
    every?: SizeCurveRecommendationWhereInput
    some?: SizeCurveRecommendationWhereInput
    none?: SizeCurveRecommendationWhereInput
  }

  export type SkuPerformanceListRelationFilter = {
    every?: SkuPerformanceWhereInput
    some?: SkuPerformanceWhereInput
    none?: SkuPerformanceWhereInput
  }

  export type BudgetDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SizeCurveRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuPerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    region?: SortOrder
    isActive?: SortOrder
  }

  export type PlanningDetailListRelationFilter = {
    every?: PlanningDetailWhereInput
    some?: PlanningDetailWhereInput
    none?: PlanningDetailWhereInput
  }

  export type PlanningDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type CollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type CollectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type GenderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type GenderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
  }

  export type GenderRelationFilter = {
    is?: GenderWhereInput
    isNot?: GenderWhereInput
  }

  export type SubCategoryListRelationFilter = {
    every?: SubCategoryWhereInput
    some?: SubCategoryWhereInput
    none?: SubCategoryWhereInput
  }

  export type SubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genderId?: SortOrder
    isActive?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    isActive?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    isActive?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    isActive?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type GroupBrandNullableRelationFilter = {
    is?: GroupBrandWhereInput | null
    isNot?: GroupBrandWhereInput | null
  }

  export type ProposalProductListRelationFilter = {
    every?: ProposalProductWhereInput
    some?: ProposalProductWhereInput
    none?: ProposalProductWhereInput
  }

  export type SkuRecommendationListRelationFilter = {
    every?: SkuRecommendationWhereInput
    some?: SkuRecommendationWhereInput
    none?: SkuRecommendationWhereInput
  }

  export type ProposalProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkuCatalogCountOrderByAggregateInput = {
    id?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    productType?: SortOrder
    theme?: SortOrder
    color?: SortOrder
    composition?: SortOrder
    srp?: SortOrder
    brandId?: SortOrder
    seasonGroupId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
  }

  export type SkuCatalogAvgOrderByAggregateInput = {
    srp?: SortOrder
  }

  export type SkuCatalogMaxOrderByAggregateInput = {
    id?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    productType?: SortOrder
    theme?: SortOrder
    color?: SortOrder
    composition?: SortOrder
    srp?: SortOrder
    brandId?: SortOrder
    seasonGroupId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
  }

  export type SkuCatalogMinOrderByAggregateInput = {
    id?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    productType?: SortOrder
    theme?: SortOrder
    color?: SortOrder
    composition?: SortOrder
    srp?: SortOrder
    brandId?: SortOrder
    seasonGroupId?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
  }

  export type SkuCatalogSumOrderByAggregateInput = {
    srp?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumBudgetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusFilter<$PrismaModel> | $Enums.BudgetStatus
  }

  export type GroupBrandRelationFilter = {
    is?: GroupBrandWhereInput
    isNot?: GroupBrandWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BudgetAlertListRelationFilter = {
    every?: BudgetAlertWhereInput
    some?: BudgetAlertWhereInput
    none?: BudgetAlertWhereInput
  }

  export type BudgetSnapshotListRelationFilter = {
    every?: BudgetSnapshotWhereInput
    some?: BudgetSnapshotWhereInput
    none?: BudgetSnapshotWhereInput
  }

  export type BudgetAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetGroupBrandIdSeasonGroupIdSeasonTypeFiscalYearCompoundUniqueInput = {
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    budgetCode?: SortOrder
    groupBrandId?: SortOrder
    seasonGroupId?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetCode?: SortOrder
    groupBrandId?: SortOrder
    seasonGroupId?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    budgetCode?: SortOrder
    groupBrandId?: SortOrder
    seasonGroupId?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    fiscalYear?: SortOrder
    totalBudget?: SortOrder
  }

  export type EnumBudgetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel> | $Enums.BudgetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetStatusFilter<$PrismaModel>
    _max?: NestedEnumBudgetStatusFilter<$PrismaModel>
  }

  export type BudgetRelationFilter = {
    is?: BudgetWhereInput
    isNot?: BudgetWhereInput
  }

  export type StoreRelationFilter = {
    is?: StoreWhereInput
    isNot?: StoreWhereInput
  }

  export type AllocationRecommendationListRelationFilter = {
    every?: AllocationRecommendationWhereInput
    some?: AllocationRecommendationWhereInput
    none?: AllocationRecommendationWhereInput
  }

  export type AllocationRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BudgetDetailBudgetIdStoreIdCompoundUniqueInput = {
    budgetId: string
    storeId: string
  }

  export type BudgetDetailCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    storeId?: SortOrder
    budgetAmount?: SortOrder
  }

  export type BudgetDetailAvgOrderByAggregateInput = {
    budgetAmount?: SortOrder
  }

  export type BudgetDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    storeId?: SortOrder
    budgetAmount?: SortOrder
  }

  export type BudgetDetailMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    storeId?: SortOrder
    budgetAmount?: SortOrder
  }

  export type BudgetDetailSumOrderByAggregateInput = {
    budgetAmount?: SortOrder
  }

  export type EnumPlanningStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanningStatus | EnumPlanningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanningStatusFilter<$PrismaModel> | $Enums.PlanningStatus
  }

  export type BudgetDetailRelationFilter = {
    is?: BudgetDetailWhereInput
    isNot?: BudgetDetailWhereInput
  }

  export type PlanningVersionBudgetDetailIdVersionNumberCompoundUniqueInput = {
    budgetDetailId: string
    versionNumber: number
  }

  export type PlanningVersionCountOrderByAggregateInput = {
    id?: SortOrder
    planningCode?: SortOrder
    budgetDetailId?: SortOrder
    versionNumber?: SortOrder
    versionName?: SortOrder
    status?: SortOrder
    isFinal?: SortOrder
    snapshotData?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type PlanningVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    planningCode?: SortOrder
    budgetDetailId?: SortOrder
    versionNumber?: SortOrder
    versionName?: SortOrder
    status?: SortOrder
    isFinal?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningVersionMinOrderByAggregateInput = {
    id?: SortOrder
    planningCode?: SortOrder
    budgetDetailId?: SortOrder
    versionNumber?: SortOrder
    versionName?: SortOrder
    status?: SortOrder
    isFinal?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanningVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumPlanningStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanningStatus | EnumPlanningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanningStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlanningStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanningStatusFilter<$PrismaModel>
    _max?: NestedEnumPlanningStatusFilter<$PrismaModel>
  }

  export type PlanningVersionRelationFilter = {
    is?: PlanningVersionWhereInput
    isNot?: PlanningVersionWhereInput
  }

  export type CollectionNullableRelationFilter = {
    is?: CollectionWhereInput | null
    isNot?: CollectionWhereInput | null
  }

  export type GenderNullableRelationFilter = {
    is?: GenderWhereInput | null
    isNot?: GenderWhereInput | null
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type SubCategoryNullableRelationFilter = {
    is?: SubCategoryWhereInput | null
    isNot?: SubCategoryWhereInput | null
  }

  export type PlanningDetailCountOrderByAggregateInput = {
    id?: SortOrder
    planningVersionId?: SortOrder
    dimensionType?: SortOrder
    collectionId?: SortOrder
    genderId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
    userComment?: SortOrder
  }

  export type PlanningDetailAvgOrderByAggregateInput = {
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
  }

  export type PlanningDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    planningVersionId?: SortOrder
    dimensionType?: SortOrder
    collectionId?: SortOrder
    genderId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
    userComment?: SortOrder
  }

  export type PlanningDetailMinOrderByAggregateInput = {
    id?: SortOrder
    planningVersionId?: SortOrder
    dimensionType?: SortOrder
    collectionId?: SortOrder
    genderId?: SortOrder
    categoryId?: SortOrder
    subCategoryId?: SortOrder
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
    userComment?: SortOrder
  }

  export type PlanningDetailSumOrderByAggregateInput = {
    lastSeasonSales?: SortOrder
    lastSeasonPct?: SortOrder
    systemBuyPct?: SortOrder
    userBuyPct?: SortOrder
    otbValue?: SortOrder
    variancePct?: SortOrder
  }

  export type EnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type PlanningVersionNullableRelationFilter = {
    is?: PlanningVersionWhereInput | null
    isNot?: PlanningVersionWhereInput | null
  }

  export type ProposalCountOrderByAggregateInput = {
    id?: SortOrder
    ticketName?: SortOrder
    budgetId?: SortOrder
    planningVersionId?: SortOrder
    status?: SortOrder
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalAvgOrderByAggregateInput = {
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
  }

  export type ProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketName?: SortOrder
    budgetId?: SortOrder
    planningVersionId?: SortOrder
    status?: SortOrder
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalMinOrderByAggregateInput = {
    id?: SortOrder
    ticketName?: SortOrder
    budgetId?: SortOrder
    planningVersionId?: SortOrder
    status?: SortOrder
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProposalSumOrderByAggregateInput = {
    totalSkuCount?: SortOrder
    totalOrderQty?: SortOrder
    totalValue?: SortOrder
  }

  export type EnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type ProposalRelationFilter = {
    is?: ProposalWhereInput
    isNot?: ProposalWhereInput
  }

  export type SkuCatalogRelationFilter = {
    is?: SkuCatalogWhereInput
    isNot?: SkuCatalogWhereInput
  }

  export type ProposalProductCountOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    collection?: SortOrder
    gender?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    theme?: SortOrder
    color?: SortOrder
    composition?: SortOrder
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    customerTarget?: SortOrder
    imageUrl?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProposalProductAvgOrderByAggregateInput = {
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProposalProductMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    collection?: SortOrder
    gender?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    theme?: SortOrder
    color?: SortOrder
    composition?: SortOrder
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    customerTarget?: SortOrder
    imageUrl?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProposalProductMinOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    collection?: SortOrder
    gender?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    theme?: SortOrder
    color?: SortOrder
    composition?: SortOrder
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    customerTarget?: SortOrder
    imageUrl?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProposalProductSumOrderByAggregateInput = {
    unitCost?: SortOrder
    srp?: SortOrder
    orderQty?: SortOrder
    totalValue?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProposalProductRelationFilter = {
    is?: ProposalProductWhereInput
    isNot?: ProposalProductWhereInput
  }

  export type ProductAllocationProposalProductIdStoreIdCompoundUniqueInput = {
    proposalProductId: string
    storeId: string
  }

  export type ProductAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    proposalProductId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductAllocationAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ProductAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalProductId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    proposalProductId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductAllocationSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumApprovalActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalAction | EnumApprovalActionFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalActionFilter<$PrismaModel> | $Enums.ApprovalAction
  }

  export type ApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    level?: SortOrder
    deciderId?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    decidedAt?: SortOrder
  }

  export type ApprovalAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    level?: SortOrder
    deciderId?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    decidedAt?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    level?: SortOrder
    deciderId?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    decidedAt?: SortOrder
  }

  export type ApprovalSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type EnumApprovalActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalAction | EnumApprovalActionFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalActionWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalActionFilter<$PrismaModel>
    _max?: NestedEnumApprovalActionFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    skuCode?: SortOrder
    storeId?: SortOrder
    sizeCode?: SortOrder
    season?: SortOrder
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesHistoryAvgOrderByAggregateInput = {
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
  }

  export type SalesHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    skuCode?: SortOrder
    storeId?: SortOrder
    sizeCode?: SortOrder
    season?: SortOrder
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    skuCode?: SortOrder
    storeId?: SortOrder
    sizeCode?: SortOrder
    season?: SortOrder
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
  }

  export type SalesHistorySumOrderByAggregateInput = {
    quantitySold?: SortOrder
    quantityBought?: SortOrder
    sellThroughPct?: SortOrder
  }

  export type SizeCurveRecommendationSkuIdStoreIdSizeCodeCompoundUniqueInput = {
    skuId: string
    storeId: string
    sizeCode: string
  }

  export type SizeCurveRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    storeId?: SortOrder
    category?: SortOrder
    sizeCode?: SortOrder
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
    reasoning?: SortOrder
    createdAt?: SortOrder
  }

  export type SizeCurveRecommendationAvgOrderByAggregateInput = {
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
  }

  export type SizeCurveRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    storeId?: SortOrder
    category?: SortOrder
    sizeCode?: SortOrder
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
    reasoning?: SortOrder
    createdAt?: SortOrder
  }

  export type SizeCurveRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    storeId?: SortOrder
    category?: SortOrder
    sizeCode?: SortOrder
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
    reasoning?: SortOrder
    createdAt?: SortOrder
  }

  export type SizeCurveRecommendationSumOrderByAggregateInput = {
    recommendedPct?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
  }

  export type BudgetAlertCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    metricValue?: SortOrder
    threshold?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    isDismissed?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetAlertAvgOrderByAggregateInput = {
    metricValue?: SortOrder
    threshold?: SortOrder
  }

  export type BudgetAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    metricValue?: SortOrder
    threshold?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    isDismissed?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetAlertMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    alertType?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    message?: SortOrder
    metricValue?: SortOrder
    threshold?: SortOrder
    category?: SortOrder
    isRead?: SortOrder
    isDismissed?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetAlertSumOrderByAggregateInput = {
    metricValue?: SortOrder
    threshold?: SortOrder
  }

  export type BudgetSnapshotBudgetIdSnapshotDateCompoundUniqueInput = {
    budgetId: string
    snapshotDate: Date | string
  }

  export type BudgetSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    snapshotDate?: SortOrder
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
  }

  export type BudgetSnapshotAvgOrderByAggregateInput = {
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
  }

  export type BudgetSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    snapshotDate?: SortOrder
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
  }

  export type BudgetSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    snapshotDate?: SortOrder
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
  }

  export type BudgetSnapshotSumOrderByAggregateInput = {
    totalCommitted?: SortOrder
    totalPlanned?: SortOrder
    utilizationPct?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AllocationHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    seasonGroup?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
  }

  export type AllocationHistoryAvgOrderByAggregateInput = {
    fiscalYear?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrder
    sellThroughPct?: SortOrder
  }

  export type AllocationHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    seasonGroup?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
  }

  export type AllocationHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    budgetId?: SortOrder
    seasonGroup?: SortOrder
    seasonType?: SortOrder
    fiscalYear?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrder
    sellThroughPct?: SortOrder
    createdAt?: SortOrder
  }

  export type AllocationHistorySumOrderByAggregateInput = {
    fiscalYear?: SortOrder
    allocatedPct?: SortOrder
    allocatedAmount?: SortOrder
    actualSales?: SortOrder
    sellThroughPct?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type AllocationRecommendationBudgetDetailIdDimensionTypeDimensionValueCompoundUniqueInput = {
    budgetDetailId: string
    dimensionType: string
    dimensionValue: string
  }

  export type AllocationRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    basedOnSeasons?: SortOrder
    factors?: SortOrder
    isApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type AllocationRecommendationAvgOrderByAggregateInput = {
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
  }

  export type AllocationRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    basedOnSeasons?: SortOrder
    isApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type AllocationRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    dimensionType?: SortOrder
    dimensionValue?: SortOrder
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    basedOnSeasons?: SortOrder
    isApplied?: SortOrder
    createdAt?: SortOrder
  }

  export type AllocationRecommendationSumOrderByAggregateInput = {
    recommendedPct?: SortOrder
    recommendedAmt?: SortOrder
    confidence?: SortOrder
    basedOnSeasons?: SortOrder
  }

  export type RiskAssessmentEntityTypeEntityIdCompoundUniqueInput = {
    entityType: string
    entityId: string
  }

  export type RiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
    factors?: SortOrder
    warnings?: SortOrder
    recommendation?: SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrder
    isStale?: SortOrder
  }

  export type RiskAssessmentAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
  }

  export type RiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
    recommendation?: SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrder
    isStale?: SortOrder
  }

  export type RiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
    recommendation?: SortOrder
    calculatedAt?: SortOrder
    calculatedBy?: SortOrder
    isStale?: SortOrder
  }

  export type RiskAssessmentSumOrderByAggregateInput = {
    overallScore?: SortOrder
    budgetAlignmentScore?: SortOrder
    skuDiversityScore?: SortOrder
    sizeCurveScore?: SortOrder
    vendorConcentrationScore?: SortOrder
    categoryBalanceScore?: SortOrder
    marginImpactScore?: SortOrder
  }

  export type RiskThresholdCountOrderByAggregateInput = {
    id?: SortOrder
    factorName?: SortOrder
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type RiskThresholdAvgOrderByAggregateInput = {
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
  }

  export type RiskThresholdMaxOrderByAggregateInput = {
    id?: SortOrder
    factorName?: SortOrder
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type RiskThresholdMinOrderByAggregateInput = {
    id?: SortOrder
    factorName?: SortOrder
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type RiskThresholdSumOrderByAggregateInput = {
    weight?: SortOrder
    lowThreshold?: SortOrder
    highThreshold?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StoreNullableRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type SkuPerformanceSkuIdSeasonGroupFiscalYearStoreIdCompoundUniqueInput = {
    skuId: string
    seasonGroup: string
    fiscalYear: number
    storeId: string
  }

  export type SkuPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    storeId?: SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SkuPerformanceAvgOrderByAggregateInput = {
    fiscalYear?: SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
  }

  export type SkuPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    storeId?: SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SkuPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    storeId?: SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
    createdAt?: SortOrder
  }

  export type SkuPerformanceSumOrderByAggregateInput = {
    fiscalYear?: SortOrder
    quantityBought?: SortOrder
    quantitySold?: SortOrder
    sellThroughPct?: SortOrder
    avgSellingPrice?: SortOrder
    totalRevenue?: SortOrder
    grossMarginPct?: SortOrder
    markdownPct?: SortOrder
    weeksToSellThru?: SortOrder
    performanceScore?: SortOrder
    velocityScore?: SortOrder
    marginScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AttributeTrendAttributeTypeAttributeValueCategorySeasonGroupFiscalYearCompoundUniqueInput = {
    attributeType: string
    attributeValue: string
    category: string
    seasonGroup: string
    fiscalYear: number
  }

  export type AttributeTrendCountOrderByAggregateInput = {
    id?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    category?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrder
    createdAt?: SortOrder
  }

  export type AttributeTrendAvgOrderByAggregateInput = {
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrder
  }

  export type AttributeTrendMaxOrderByAggregateInput = {
    id?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    category?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrder
    createdAt?: SortOrder
  }

  export type AttributeTrendMinOrderByAggregateInput = {
    id?: SortOrder
    attributeType?: SortOrder
    attributeValue?: SortOrder
    category?: SortOrder
    seasonGroup?: SortOrder
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrder
    createdAt?: SortOrder
  }

  export type AttributeTrendSumOrderByAggregateInput = {
    fiscalYear?: SortOrder
    totalSkus?: SortOrder
    avgSellThrough?: SortOrder
    avgMargin?: SortOrder
    trendScore?: SortOrder
    yoyGrowth?: SortOrder
  }

  export type SkuRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    reasoning?: SortOrder
    isSelected?: SortOrder
    isRejected?: SortOrder
    createdAt?: SortOrder
  }

  export type SkuRecommendationAvgOrderByAggregateInput = {
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
  }

  export type SkuRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    reasoning?: SortOrder
    isSelected?: SortOrder
    isRejected?: SortOrder
    createdAt?: SortOrder
  }

  export type SkuRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    budgetDetailId?: SortOrder
    category?: SortOrder
    subCategory?: SortOrder
    skuId?: SortOrder
    skuCode?: SortOrder
    productName?: SortOrder
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
    riskLevel?: SortOrder
    reasoning?: SortOrder
    isSelected?: SortOrder
    isRejected?: SortOrder
    createdAt?: SortOrder
  }

  export type SkuRecommendationSumOrderByAggregateInput = {
    recommendedQty?: SortOrder
    recommendedValue?: SortOrder
    confidence?: SortOrder
    performanceScore?: SortOrder
    trendScore?: SortOrder
    assortmentScore?: SortOrder
    priceScore?: SortOrder
    overallScore?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ApprovalWorkflowStepBrandIdStepNumberCompoundUniqueInput = {
    brandId: string
    stepNumber: number
  }

  export type ApprovalWorkflowStepCountOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    stepNumber?: SortOrder
    roleName?: SortOrder
    roleCode?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowStepAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type ApprovalWorkflowStepMaxOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    stepNumber?: SortOrder
    roleName?: SortOrder
    roleCode?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowStepMinOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    stepNumber?: SortOrder
    roleName?: SortOrder
    roleCode?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowStepSumOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type UserCreatestoreAccessInput = {
    set: string[]
  }

  export type UserCreatebrandAccessInput = {
    set: string[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type BudgetCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BudgetCreateWithoutCreatedByInput, BudgetUncheckedCreateWithoutCreatedByInput> | BudgetCreateWithoutCreatedByInput[] | BudgetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCreatedByInput | BudgetCreateOrConnectWithoutCreatedByInput[]
    createMany?: BudgetCreateManyCreatedByInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type PlanningVersionCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PlanningVersionCreateWithoutCreatedByInput, PlanningVersionUncheckedCreateWithoutCreatedByInput> | PlanningVersionCreateWithoutCreatedByInput[] | PlanningVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutCreatedByInput | PlanningVersionCreateOrConnectWithoutCreatedByInput[]
    createMany?: PlanningVersionCreateManyCreatedByInputEnvelope
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutDeciderInput = {
    create?: XOR<ApprovalCreateWithoutDeciderInput, ApprovalUncheckedCreateWithoutDeciderInput> | ApprovalCreateWithoutDeciderInput[] | ApprovalUncheckedCreateWithoutDeciderInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutDeciderInput | ApprovalCreateOrConnectWithoutDeciderInput[]
    createMany?: ApprovalCreateManyDeciderInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ApprovalWorkflowStepCreateNestedManyWithoutUserInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutUserInput, ApprovalWorkflowStepUncheckedCreateWithoutUserInput> | ApprovalWorkflowStepCreateWithoutUserInput[] | ApprovalWorkflowStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutUserInput | ApprovalWorkflowStepCreateOrConnectWithoutUserInput[]
    createMany?: ApprovalWorkflowStepCreateManyUserInputEnvelope
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BudgetCreateWithoutCreatedByInput, BudgetUncheckedCreateWithoutCreatedByInput> | BudgetCreateWithoutCreatedByInput[] | BudgetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCreatedByInput | BudgetCreateOrConnectWithoutCreatedByInput[]
    createMany?: BudgetCreateManyCreatedByInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PlanningVersionCreateWithoutCreatedByInput, PlanningVersionUncheckedCreateWithoutCreatedByInput> | PlanningVersionCreateWithoutCreatedByInput[] | PlanningVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutCreatedByInput | PlanningVersionCreateOrConnectWithoutCreatedByInput[]
    createMany?: PlanningVersionCreateManyCreatedByInputEnvelope
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutDeciderInput = {
    create?: XOR<ApprovalCreateWithoutDeciderInput, ApprovalUncheckedCreateWithoutDeciderInput> | ApprovalCreateWithoutDeciderInput[] | ApprovalUncheckedCreateWithoutDeciderInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutDeciderInput | ApprovalCreateOrConnectWithoutDeciderInput[]
    createMany?: ApprovalCreateManyDeciderInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutUserInput, ApprovalWorkflowStepUncheckedCreateWithoutUserInput> | ApprovalWorkflowStepCreateWithoutUserInput[] | ApprovalWorkflowStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutUserInput | ApprovalWorkflowStepCreateOrConnectWithoutUserInput[]
    createMany?: ApprovalWorkflowStepCreateManyUserInputEnvelope
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdatestoreAccessInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdatebrandAccessInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type BudgetUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BudgetCreateWithoutCreatedByInput, BudgetUncheckedCreateWithoutCreatedByInput> | BudgetCreateWithoutCreatedByInput[] | BudgetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCreatedByInput | BudgetCreateOrConnectWithoutCreatedByInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutCreatedByInput | BudgetUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BudgetCreateManyCreatedByInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutCreatedByInput | BudgetUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutCreatedByInput | BudgetUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type PlanningVersionUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PlanningVersionCreateWithoutCreatedByInput, PlanningVersionUncheckedCreateWithoutCreatedByInput> | PlanningVersionCreateWithoutCreatedByInput[] | PlanningVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutCreatedByInput | PlanningVersionCreateOrConnectWithoutCreatedByInput[]
    upsert?: PlanningVersionUpsertWithWhereUniqueWithoutCreatedByInput | PlanningVersionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PlanningVersionCreateManyCreatedByInputEnvelope
    set?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    disconnect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    delete?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    update?: PlanningVersionUpdateWithWhereUniqueWithoutCreatedByInput | PlanningVersionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PlanningVersionUpdateManyWithWhereWithoutCreatedByInput | PlanningVersionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PlanningVersionScalarWhereInput | PlanningVersionScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCreatedByInput | ProposalUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCreatedByInput | ProposalUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCreatedByInput | ProposalUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutDeciderNestedInput = {
    create?: XOR<ApprovalCreateWithoutDeciderInput, ApprovalUncheckedCreateWithoutDeciderInput> | ApprovalCreateWithoutDeciderInput[] | ApprovalUncheckedCreateWithoutDeciderInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutDeciderInput | ApprovalCreateOrConnectWithoutDeciderInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutDeciderInput | ApprovalUpsertWithWhereUniqueWithoutDeciderInput[]
    createMany?: ApprovalCreateManyDeciderInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutDeciderInput | ApprovalUpdateWithWhereUniqueWithoutDeciderInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutDeciderInput | ApprovalUpdateManyWithWhereWithoutDeciderInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ApprovalWorkflowStepUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutUserInput, ApprovalWorkflowStepUncheckedCreateWithoutUserInput> | ApprovalWorkflowStepCreateWithoutUserInput[] | ApprovalWorkflowStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutUserInput | ApprovalWorkflowStepCreateOrConnectWithoutUserInput[]
    upsert?: ApprovalWorkflowStepUpsertWithWhereUniqueWithoutUserInput | ApprovalWorkflowStepUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApprovalWorkflowStepCreateManyUserInputEnvelope
    set?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    disconnect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    delete?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    update?: ApprovalWorkflowStepUpdateWithWhereUniqueWithoutUserInput | ApprovalWorkflowStepUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApprovalWorkflowStepUpdateManyWithWhereWithoutUserInput | ApprovalWorkflowStepUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApprovalWorkflowStepScalarWhereInput | ApprovalWorkflowStepScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BudgetCreateWithoutCreatedByInput, BudgetUncheckedCreateWithoutCreatedByInput> | BudgetCreateWithoutCreatedByInput[] | BudgetUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutCreatedByInput | BudgetCreateOrConnectWithoutCreatedByInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutCreatedByInput | BudgetUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BudgetCreateManyCreatedByInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutCreatedByInput | BudgetUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutCreatedByInput | BudgetUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PlanningVersionCreateWithoutCreatedByInput, PlanningVersionUncheckedCreateWithoutCreatedByInput> | PlanningVersionCreateWithoutCreatedByInput[] | PlanningVersionUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutCreatedByInput | PlanningVersionCreateOrConnectWithoutCreatedByInput[]
    upsert?: PlanningVersionUpsertWithWhereUniqueWithoutCreatedByInput | PlanningVersionUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PlanningVersionCreateManyCreatedByInputEnvelope
    set?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    disconnect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    delete?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    update?: PlanningVersionUpdateWithWhereUniqueWithoutCreatedByInput | PlanningVersionUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PlanningVersionUpdateManyWithWhereWithoutCreatedByInput | PlanningVersionUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PlanningVersionScalarWhereInput | PlanningVersionScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCreatedByInput | ProposalUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCreatedByInput | ProposalUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCreatedByInput | ProposalUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutDeciderNestedInput = {
    create?: XOR<ApprovalCreateWithoutDeciderInput, ApprovalUncheckedCreateWithoutDeciderInput> | ApprovalCreateWithoutDeciderInput[] | ApprovalUncheckedCreateWithoutDeciderInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutDeciderInput | ApprovalCreateOrConnectWithoutDeciderInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutDeciderInput | ApprovalUpsertWithWhereUniqueWithoutDeciderInput[]
    createMany?: ApprovalCreateManyDeciderInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutDeciderInput | ApprovalUpdateWithWhereUniqueWithoutDeciderInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutDeciderInput | ApprovalUpdateManyWithWhereWithoutDeciderInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutUserInput, ApprovalWorkflowStepUncheckedCreateWithoutUserInput> | ApprovalWorkflowStepCreateWithoutUserInput[] | ApprovalWorkflowStepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutUserInput | ApprovalWorkflowStepCreateOrConnectWithoutUserInput[]
    upsert?: ApprovalWorkflowStepUpsertWithWhereUniqueWithoutUserInput | ApprovalWorkflowStepUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApprovalWorkflowStepCreateManyUserInputEnvelope
    set?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    disconnect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    delete?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    update?: ApprovalWorkflowStepUpdateWithWhereUniqueWithoutUserInput | ApprovalWorkflowStepUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApprovalWorkflowStepUpdateManyWithWhereWithoutUserInput | ApprovalWorkflowStepUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApprovalWorkflowStepScalarWhereInput | ApprovalWorkflowStepScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BudgetCreateNestedManyWithoutGroupBrandInput = {
    create?: XOR<BudgetCreateWithoutGroupBrandInput, BudgetUncheckedCreateWithoutGroupBrandInput> | BudgetCreateWithoutGroupBrandInput[] | BudgetUncheckedCreateWithoutGroupBrandInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutGroupBrandInput | BudgetCreateOrConnectWithoutGroupBrandInput[]
    createMany?: BudgetCreateManyGroupBrandInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type SkuCatalogCreateNestedManyWithoutBrandInput = {
    create?: XOR<SkuCatalogCreateWithoutBrandInput, SkuCatalogUncheckedCreateWithoutBrandInput> | SkuCatalogCreateWithoutBrandInput[] | SkuCatalogUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutBrandInput | SkuCatalogCreateOrConnectWithoutBrandInput[]
    createMany?: SkuCatalogCreateManyBrandInputEnvelope
    connect?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
  }

  export type ApprovalWorkflowStepCreateNestedManyWithoutBrandInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutBrandInput, ApprovalWorkflowStepUncheckedCreateWithoutBrandInput> | ApprovalWorkflowStepCreateWithoutBrandInput[] | ApprovalWorkflowStepUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutBrandInput | ApprovalWorkflowStepCreateOrConnectWithoutBrandInput[]
    createMany?: ApprovalWorkflowStepCreateManyBrandInputEnvelope
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutGroupBrandInput = {
    create?: XOR<BudgetCreateWithoutGroupBrandInput, BudgetUncheckedCreateWithoutGroupBrandInput> | BudgetCreateWithoutGroupBrandInput[] | BudgetUncheckedCreateWithoutGroupBrandInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutGroupBrandInput | BudgetCreateOrConnectWithoutGroupBrandInput[]
    createMany?: BudgetCreateManyGroupBrandInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type SkuCatalogUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<SkuCatalogCreateWithoutBrandInput, SkuCatalogUncheckedCreateWithoutBrandInput> | SkuCatalogCreateWithoutBrandInput[] | SkuCatalogUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutBrandInput | SkuCatalogCreateOrConnectWithoutBrandInput[]
    createMany?: SkuCatalogCreateManyBrandInputEnvelope
    connect?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
  }

  export type ApprovalWorkflowStepUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutBrandInput, ApprovalWorkflowStepUncheckedCreateWithoutBrandInput> | ApprovalWorkflowStepCreateWithoutBrandInput[] | ApprovalWorkflowStepUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutBrandInput | ApprovalWorkflowStepCreateOrConnectWithoutBrandInput[]
    createMany?: ApprovalWorkflowStepCreateManyBrandInputEnvelope
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BudgetUpdateManyWithoutGroupBrandNestedInput = {
    create?: XOR<BudgetCreateWithoutGroupBrandInput, BudgetUncheckedCreateWithoutGroupBrandInput> | BudgetCreateWithoutGroupBrandInput[] | BudgetUncheckedCreateWithoutGroupBrandInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutGroupBrandInput | BudgetCreateOrConnectWithoutGroupBrandInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutGroupBrandInput | BudgetUpsertWithWhereUniqueWithoutGroupBrandInput[]
    createMany?: BudgetCreateManyGroupBrandInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutGroupBrandInput | BudgetUpdateWithWhereUniqueWithoutGroupBrandInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutGroupBrandInput | BudgetUpdateManyWithWhereWithoutGroupBrandInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type SkuCatalogUpdateManyWithoutBrandNestedInput = {
    create?: XOR<SkuCatalogCreateWithoutBrandInput, SkuCatalogUncheckedCreateWithoutBrandInput> | SkuCatalogCreateWithoutBrandInput[] | SkuCatalogUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutBrandInput | SkuCatalogCreateOrConnectWithoutBrandInput[]
    upsert?: SkuCatalogUpsertWithWhereUniqueWithoutBrandInput | SkuCatalogUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: SkuCatalogCreateManyBrandInputEnvelope
    set?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    disconnect?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    delete?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    connect?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    update?: SkuCatalogUpdateWithWhereUniqueWithoutBrandInput | SkuCatalogUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: SkuCatalogUpdateManyWithWhereWithoutBrandInput | SkuCatalogUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: SkuCatalogScalarWhereInput | SkuCatalogScalarWhereInput[]
  }

  export type ApprovalWorkflowStepUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutBrandInput, ApprovalWorkflowStepUncheckedCreateWithoutBrandInput> | ApprovalWorkflowStepCreateWithoutBrandInput[] | ApprovalWorkflowStepUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutBrandInput | ApprovalWorkflowStepCreateOrConnectWithoutBrandInput[]
    upsert?: ApprovalWorkflowStepUpsertWithWhereUniqueWithoutBrandInput | ApprovalWorkflowStepUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ApprovalWorkflowStepCreateManyBrandInputEnvelope
    set?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    disconnect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    delete?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    update?: ApprovalWorkflowStepUpdateWithWhereUniqueWithoutBrandInput | ApprovalWorkflowStepUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ApprovalWorkflowStepUpdateManyWithWhereWithoutBrandInput | ApprovalWorkflowStepUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ApprovalWorkflowStepScalarWhereInput | ApprovalWorkflowStepScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutGroupBrandNestedInput = {
    create?: XOR<BudgetCreateWithoutGroupBrandInput, BudgetUncheckedCreateWithoutGroupBrandInput> | BudgetCreateWithoutGroupBrandInput[] | BudgetUncheckedCreateWithoutGroupBrandInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutGroupBrandInput | BudgetCreateOrConnectWithoutGroupBrandInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutGroupBrandInput | BudgetUpsertWithWhereUniqueWithoutGroupBrandInput[]
    createMany?: BudgetCreateManyGroupBrandInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutGroupBrandInput | BudgetUpdateWithWhereUniqueWithoutGroupBrandInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutGroupBrandInput | BudgetUpdateManyWithWhereWithoutGroupBrandInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type SkuCatalogUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<SkuCatalogCreateWithoutBrandInput, SkuCatalogUncheckedCreateWithoutBrandInput> | SkuCatalogCreateWithoutBrandInput[] | SkuCatalogUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutBrandInput | SkuCatalogCreateOrConnectWithoutBrandInput[]
    upsert?: SkuCatalogUpsertWithWhereUniqueWithoutBrandInput | SkuCatalogUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: SkuCatalogCreateManyBrandInputEnvelope
    set?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    disconnect?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    delete?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    connect?: SkuCatalogWhereUniqueInput | SkuCatalogWhereUniqueInput[]
    update?: SkuCatalogUpdateWithWhereUniqueWithoutBrandInput | SkuCatalogUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: SkuCatalogUpdateManyWithWhereWithoutBrandInput | SkuCatalogUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: SkuCatalogScalarWhereInput | SkuCatalogScalarWhereInput[]
  }

  export type ApprovalWorkflowStepUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ApprovalWorkflowStepCreateWithoutBrandInput, ApprovalWorkflowStepUncheckedCreateWithoutBrandInput> | ApprovalWorkflowStepCreateWithoutBrandInput[] | ApprovalWorkflowStepUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ApprovalWorkflowStepCreateOrConnectWithoutBrandInput | ApprovalWorkflowStepCreateOrConnectWithoutBrandInput[]
    upsert?: ApprovalWorkflowStepUpsertWithWhereUniqueWithoutBrandInput | ApprovalWorkflowStepUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ApprovalWorkflowStepCreateManyBrandInputEnvelope
    set?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    disconnect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    delete?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    connect?: ApprovalWorkflowStepWhereUniqueInput | ApprovalWorkflowStepWhereUniqueInput[]
    update?: ApprovalWorkflowStepUpdateWithWhereUniqueWithoutBrandInput | ApprovalWorkflowStepUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ApprovalWorkflowStepUpdateManyWithWhereWithoutBrandInput | ApprovalWorkflowStepUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ApprovalWorkflowStepScalarWhereInput | ApprovalWorkflowStepScalarWhereInput[]
  }

  export type BudgetDetailCreateNestedManyWithoutStoreInput = {
    create?: XOR<BudgetDetailCreateWithoutStoreInput, BudgetDetailUncheckedCreateWithoutStoreInput> | BudgetDetailCreateWithoutStoreInput[] | BudgetDetailUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutStoreInput | BudgetDetailCreateOrConnectWithoutStoreInput[]
    createMany?: BudgetDetailCreateManyStoreInputEnvelope
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
  }

  export type ProductAllocationCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductAllocationCreateWithoutStoreInput, ProductAllocationUncheckedCreateWithoutStoreInput> | ProductAllocationCreateWithoutStoreInput[] | ProductAllocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutStoreInput | ProductAllocationCreateOrConnectWithoutStoreInput[]
    createMany?: ProductAllocationCreateManyStoreInputEnvelope
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
  }

  export type SalesHistoryCreateNestedManyWithoutStoreInput = {
    create?: XOR<SalesHistoryCreateWithoutStoreInput, SalesHistoryUncheckedCreateWithoutStoreInput> | SalesHistoryCreateWithoutStoreInput[] | SalesHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SalesHistoryCreateOrConnectWithoutStoreInput | SalesHistoryCreateOrConnectWithoutStoreInput[]
    createMany?: SalesHistoryCreateManyStoreInputEnvelope
    connect?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
  }

  export type SizeCurveRecommendationCreateNestedManyWithoutStoreInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutStoreInput, SizeCurveRecommendationUncheckedCreateWithoutStoreInput> | SizeCurveRecommendationCreateWithoutStoreInput[] | SizeCurveRecommendationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutStoreInput | SizeCurveRecommendationCreateOrConnectWithoutStoreInput[]
    createMany?: SizeCurveRecommendationCreateManyStoreInputEnvelope
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
  }

  export type SkuPerformanceCreateNestedManyWithoutStoreInput = {
    create?: XOR<SkuPerformanceCreateWithoutStoreInput, SkuPerformanceUncheckedCreateWithoutStoreInput> | SkuPerformanceCreateWithoutStoreInput[] | SkuPerformanceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutStoreInput | SkuPerformanceCreateOrConnectWithoutStoreInput[]
    createMany?: SkuPerformanceCreateManyStoreInputEnvelope
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
  }

  export type BudgetDetailUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<BudgetDetailCreateWithoutStoreInput, BudgetDetailUncheckedCreateWithoutStoreInput> | BudgetDetailCreateWithoutStoreInput[] | BudgetDetailUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutStoreInput | BudgetDetailCreateOrConnectWithoutStoreInput[]
    createMany?: BudgetDetailCreateManyStoreInputEnvelope
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
  }

  export type ProductAllocationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<ProductAllocationCreateWithoutStoreInput, ProductAllocationUncheckedCreateWithoutStoreInput> | ProductAllocationCreateWithoutStoreInput[] | ProductAllocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutStoreInput | ProductAllocationCreateOrConnectWithoutStoreInput[]
    createMany?: ProductAllocationCreateManyStoreInputEnvelope
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
  }

  export type SalesHistoryUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SalesHistoryCreateWithoutStoreInput, SalesHistoryUncheckedCreateWithoutStoreInput> | SalesHistoryCreateWithoutStoreInput[] | SalesHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SalesHistoryCreateOrConnectWithoutStoreInput | SalesHistoryCreateOrConnectWithoutStoreInput[]
    createMany?: SalesHistoryCreateManyStoreInputEnvelope
    connect?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
  }

  export type SizeCurveRecommendationUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutStoreInput, SizeCurveRecommendationUncheckedCreateWithoutStoreInput> | SizeCurveRecommendationCreateWithoutStoreInput[] | SizeCurveRecommendationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutStoreInput | SizeCurveRecommendationCreateOrConnectWithoutStoreInput[]
    createMany?: SizeCurveRecommendationCreateManyStoreInputEnvelope
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
  }

  export type SkuPerformanceUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<SkuPerformanceCreateWithoutStoreInput, SkuPerformanceUncheckedCreateWithoutStoreInput> | SkuPerformanceCreateWithoutStoreInput[] | SkuPerformanceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutStoreInput | SkuPerformanceCreateOrConnectWithoutStoreInput[]
    createMany?: SkuPerformanceCreateManyStoreInputEnvelope
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
  }

  export type BudgetDetailUpdateManyWithoutStoreNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutStoreInput, BudgetDetailUncheckedCreateWithoutStoreInput> | BudgetDetailCreateWithoutStoreInput[] | BudgetDetailUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutStoreInput | BudgetDetailCreateOrConnectWithoutStoreInput[]
    upsert?: BudgetDetailUpsertWithWhereUniqueWithoutStoreInput | BudgetDetailUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: BudgetDetailCreateManyStoreInputEnvelope
    set?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    disconnect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    delete?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    update?: BudgetDetailUpdateWithWhereUniqueWithoutStoreInput | BudgetDetailUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: BudgetDetailUpdateManyWithWhereWithoutStoreInput | BudgetDetailUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: BudgetDetailScalarWhereInput | BudgetDetailScalarWhereInput[]
  }

  export type ProductAllocationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductAllocationCreateWithoutStoreInput, ProductAllocationUncheckedCreateWithoutStoreInput> | ProductAllocationCreateWithoutStoreInput[] | ProductAllocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutStoreInput | ProductAllocationCreateOrConnectWithoutStoreInput[]
    upsert?: ProductAllocationUpsertWithWhereUniqueWithoutStoreInput | ProductAllocationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductAllocationCreateManyStoreInputEnvelope
    set?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    disconnect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    delete?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    update?: ProductAllocationUpdateWithWhereUniqueWithoutStoreInput | ProductAllocationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductAllocationUpdateManyWithWhereWithoutStoreInput | ProductAllocationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductAllocationScalarWhereInput | ProductAllocationScalarWhereInput[]
  }

  export type SalesHistoryUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SalesHistoryCreateWithoutStoreInput, SalesHistoryUncheckedCreateWithoutStoreInput> | SalesHistoryCreateWithoutStoreInput[] | SalesHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SalesHistoryCreateOrConnectWithoutStoreInput | SalesHistoryCreateOrConnectWithoutStoreInput[]
    upsert?: SalesHistoryUpsertWithWhereUniqueWithoutStoreInput | SalesHistoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SalesHistoryCreateManyStoreInputEnvelope
    set?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    disconnect?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    delete?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    connect?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    update?: SalesHistoryUpdateWithWhereUniqueWithoutStoreInput | SalesHistoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SalesHistoryUpdateManyWithWhereWithoutStoreInput | SalesHistoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SalesHistoryScalarWhereInput | SalesHistoryScalarWhereInput[]
  }

  export type SizeCurveRecommendationUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutStoreInput, SizeCurveRecommendationUncheckedCreateWithoutStoreInput> | SizeCurveRecommendationCreateWithoutStoreInput[] | SizeCurveRecommendationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutStoreInput | SizeCurveRecommendationCreateOrConnectWithoutStoreInput[]
    upsert?: SizeCurveRecommendationUpsertWithWhereUniqueWithoutStoreInput | SizeCurveRecommendationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SizeCurveRecommendationCreateManyStoreInputEnvelope
    set?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    disconnect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    delete?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    update?: SizeCurveRecommendationUpdateWithWhereUniqueWithoutStoreInput | SizeCurveRecommendationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SizeCurveRecommendationUpdateManyWithWhereWithoutStoreInput | SizeCurveRecommendationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SizeCurveRecommendationScalarWhereInput | SizeCurveRecommendationScalarWhereInput[]
  }

  export type SkuPerformanceUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SkuPerformanceCreateWithoutStoreInput, SkuPerformanceUncheckedCreateWithoutStoreInput> | SkuPerformanceCreateWithoutStoreInput[] | SkuPerformanceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutStoreInput | SkuPerformanceCreateOrConnectWithoutStoreInput[]
    upsert?: SkuPerformanceUpsertWithWhereUniqueWithoutStoreInput | SkuPerformanceUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SkuPerformanceCreateManyStoreInputEnvelope
    set?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    disconnect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    delete?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    update?: SkuPerformanceUpdateWithWhereUniqueWithoutStoreInput | SkuPerformanceUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SkuPerformanceUpdateManyWithWhereWithoutStoreInput | SkuPerformanceUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SkuPerformanceScalarWhereInput | SkuPerformanceScalarWhereInput[]
  }

  export type BudgetDetailUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutStoreInput, BudgetDetailUncheckedCreateWithoutStoreInput> | BudgetDetailCreateWithoutStoreInput[] | BudgetDetailUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutStoreInput | BudgetDetailCreateOrConnectWithoutStoreInput[]
    upsert?: BudgetDetailUpsertWithWhereUniqueWithoutStoreInput | BudgetDetailUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: BudgetDetailCreateManyStoreInputEnvelope
    set?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    disconnect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    delete?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    update?: BudgetDetailUpdateWithWhereUniqueWithoutStoreInput | BudgetDetailUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: BudgetDetailUpdateManyWithWhereWithoutStoreInput | BudgetDetailUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: BudgetDetailScalarWhereInput | BudgetDetailScalarWhereInput[]
  }

  export type ProductAllocationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<ProductAllocationCreateWithoutStoreInput, ProductAllocationUncheckedCreateWithoutStoreInput> | ProductAllocationCreateWithoutStoreInput[] | ProductAllocationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutStoreInput | ProductAllocationCreateOrConnectWithoutStoreInput[]
    upsert?: ProductAllocationUpsertWithWhereUniqueWithoutStoreInput | ProductAllocationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: ProductAllocationCreateManyStoreInputEnvelope
    set?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    disconnect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    delete?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    update?: ProductAllocationUpdateWithWhereUniqueWithoutStoreInput | ProductAllocationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: ProductAllocationUpdateManyWithWhereWithoutStoreInput | ProductAllocationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: ProductAllocationScalarWhereInput | ProductAllocationScalarWhereInput[]
  }

  export type SalesHistoryUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SalesHistoryCreateWithoutStoreInput, SalesHistoryUncheckedCreateWithoutStoreInput> | SalesHistoryCreateWithoutStoreInput[] | SalesHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SalesHistoryCreateOrConnectWithoutStoreInput | SalesHistoryCreateOrConnectWithoutStoreInput[]
    upsert?: SalesHistoryUpsertWithWhereUniqueWithoutStoreInput | SalesHistoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SalesHistoryCreateManyStoreInputEnvelope
    set?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    disconnect?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    delete?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    connect?: SalesHistoryWhereUniqueInput | SalesHistoryWhereUniqueInput[]
    update?: SalesHistoryUpdateWithWhereUniqueWithoutStoreInput | SalesHistoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SalesHistoryUpdateManyWithWhereWithoutStoreInput | SalesHistoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SalesHistoryScalarWhereInput | SalesHistoryScalarWhereInput[]
  }

  export type SizeCurveRecommendationUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutStoreInput, SizeCurveRecommendationUncheckedCreateWithoutStoreInput> | SizeCurveRecommendationCreateWithoutStoreInput[] | SizeCurveRecommendationUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutStoreInput | SizeCurveRecommendationCreateOrConnectWithoutStoreInput[]
    upsert?: SizeCurveRecommendationUpsertWithWhereUniqueWithoutStoreInput | SizeCurveRecommendationUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SizeCurveRecommendationCreateManyStoreInputEnvelope
    set?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    disconnect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    delete?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    update?: SizeCurveRecommendationUpdateWithWhereUniqueWithoutStoreInput | SizeCurveRecommendationUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SizeCurveRecommendationUpdateManyWithWhereWithoutStoreInput | SizeCurveRecommendationUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SizeCurveRecommendationScalarWhereInput | SizeCurveRecommendationScalarWhereInput[]
  }

  export type SkuPerformanceUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<SkuPerformanceCreateWithoutStoreInput, SkuPerformanceUncheckedCreateWithoutStoreInput> | SkuPerformanceCreateWithoutStoreInput[] | SkuPerformanceUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutStoreInput | SkuPerformanceCreateOrConnectWithoutStoreInput[]
    upsert?: SkuPerformanceUpsertWithWhereUniqueWithoutStoreInput | SkuPerformanceUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: SkuPerformanceCreateManyStoreInputEnvelope
    set?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    disconnect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    delete?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    update?: SkuPerformanceUpdateWithWhereUniqueWithoutStoreInput | SkuPerformanceUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: SkuPerformanceUpdateManyWithWhereWithoutStoreInput | SkuPerformanceUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: SkuPerformanceScalarWhereInput | SkuPerformanceScalarWhereInput[]
  }

  export type PlanningDetailCreateNestedManyWithoutCollectionInput = {
    create?: XOR<PlanningDetailCreateWithoutCollectionInput, PlanningDetailUncheckedCreateWithoutCollectionInput> | PlanningDetailCreateWithoutCollectionInput[] | PlanningDetailUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCollectionInput | PlanningDetailCreateOrConnectWithoutCollectionInput[]
    createMany?: PlanningDetailCreateManyCollectionInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type PlanningDetailUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<PlanningDetailCreateWithoutCollectionInput, PlanningDetailUncheckedCreateWithoutCollectionInput> | PlanningDetailCreateWithoutCollectionInput[] | PlanningDetailUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCollectionInput | PlanningDetailCreateOrConnectWithoutCollectionInput[]
    createMany?: PlanningDetailCreateManyCollectionInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type PlanningDetailUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutCollectionInput, PlanningDetailUncheckedCreateWithoutCollectionInput> | PlanningDetailCreateWithoutCollectionInput[] | PlanningDetailUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCollectionInput | PlanningDetailCreateOrConnectWithoutCollectionInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutCollectionInput | PlanningDetailUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: PlanningDetailCreateManyCollectionInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutCollectionInput | PlanningDetailUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutCollectionInput | PlanningDetailUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type PlanningDetailUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutCollectionInput, PlanningDetailUncheckedCreateWithoutCollectionInput> | PlanningDetailCreateWithoutCollectionInput[] | PlanningDetailUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCollectionInput | PlanningDetailCreateOrConnectWithoutCollectionInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutCollectionInput | PlanningDetailUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: PlanningDetailCreateManyCollectionInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutCollectionInput | PlanningDetailUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutCollectionInput | PlanningDetailUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type CategoryCreateNestedManyWithoutGenderInput = {
    create?: XOR<CategoryCreateWithoutGenderInput, CategoryUncheckedCreateWithoutGenderInput> | CategoryCreateWithoutGenderInput[] | CategoryUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutGenderInput | CategoryCreateOrConnectWithoutGenderInput[]
    createMany?: CategoryCreateManyGenderInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PlanningDetailCreateNestedManyWithoutGenderInput = {
    create?: XOR<PlanningDetailCreateWithoutGenderInput, PlanningDetailUncheckedCreateWithoutGenderInput> | PlanningDetailCreateWithoutGenderInput[] | PlanningDetailUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutGenderInput | PlanningDetailCreateOrConnectWithoutGenderInput[]
    createMany?: PlanningDetailCreateManyGenderInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<CategoryCreateWithoutGenderInput, CategoryUncheckedCreateWithoutGenderInput> | CategoryCreateWithoutGenderInput[] | CategoryUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutGenderInput | CategoryCreateOrConnectWithoutGenderInput[]
    createMany?: CategoryCreateManyGenderInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type PlanningDetailUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<PlanningDetailCreateWithoutGenderInput, PlanningDetailUncheckedCreateWithoutGenderInput> | PlanningDetailCreateWithoutGenderInput[] | PlanningDetailUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutGenderInput | PlanningDetailCreateOrConnectWithoutGenderInput[]
    createMany?: PlanningDetailCreateManyGenderInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutGenderNestedInput = {
    create?: XOR<CategoryCreateWithoutGenderInput, CategoryUncheckedCreateWithoutGenderInput> | CategoryCreateWithoutGenderInput[] | CategoryUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutGenderInput | CategoryCreateOrConnectWithoutGenderInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutGenderInput | CategoryUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: CategoryCreateManyGenderInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutGenderInput | CategoryUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutGenderInput | CategoryUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PlanningDetailUpdateManyWithoutGenderNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutGenderInput, PlanningDetailUncheckedCreateWithoutGenderInput> | PlanningDetailCreateWithoutGenderInput[] | PlanningDetailUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutGenderInput | PlanningDetailCreateOrConnectWithoutGenderInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutGenderInput | PlanningDetailUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: PlanningDetailCreateManyGenderInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutGenderInput | PlanningDetailUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutGenderInput | PlanningDetailUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<CategoryCreateWithoutGenderInput, CategoryUncheckedCreateWithoutGenderInput> | CategoryCreateWithoutGenderInput[] | CategoryUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutGenderInput | CategoryCreateOrConnectWithoutGenderInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutGenderInput | CategoryUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: CategoryCreateManyGenderInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutGenderInput | CategoryUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutGenderInput | CategoryUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type PlanningDetailUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutGenderInput, PlanningDetailUncheckedCreateWithoutGenderInput> | PlanningDetailCreateWithoutGenderInput[] | PlanningDetailUncheckedCreateWithoutGenderInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutGenderInput | PlanningDetailCreateOrConnectWithoutGenderInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutGenderInput | PlanningDetailUpsertWithWhereUniqueWithoutGenderInput[]
    createMany?: PlanningDetailCreateManyGenderInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutGenderInput | PlanningDetailUpdateWithWhereUniqueWithoutGenderInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutGenderInput | PlanningDetailUpdateManyWithWhereWithoutGenderInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type GenderCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<GenderCreateWithoutCategoriesInput, GenderUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: GenderCreateOrConnectWithoutCategoriesInput
    connect?: GenderWhereUniqueInput
  }

  export type SubCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type PlanningDetailCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PlanningDetailCreateWithoutCategoryInput, PlanningDetailUncheckedCreateWithoutCategoryInput> | PlanningDetailCreateWithoutCategoryInput[] | PlanningDetailUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCategoryInput | PlanningDetailCreateOrConnectWithoutCategoryInput[]
    createMany?: PlanningDetailCreateManyCategoryInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
  }

  export type PlanningDetailUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PlanningDetailCreateWithoutCategoryInput, PlanningDetailUncheckedCreateWithoutCategoryInput> | PlanningDetailCreateWithoutCategoryInput[] | PlanningDetailUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCategoryInput | PlanningDetailCreateOrConnectWithoutCategoryInput[]
    createMany?: PlanningDetailCreateManyCategoryInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type GenderUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<GenderCreateWithoutCategoriesInput, GenderUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: GenderCreateOrConnectWithoutCategoriesInput
    upsert?: GenderUpsertWithoutCategoriesInput
    connect?: GenderWhereUniqueInput
    update?: XOR<XOR<GenderUpdateToOneWithWhereWithoutCategoriesInput, GenderUpdateWithoutCategoriesInput>, GenderUncheckedUpdateWithoutCategoriesInput>
  }

  export type SubCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type PlanningDetailUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutCategoryInput, PlanningDetailUncheckedCreateWithoutCategoryInput> | PlanningDetailCreateWithoutCategoryInput[] | PlanningDetailUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCategoryInput | PlanningDetailCreateOrConnectWithoutCategoryInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutCategoryInput | PlanningDetailUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PlanningDetailCreateManyCategoryInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutCategoryInput | PlanningDetailUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutCategoryInput | PlanningDetailUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput> | SubCategoryCreateWithoutCategoryInput[] | SubCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubCategoryCreateOrConnectWithoutCategoryInput | SubCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubCategoryUpsertWithWhereUniqueWithoutCategoryInput | SubCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    disconnect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    delete?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    connect?: SubCategoryWhereUniqueInput | SubCategoryWhereUniqueInput[]
    update?: SubCategoryUpdateWithWhereUniqueWithoutCategoryInput | SubCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubCategoryUpdateManyWithWhereWithoutCategoryInput | SubCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
  }

  export type PlanningDetailUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutCategoryInput, PlanningDetailUncheckedCreateWithoutCategoryInput> | PlanningDetailCreateWithoutCategoryInput[] | PlanningDetailUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutCategoryInput | PlanningDetailCreateOrConnectWithoutCategoryInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutCategoryInput | PlanningDetailUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PlanningDetailCreateManyCategoryInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutCategoryInput | PlanningDetailUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutCategoryInput | PlanningDetailUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutSubCategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type PlanningDetailCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<PlanningDetailCreateWithoutSubCategoryInput, PlanningDetailUncheckedCreateWithoutSubCategoryInput> | PlanningDetailCreateWithoutSubCategoryInput[] | PlanningDetailUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutSubCategoryInput | PlanningDetailCreateOrConnectWithoutSubCategoryInput[]
    createMany?: PlanningDetailCreateManySubCategoryInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type PlanningDetailUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<PlanningDetailCreateWithoutSubCategoryInput, PlanningDetailUncheckedCreateWithoutSubCategoryInput> | PlanningDetailCreateWithoutSubCategoryInput[] | PlanningDetailUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutSubCategoryInput | PlanningDetailCreateOrConnectWithoutSubCategoryInput[]
    createMany?: PlanningDetailCreateManySubCategoryInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoriesInput
    upsert?: CategoryUpsertWithoutSubCategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubCategoriesInput, CategoryUpdateWithoutSubCategoriesInput>, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type PlanningDetailUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutSubCategoryInput, PlanningDetailUncheckedCreateWithoutSubCategoryInput> | PlanningDetailCreateWithoutSubCategoryInput[] | PlanningDetailUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutSubCategoryInput | PlanningDetailCreateOrConnectWithoutSubCategoryInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutSubCategoryInput | PlanningDetailUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: PlanningDetailCreateManySubCategoryInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutSubCategoryInput | PlanningDetailUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutSubCategoryInput | PlanningDetailUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type PlanningDetailUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutSubCategoryInput, PlanningDetailUncheckedCreateWithoutSubCategoryInput> | PlanningDetailCreateWithoutSubCategoryInput[] | PlanningDetailUncheckedCreateWithoutSubCategoryInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutSubCategoryInput | PlanningDetailCreateOrConnectWithoutSubCategoryInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutSubCategoryInput | PlanningDetailUpsertWithWhereUniqueWithoutSubCategoryInput[]
    createMany?: PlanningDetailCreateManySubCategoryInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutSubCategoryInput | PlanningDetailUpdateWithWhereUniqueWithoutSubCategoryInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutSubCategoryInput | PlanningDetailUpdateManyWithWhereWithoutSubCategoryInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type GroupBrandCreateNestedOneWithoutSkuCatalogInput = {
    create?: XOR<GroupBrandCreateWithoutSkuCatalogInput, GroupBrandUncheckedCreateWithoutSkuCatalogInput>
    connectOrCreate?: GroupBrandCreateOrConnectWithoutSkuCatalogInput
    connect?: GroupBrandWhereUniqueInput
  }

  export type ProposalProductCreateNestedManyWithoutSkuInput = {
    create?: XOR<ProposalProductCreateWithoutSkuInput, ProposalProductUncheckedCreateWithoutSkuInput> | ProposalProductCreateWithoutSkuInput[] | ProposalProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutSkuInput | ProposalProductCreateOrConnectWithoutSkuInput[]
    createMany?: ProposalProductCreateManySkuInputEnvelope
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
  }

  export type SizeCurveRecommendationCreateNestedManyWithoutSkuInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutSkuInput, SizeCurveRecommendationUncheckedCreateWithoutSkuInput> | SizeCurveRecommendationCreateWithoutSkuInput[] | SizeCurveRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutSkuInput | SizeCurveRecommendationCreateOrConnectWithoutSkuInput[]
    createMany?: SizeCurveRecommendationCreateManySkuInputEnvelope
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
  }

  export type SkuPerformanceCreateNestedManyWithoutSkuInput = {
    create?: XOR<SkuPerformanceCreateWithoutSkuInput, SkuPerformanceUncheckedCreateWithoutSkuInput> | SkuPerformanceCreateWithoutSkuInput[] | SkuPerformanceUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutSkuInput | SkuPerformanceCreateOrConnectWithoutSkuInput[]
    createMany?: SkuPerformanceCreateManySkuInputEnvelope
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
  }

  export type SkuRecommendationCreateNestedManyWithoutSkuInput = {
    create?: XOR<SkuRecommendationCreateWithoutSkuInput, SkuRecommendationUncheckedCreateWithoutSkuInput> | SkuRecommendationCreateWithoutSkuInput[] | SkuRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutSkuInput | SkuRecommendationCreateOrConnectWithoutSkuInput[]
    createMany?: SkuRecommendationCreateManySkuInputEnvelope
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
  }

  export type ProposalProductUncheckedCreateNestedManyWithoutSkuInput = {
    create?: XOR<ProposalProductCreateWithoutSkuInput, ProposalProductUncheckedCreateWithoutSkuInput> | ProposalProductCreateWithoutSkuInput[] | ProposalProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutSkuInput | ProposalProductCreateOrConnectWithoutSkuInput[]
    createMany?: ProposalProductCreateManySkuInputEnvelope
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
  }

  export type SizeCurveRecommendationUncheckedCreateNestedManyWithoutSkuInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutSkuInput, SizeCurveRecommendationUncheckedCreateWithoutSkuInput> | SizeCurveRecommendationCreateWithoutSkuInput[] | SizeCurveRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutSkuInput | SizeCurveRecommendationCreateOrConnectWithoutSkuInput[]
    createMany?: SizeCurveRecommendationCreateManySkuInputEnvelope
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
  }

  export type SkuPerformanceUncheckedCreateNestedManyWithoutSkuInput = {
    create?: XOR<SkuPerformanceCreateWithoutSkuInput, SkuPerformanceUncheckedCreateWithoutSkuInput> | SkuPerformanceCreateWithoutSkuInput[] | SkuPerformanceUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutSkuInput | SkuPerformanceCreateOrConnectWithoutSkuInput[]
    createMany?: SkuPerformanceCreateManySkuInputEnvelope
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
  }

  export type SkuRecommendationUncheckedCreateNestedManyWithoutSkuInput = {
    create?: XOR<SkuRecommendationCreateWithoutSkuInput, SkuRecommendationUncheckedCreateWithoutSkuInput> | SkuRecommendationCreateWithoutSkuInput[] | SkuRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutSkuInput | SkuRecommendationCreateOrConnectWithoutSkuInput[]
    createMany?: SkuRecommendationCreateManySkuInputEnvelope
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type GroupBrandUpdateOneWithoutSkuCatalogNestedInput = {
    create?: XOR<GroupBrandCreateWithoutSkuCatalogInput, GroupBrandUncheckedCreateWithoutSkuCatalogInput>
    connectOrCreate?: GroupBrandCreateOrConnectWithoutSkuCatalogInput
    upsert?: GroupBrandUpsertWithoutSkuCatalogInput
    disconnect?: GroupBrandWhereInput | boolean
    delete?: GroupBrandWhereInput | boolean
    connect?: GroupBrandWhereUniqueInput
    update?: XOR<XOR<GroupBrandUpdateToOneWithWhereWithoutSkuCatalogInput, GroupBrandUpdateWithoutSkuCatalogInput>, GroupBrandUncheckedUpdateWithoutSkuCatalogInput>
  }

  export type ProposalProductUpdateManyWithoutSkuNestedInput = {
    create?: XOR<ProposalProductCreateWithoutSkuInput, ProposalProductUncheckedCreateWithoutSkuInput> | ProposalProductCreateWithoutSkuInput[] | ProposalProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutSkuInput | ProposalProductCreateOrConnectWithoutSkuInput[]
    upsert?: ProposalProductUpsertWithWhereUniqueWithoutSkuInput | ProposalProductUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: ProposalProductCreateManySkuInputEnvelope
    set?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    disconnect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    delete?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    update?: ProposalProductUpdateWithWhereUniqueWithoutSkuInput | ProposalProductUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: ProposalProductUpdateManyWithWhereWithoutSkuInput | ProposalProductUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: ProposalProductScalarWhereInput | ProposalProductScalarWhereInput[]
  }

  export type SizeCurveRecommendationUpdateManyWithoutSkuNestedInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutSkuInput, SizeCurveRecommendationUncheckedCreateWithoutSkuInput> | SizeCurveRecommendationCreateWithoutSkuInput[] | SizeCurveRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutSkuInput | SizeCurveRecommendationCreateOrConnectWithoutSkuInput[]
    upsert?: SizeCurveRecommendationUpsertWithWhereUniqueWithoutSkuInput | SizeCurveRecommendationUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: SizeCurveRecommendationCreateManySkuInputEnvelope
    set?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    disconnect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    delete?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    update?: SizeCurveRecommendationUpdateWithWhereUniqueWithoutSkuInput | SizeCurveRecommendationUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: SizeCurveRecommendationUpdateManyWithWhereWithoutSkuInput | SizeCurveRecommendationUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: SizeCurveRecommendationScalarWhereInput | SizeCurveRecommendationScalarWhereInput[]
  }

  export type SkuPerformanceUpdateManyWithoutSkuNestedInput = {
    create?: XOR<SkuPerformanceCreateWithoutSkuInput, SkuPerformanceUncheckedCreateWithoutSkuInput> | SkuPerformanceCreateWithoutSkuInput[] | SkuPerformanceUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutSkuInput | SkuPerformanceCreateOrConnectWithoutSkuInput[]
    upsert?: SkuPerformanceUpsertWithWhereUniqueWithoutSkuInput | SkuPerformanceUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: SkuPerformanceCreateManySkuInputEnvelope
    set?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    disconnect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    delete?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    update?: SkuPerformanceUpdateWithWhereUniqueWithoutSkuInput | SkuPerformanceUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: SkuPerformanceUpdateManyWithWhereWithoutSkuInput | SkuPerformanceUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: SkuPerformanceScalarWhereInput | SkuPerformanceScalarWhereInput[]
  }

  export type SkuRecommendationUpdateManyWithoutSkuNestedInput = {
    create?: XOR<SkuRecommendationCreateWithoutSkuInput, SkuRecommendationUncheckedCreateWithoutSkuInput> | SkuRecommendationCreateWithoutSkuInput[] | SkuRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutSkuInput | SkuRecommendationCreateOrConnectWithoutSkuInput[]
    upsert?: SkuRecommendationUpsertWithWhereUniqueWithoutSkuInput | SkuRecommendationUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: SkuRecommendationCreateManySkuInputEnvelope
    set?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    disconnect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    delete?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    update?: SkuRecommendationUpdateWithWhereUniqueWithoutSkuInput | SkuRecommendationUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: SkuRecommendationUpdateManyWithWhereWithoutSkuInput | SkuRecommendationUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: SkuRecommendationScalarWhereInput | SkuRecommendationScalarWhereInput[]
  }

  export type ProposalProductUncheckedUpdateManyWithoutSkuNestedInput = {
    create?: XOR<ProposalProductCreateWithoutSkuInput, ProposalProductUncheckedCreateWithoutSkuInput> | ProposalProductCreateWithoutSkuInput[] | ProposalProductUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutSkuInput | ProposalProductCreateOrConnectWithoutSkuInput[]
    upsert?: ProposalProductUpsertWithWhereUniqueWithoutSkuInput | ProposalProductUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: ProposalProductCreateManySkuInputEnvelope
    set?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    disconnect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    delete?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    update?: ProposalProductUpdateWithWhereUniqueWithoutSkuInput | ProposalProductUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: ProposalProductUpdateManyWithWhereWithoutSkuInput | ProposalProductUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: ProposalProductScalarWhereInput | ProposalProductScalarWhereInput[]
  }

  export type SizeCurveRecommendationUncheckedUpdateManyWithoutSkuNestedInput = {
    create?: XOR<SizeCurveRecommendationCreateWithoutSkuInput, SizeCurveRecommendationUncheckedCreateWithoutSkuInput> | SizeCurveRecommendationCreateWithoutSkuInput[] | SizeCurveRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SizeCurveRecommendationCreateOrConnectWithoutSkuInput | SizeCurveRecommendationCreateOrConnectWithoutSkuInput[]
    upsert?: SizeCurveRecommendationUpsertWithWhereUniqueWithoutSkuInput | SizeCurveRecommendationUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: SizeCurveRecommendationCreateManySkuInputEnvelope
    set?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    disconnect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    delete?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    connect?: SizeCurveRecommendationWhereUniqueInput | SizeCurveRecommendationWhereUniqueInput[]
    update?: SizeCurveRecommendationUpdateWithWhereUniqueWithoutSkuInput | SizeCurveRecommendationUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: SizeCurveRecommendationUpdateManyWithWhereWithoutSkuInput | SizeCurveRecommendationUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: SizeCurveRecommendationScalarWhereInput | SizeCurveRecommendationScalarWhereInput[]
  }

  export type SkuPerformanceUncheckedUpdateManyWithoutSkuNestedInput = {
    create?: XOR<SkuPerformanceCreateWithoutSkuInput, SkuPerformanceUncheckedCreateWithoutSkuInput> | SkuPerformanceCreateWithoutSkuInput[] | SkuPerformanceUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuPerformanceCreateOrConnectWithoutSkuInput | SkuPerformanceCreateOrConnectWithoutSkuInput[]
    upsert?: SkuPerformanceUpsertWithWhereUniqueWithoutSkuInput | SkuPerformanceUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: SkuPerformanceCreateManySkuInputEnvelope
    set?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    disconnect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    delete?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    connect?: SkuPerformanceWhereUniqueInput | SkuPerformanceWhereUniqueInput[]
    update?: SkuPerformanceUpdateWithWhereUniqueWithoutSkuInput | SkuPerformanceUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: SkuPerformanceUpdateManyWithWhereWithoutSkuInput | SkuPerformanceUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: SkuPerformanceScalarWhereInput | SkuPerformanceScalarWhereInput[]
  }

  export type SkuRecommendationUncheckedUpdateManyWithoutSkuNestedInput = {
    create?: XOR<SkuRecommendationCreateWithoutSkuInput, SkuRecommendationUncheckedCreateWithoutSkuInput> | SkuRecommendationCreateWithoutSkuInput[] | SkuRecommendationUncheckedCreateWithoutSkuInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutSkuInput | SkuRecommendationCreateOrConnectWithoutSkuInput[]
    upsert?: SkuRecommendationUpsertWithWhereUniqueWithoutSkuInput | SkuRecommendationUpsertWithWhereUniqueWithoutSkuInput[]
    createMany?: SkuRecommendationCreateManySkuInputEnvelope
    set?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    disconnect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    delete?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    update?: SkuRecommendationUpdateWithWhereUniqueWithoutSkuInput | SkuRecommendationUpdateWithWhereUniqueWithoutSkuInput[]
    updateMany?: SkuRecommendationUpdateManyWithWhereWithoutSkuInput | SkuRecommendationUpdateManyWithWhereWithoutSkuInput[]
    deleteMany?: SkuRecommendationScalarWhereInput | SkuRecommendationScalarWhereInput[]
  }

  export type GroupBrandCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<GroupBrandCreateWithoutBudgetsInput, GroupBrandUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: GroupBrandCreateOrConnectWithoutBudgetsInput
    connect?: GroupBrandWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedBudgetsInput = {
    create?: XOR<UserCreateWithoutCreatedBudgetsInput, UserUncheckedCreateWithoutCreatedBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBudgetsInput
    connect?: UserWhereUniqueInput
  }

  export type BudgetDetailCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetDetailCreateWithoutBudgetInput, BudgetDetailUncheckedCreateWithoutBudgetInput> | BudgetDetailCreateWithoutBudgetInput[] | BudgetDetailUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutBudgetInput | BudgetDetailCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetDetailCreateManyBudgetInputEnvelope
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutBudgetInput = {
    create?: XOR<ProposalCreateWithoutBudgetInput, ProposalUncheckedCreateWithoutBudgetInput> | ProposalCreateWithoutBudgetInput[] | ProposalUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutBudgetInput | ProposalCreateOrConnectWithoutBudgetInput[]
    createMany?: ProposalCreateManyBudgetInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type BudgetAlertCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetAlertCreateWithoutBudgetInput, BudgetAlertUncheckedCreateWithoutBudgetInput> | BudgetAlertCreateWithoutBudgetInput[] | BudgetAlertUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetAlertCreateOrConnectWithoutBudgetInput | BudgetAlertCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetAlertCreateManyBudgetInputEnvelope
    connect?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
  }

  export type BudgetSnapshotCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetSnapshotCreateWithoutBudgetInput, BudgetSnapshotUncheckedCreateWithoutBudgetInput> | BudgetSnapshotCreateWithoutBudgetInput[] | BudgetSnapshotUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetSnapshotCreateOrConnectWithoutBudgetInput | BudgetSnapshotCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetSnapshotCreateManyBudgetInputEnvelope
    connect?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
  }

  export type BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetDetailCreateWithoutBudgetInput, BudgetDetailUncheckedCreateWithoutBudgetInput> | BudgetDetailCreateWithoutBudgetInput[] | BudgetDetailUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutBudgetInput | BudgetDetailCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetDetailCreateManyBudgetInputEnvelope
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<ProposalCreateWithoutBudgetInput, ProposalUncheckedCreateWithoutBudgetInput> | ProposalCreateWithoutBudgetInput[] | ProposalUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutBudgetInput | ProposalCreateOrConnectWithoutBudgetInput[]
    createMany?: ProposalCreateManyBudgetInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetAlertCreateWithoutBudgetInput, BudgetAlertUncheckedCreateWithoutBudgetInput> | BudgetAlertCreateWithoutBudgetInput[] | BudgetAlertUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetAlertCreateOrConnectWithoutBudgetInput | BudgetAlertCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetAlertCreateManyBudgetInputEnvelope
    connect?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
  }

  export type BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput = {
    create?: XOR<BudgetSnapshotCreateWithoutBudgetInput, BudgetSnapshotUncheckedCreateWithoutBudgetInput> | BudgetSnapshotCreateWithoutBudgetInput[] | BudgetSnapshotUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetSnapshotCreateOrConnectWithoutBudgetInput | BudgetSnapshotCreateOrConnectWithoutBudgetInput[]
    createMany?: BudgetSnapshotCreateManyBudgetInputEnvelope
    connect?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
  }

  export type EnumBudgetStatusFieldUpdateOperationsInput = {
    set?: $Enums.BudgetStatus
  }

  export type GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<GroupBrandCreateWithoutBudgetsInput, GroupBrandUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: GroupBrandCreateOrConnectWithoutBudgetsInput
    upsert?: GroupBrandUpsertWithoutBudgetsInput
    connect?: GroupBrandWhereUniqueInput
    update?: XOR<XOR<GroupBrandUpdateToOneWithWhereWithoutBudgetsInput, GroupBrandUpdateWithoutBudgetsInput>, GroupBrandUncheckedUpdateWithoutBudgetsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBudgetsInput, UserUncheckedCreateWithoutCreatedBudgetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBudgetsInput
    upsert?: UserUpsertWithoutCreatedBudgetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBudgetsInput, UserUpdateWithoutCreatedBudgetsInput>, UserUncheckedUpdateWithoutCreatedBudgetsInput>
  }

  export type BudgetDetailUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutBudgetInput, BudgetDetailUncheckedCreateWithoutBudgetInput> | BudgetDetailCreateWithoutBudgetInput[] | BudgetDetailUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutBudgetInput | BudgetDetailCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetDetailUpsertWithWhereUniqueWithoutBudgetInput | BudgetDetailUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetDetailCreateManyBudgetInputEnvelope
    set?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    disconnect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    delete?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    update?: BudgetDetailUpdateWithWhereUniqueWithoutBudgetInput | BudgetDetailUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetDetailUpdateManyWithWhereWithoutBudgetInput | BudgetDetailUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetDetailScalarWhereInput | BudgetDetailScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<ProposalCreateWithoutBudgetInput, ProposalUncheckedCreateWithoutBudgetInput> | ProposalCreateWithoutBudgetInput[] | ProposalUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutBudgetInput | ProposalCreateOrConnectWithoutBudgetInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutBudgetInput | ProposalUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: ProposalCreateManyBudgetInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutBudgetInput | ProposalUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutBudgetInput | ProposalUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type BudgetAlertUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetAlertCreateWithoutBudgetInput, BudgetAlertUncheckedCreateWithoutBudgetInput> | BudgetAlertCreateWithoutBudgetInput[] | BudgetAlertUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetAlertCreateOrConnectWithoutBudgetInput | BudgetAlertCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetAlertUpsertWithWhereUniqueWithoutBudgetInput | BudgetAlertUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetAlertCreateManyBudgetInputEnvelope
    set?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    disconnect?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    delete?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    connect?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    update?: BudgetAlertUpdateWithWhereUniqueWithoutBudgetInput | BudgetAlertUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetAlertUpdateManyWithWhereWithoutBudgetInput | BudgetAlertUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetAlertScalarWhereInput | BudgetAlertScalarWhereInput[]
  }

  export type BudgetSnapshotUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetSnapshotCreateWithoutBudgetInput, BudgetSnapshotUncheckedCreateWithoutBudgetInput> | BudgetSnapshotCreateWithoutBudgetInput[] | BudgetSnapshotUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetSnapshotCreateOrConnectWithoutBudgetInput | BudgetSnapshotCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetSnapshotUpsertWithWhereUniqueWithoutBudgetInput | BudgetSnapshotUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetSnapshotCreateManyBudgetInputEnvelope
    set?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    disconnect?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    delete?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    connect?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    update?: BudgetSnapshotUpdateWithWhereUniqueWithoutBudgetInput | BudgetSnapshotUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetSnapshotUpdateManyWithWhereWithoutBudgetInput | BudgetSnapshotUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetSnapshotScalarWhereInput | BudgetSnapshotScalarWhereInput[]
  }

  export type BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutBudgetInput, BudgetDetailUncheckedCreateWithoutBudgetInput> | BudgetDetailCreateWithoutBudgetInput[] | BudgetDetailUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutBudgetInput | BudgetDetailCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetDetailUpsertWithWhereUniqueWithoutBudgetInput | BudgetDetailUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetDetailCreateManyBudgetInputEnvelope
    set?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    disconnect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    delete?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    connect?: BudgetDetailWhereUniqueInput | BudgetDetailWhereUniqueInput[]
    update?: BudgetDetailUpdateWithWhereUniqueWithoutBudgetInput | BudgetDetailUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetDetailUpdateManyWithWhereWithoutBudgetInput | BudgetDetailUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetDetailScalarWhereInput | BudgetDetailScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<ProposalCreateWithoutBudgetInput, ProposalUncheckedCreateWithoutBudgetInput> | ProposalCreateWithoutBudgetInput[] | ProposalUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutBudgetInput | ProposalCreateOrConnectWithoutBudgetInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutBudgetInput | ProposalUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: ProposalCreateManyBudgetInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutBudgetInput | ProposalUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutBudgetInput | ProposalUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetAlertCreateWithoutBudgetInput, BudgetAlertUncheckedCreateWithoutBudgetInput> | BudgetAlertCreateWithoutBudgetInput[] | BudgetAlertUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetAlertCreateOrConnectWithoutBudgetInput | BudgetAlertCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetAlertUpsertWithWhereUniqueWithoutBudgetInput | BudgetAlertUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetAlertCreateManyBudgetInputEnvelope
    set?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    disconnect?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    delete?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    connect?: BudgetAlertWhereUniqueInput | BudgetAlertWhereUniqueInput[]
    update?: BudgetAlertUpdateWithWhereUniqueWithoutBudgetInput | BudgetAlertUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetAlertUpdateManyWithWhereWithoutBudgetInput | BudgetAlertUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetAlertScalarWhereInput | BudgetAlertScalarWhereInput[]
  }

  export type BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput = {
    create?: XOR<BudgetSnapshotCreateWithoutBudgetInput, BudgetSnapshotUncheckedCreateWithoutBudgetInput> | BudgetSnapshotCreateWithoutBudgetInput[] | BudgetSnapshotUncheckedCreateWithoutBudgetInput[]
    connectOrCreate?: BudgetSnapshotCreateOrConnectWithoutBudgetInput | BudgetSnapshotCreateOrConnectWithoutBudgetInput[]
    upsert?: BudgetSnapshotUpsertWithWhereUniqueWithoutBudgetInput | BudgetSnapshotUpsertWithWhereUniqueWithoutBudgetInput[]
    createMany?: BudgetSnapshotCreateManyBudgetInputEnvelope
    set?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    disconnect?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    delete?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    connect?: BudgetSnapshotWhereUniqueInput | BudgetSnapshotWhereUniqueInput[]
    update?: BudgetSnapshotUpdateWithWhereUniqueWithoutBudgetInput | BudgetSnapshotUpdateWithWhereUniqueWithoutBudgetInput[]
    updateMany?: BudgetSnapshotUpdateManyWithWhereWithoutBudgetInput | BudgetSnapshotUpdateManyWithWhereWithoutBudgetInput[]
    deleteMany?: BudgetSnapshotScalarWhereInput | BudgetSnapshotScalarWhereInput[]
  }

  export type BudgetCreateNestedOneWithoutDetailsInput = {
    create?: XOR<BudgetCreateWithoutDetailsInput, BudgetUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutDetailsInput
    connect?: BudgetWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutBudgetDetailsInput = {
    create?: XOR<StoreCreateWithoutBudgetDetailsInput, StoreUncheckedCreateWithoutBudgetDetailsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutBudgetDetailsInput
    connect?: StoreWhereUniqueInput
  }

  export type PlanningVersionCreateNestedManyWithoutBudgetDetailInput = {
    create?: XOR<PlanningVersionCreateWithoutBudgetDetailInput, PlanningVersionUncheckedCreateWithoutBudgetDetailInput> | PlanningVersionCreateWithoutBudgetDetailInput[] | PlanningVersionUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutBudgetDetailInput | PlanningVersionCreateOrConnectWithoutBudgetDetailInput[]
    createMany?: PlanningVersionCreateManyBudgetDetailInputEnvelope
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
  }

  export type AllocationRecommendationCreateNestedManyWithoutBudgetDetailInput = {
    create?: XOR<AllocationRecommendationCreateWithoutBudgetDetailInput, AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput> | AllocationRecommendationCreateWithoutBudgetDetailInput[] | AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput | AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    createMany?: AllocationRecommendationCreateManyBudgetDetailInputEnvelope
    connect?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
  }

  export type SkuRecommendationCreateNestedManyWithoutBudgetDetailInput = {
    create?: XOR<SkuRecommendationCreateWithoutBudgetDetailInput, SkuRecommendationUncheckedCreateWithoutBudgetDetailInput> | SkuRecommendationCreateWithoutBudgetDetailInput[] | SkuRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutBudgetDetailInput | SkuRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    createMany?: SkuRecommendationCreateManyBudgetDetailInputEnvelope
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
  }

  export type PlanningVersionUncheckedCreateNestedManyWithoutBudgetDetailInput = {
    create?: XOR<PlanningVersionCreateWithoutBudgetDetailInput, PlanningVersionUncheckedCreateWithoutBudgetDetailInput> | PlanningVersionCreateWithoutBudgetDetailInput[] | PlanningVersionUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutBudgetDetailInput | PlanningVersionCreateOrConnectWithoutBudgetDetailInput[]
    createMany?: PlanningVersionCreateManyBudgetDetailInputEnvelope
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
  }

  export type AllocationRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput = {
    create?: XOR<AllocationRecommendationCreateWithoutBudgetDetailInput, AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput> | AllocationRecommendationCreateWithoutBudgetDetailInput[] | AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput | AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    createMany?: AllocationRecommendationCreateManyBudgetDetailInputEnvelope
    connect?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
  }

  export type SkuRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput = {
    create?: XOR<SkuRecommendationCreateWithoutBudgetDetailInput, SkuRecommendationUncheckedCreateWithoutBudgetDetailInput> | SkuRecommendationCreateWithoutBudgetDetailInput[] | SkuRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutBudgetDetailInput | SkuRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    createMany?: SkuRecommendationCreateManyBudgetDetailInputEnvelope
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
  }

  export type BudgetUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<BudgetCreateWithoutDetailsInput, BudgetUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutDetailsInput
    upsert?: BudgetUpsertWithoutDetailsInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutDetailsInput, BudgetUpdateWithoutDetailsInput>, BudgetUncheckedUpdateWithoutDetailsInput>
  }

  export type StoreUpdateOneRequiredWithoutBudgetDetailsNestedInput = {
    create?: XOR<StoreCreateWithoutBudgetDetailsInput, StoreUncheckedCreateWithoutBudgetDetailsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutBudgetDetailsInput
    upsert?: StoreUpsertWithoutBudgetDetailsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutBudgetDetailsInput, StoreUpdateWithoutBudgetDetailsInput>, StoreUncheckedUpdateWithoutBudgetDetailsInput>
  }

  export type PlanningVersionUpdateManyWithoutBudgetDetailNestedInput = {
    create?: XOR<PlanningVersionCreateWithoutBudgetDetailInput, PlanningVersionUncheckedCreateWithoutBudgetDetailInput> | PlanningVersionCreateWithoutBudgetDetailInput[] | PlanningVersionUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutBudgetDetailInput | PlanningVersionCreateOrConnectWithoutBudgetDetailInput[]
    upsert?: PlanningVersionUpsertWithWhereUniqueWithoutBudgetDetailInput | PlanningVersionUpsertWithWhereUniqueWithoutBudgetDetailInput[]
    createMany?: PlanningVersionCreateManyBudgetDetailInputEnvelope
    set?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    disconnect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    delete?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    update?: PlanningVersionUpdateWithWhereUniqueWithoutBudgetDetailInput | PlanningVersionUpdateWithWhereUniqueWithoutBudgetDetailInput[]
    updateMany?: PlanningVersionUpdateManyWithWhereWithoutBudgetDetailInput | PlanningVersionUpdateManyWithWhereWithoutBudgetDetailInput[]
    deleteMany?: PlanningVersionScalarWhereInput | PlanningVersionScalarWhereInput[]
  }

  export type AllocationRecommendationUpdateManyWithoutBudgetDetailNestedInput = {
    create?: XOR<AllocationRecommendationCreateWithoutBudgetDetailInput, AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput> | AllocationRecommendationCreateWithoutBudgetDetailInput[] | AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput | AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    upsert?: AllocationRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput | AllocationRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput[]
    createMany?: AllocationRecommendationCreateManyBudgetDetailInputEnvelope
    set?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    disconnect?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    delete?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    connect?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    update?: AllocationRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput | AllocationRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput[]
    updateMany?: AllocationRecommendationUpdateManyWithWhereWithoutBudgetDetailInput | AllocationRecommendationUpdateManyWithWhereWithoutBudgetDetailInput[]
    deleteMany?: AllocationRecommendationScalarWhereInput | AllocationRecommendationScalarWhereInput[]
  }

  export type SkuRecommendationUpdateManyWithoutBudgetDetailNestedInput = {
    create?: XOR<SkuRecommendationCreateWithoutBudgetDetailInput, SkuRecommendationUncheckedCreateWithoutBudgetDetailInput> | SkuRecommendationCreateWithoutBudgetDetailInput[] | SkuRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutBudgetDetailInput | SkuRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    upsert?: SkuRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput | SkuRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput[]
    createMany?: SkuRecommendationCreateManyBudgetDetailInputEnvelope
    set?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    disconnect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    delete?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    update?: SkuRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput | SkuRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput[]
    updateMany?: SkuRecommendationUpdateManyWithWhereWithoutBudgetDetailInput | SkuRecommendationUpdateManyWithWhereWithoutBudgetDetailInput[]
    deleteMany?: SkuRecommendationScalarWhereInput | SkuRecommendationScalarWhereInput[]
  }

  export type PlanningVersionUncheckedUpdateManyWithoutBudgetDetailNestedInput = {
    create?: XOR<PlanningVersionCreateWithoutBudgetDetailInput, PlanningVersionUncheckedCreateWithoutBudgetDetailInput> | PlanningVersionCreateWithoutBudgetDetailInput[] | PlanningVersionUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutBudgetDetailInput | PlanningVersionCreateOrConnectWithoutBudgetDetailInput[]
    upsert?: PlanningVersionUpsertWithWhereUniqueWithoutBudgetDetailInput | PlanningVersionUpsertWithWhereUniqueWithoutBudgetDetailInput[]
    createMany?: PlanningVersionCreateManyBudgetDetailInputEnvelope
    set?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    disconnect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    delete?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    connect?: PlanningVersionWhereUniqueInput | PlanningVersionWhereUniqueInput[]
    update?: PlanningVersionUpdateWithWhereUniqueWithoutBudgetDetailInput | PlanningVersionUpdateWithWhereUniqueWithoutBudgetDetailInput[]
    updateMany?: PlanningVersionUpdateManyWithWhereWithoutBudgetDetailInput | PlanningVersionUpdateManyWithWhereWithoutBudgetDetailInput[]
    deleteMany?: PlanningVersionScalarWhereInput | PlanningVersionScalarWhereInput[]
  }

  export type AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput = {
    create?: XOR<AllocationRecommendationCreateWithoutBudgetDetailInput, AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput> | AllocationRecommendationCreateWithoutBudgetDetailInput[] | AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput | AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    upsert?: AllocationRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput | AllocationRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput[]
    createMany?: AllocationRecommendationCreateManyBudgetDetailInputEnvelope
    set?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    disconnect?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    delete?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    connect?: AllocationRecommendationWhereUniqueInput | AllocationRecommendationWhereUniqueInput[]
    update?: AllocationRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput | AllocationRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput[]
    updateMany?: AllocationRecommendationUpdateManyWithWhereWithoutBudgetDetailInput | AllocationRecommendationUpdateManyWithWhereWithoutBudgetDetailInput[]
    deleteMany?: AllocationRecommendationScalarWhereInput | AllocationRecommendationScalarWhereInput[]
  }

  export type SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput = {
    create?: XOR<SkuRecommendationCreateWithoutBudgetDetailInput, SkuRecommendationUncheckedCreateWithoutBudgetDetailInput> | SkuRecommendationCreateWithoutBudgetDetailInput[] | SkuRecommendationUncheckedCreateWithoutBudgetDetailInput[]
    connectOrCreate?: SkuRecommendationCreateOrConnectWithoutBudgetDetailInput | SkuRecommendationCreateOrConnectWithoutBudgetDetailInput[]
    upsert?: SkuRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput | SkuRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput[]
    createMany?: SkuRecommendationCreateManyBudgetDetailInputEnvelope
    set?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    disconnect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    delete?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    connect?: SkuRecommendationWhereUniqueInput | SkuRecommendationWhereUniqueInput[]
    update?: SkuRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput | SkuRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput[]
    updateMany?: SkuRecommendationUpdateManyWithWhereWithoutBudgetDetailInput | SkuRecommendationUpdateManyWithWhereWithoutBudgetDetailInput[]
    deleteMany?: SkuRecommendationScalarWhereInput | SkuRecommendationScalarWhereInput[]
  }

  export type BudgetDetailCreateNestedOneWithoutPlanningVersionsInput = {
    create?: XOR<BudgetDetailCreateWithoutPlanningVersionsInput, BudgetDetailUncheckedCreateWithoutPlanningVersionsInput>
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutPlanningVersionsInput
    connect?: BudgetDetailWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedPlanningsInput = {
    create?: XOR<UserCreateWithoutCreatedPlanningsInput, UserUncheckedCreateWithoutCreatedPlanningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPlanningsInput
    connect?: UserWhereUniqueInput
  }

  export type PlanningDetailCreateNestedManyWithoutPlanningVersionInput = {
    create?: XOR<PlanningDetailCreateWithoutPlanningVersionInput, PlanningDetailUncheckedCreateWithoutPlanningVersionInput> | PlanningDetailCreateWithoutPlanningVersionInput[] | PlanningDetailUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutPlanningVersionInput | PlanningDetailCreateOrConnectWithoutPlanningVersionInput[]
    createMany?: PlanningDetailCreateManyPlanningVersionInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutPlanningVersionInput = {
    create?: XOR<ProposalCreateWithoutPlanningVersionInput, ProposalUncheckedCreateWithoutPlanningVersionInput> | ProposalCreateWithoutPlanningVersionInput[] | ProposalUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPlanningVersionInput | ProposalCreateOrConnectWithoutPlanningVersionInput[]
    createMany?: ProposalCreateManyPlanningVersionInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type PlanningDetailUncheckedCreateNestedManyWithoutPlanningVersionInput = {
    create?: XOR<PlanningDetailCreateWithoutPlanningVersionInput, PlanningDetailUncheckedCreateWithoutPlanningVersionInput> | PlanningDetailCreateWithoutPlanningVersionInput[] | PlanningDetailUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutPlanningVersionInput | PlanningDetailCreateOrConnectWithoutPlanningVersionInput[]
    createMany?: PlanningDetailCreateManyPlanningVersionInputEnvelope
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutPlanningVersionInput = {
    create?: XOR<ProposalCreateWithoutPlanningVersionInput, ProposalUncheckedCreateWithoutPlanningVersionInput> | ProposalCreateWithoutPlanningVersionInput[] | ProposalUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPlanningVersionInput | ProposalCreateOrConnectWithoutPlanningVersionInput[]
    createMany?: ProposalCreateManyPlanningVersionInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type EnumPlanningStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlanningStatus
  }

  export type BudgetDetailUpdateOneRequiredWithoutPlanningVersionsNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutPlanningVersionsInput, BudgetDetailUncheckedCreateWithoutPlanningVersionsInput>
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutPlanningVersionsInput
    upsert?: BudgetDetailUpsertWithoutPlanningVersionsInput
    connect?: BudgetDetailWhereUniqueInput
    update?: XOR<XOR<BudgetDetailUpdateToOneWithWhereWithoutPlanningVersionsInput, BudgetDetailUpdateWithoutPlanningVersionsInput>, BudgetDetailUncheckedUpdateWithoutPlanningVersionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedPlanningsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPlanningsInput, UserUncheckedCreateWithoutCreatedPlanningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPlanningsInput
    upsert?: UserUpsertWithoutCreatedPlanningsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPlanningsInput, UserUpdateWithoutCreatedPlanningsInput>, UserUncheckedUpdateWithoutCreatedPlanningsInput>
  }

  export type PlanningDetailUpdateManyWithoutPlanningVersionNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutPlanningVersionInput, PlanningDetailUncheckedCreateWithoutPlanningVersionInput> | PlanningDetailCreateWithoutPlanningVersionInput[] | PlanningDetailUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutPlanningVersionInput | PlanningDetailCreateOrConnectWithoutPlanningVersionInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutPlanningVersionInput | PlanningDetailUpsertWithWhereUniqueWithoutPlanningVersionInput[]
    createMany?: PlanningDetailCreateManyPlanningVersionInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutPlanningVersionInput | PlanningDetailUpdateWithWhereUniqueWithoutPlanningVersionInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutPlanningVersionInput | PlanningDetailUpdateManyWithWhereWithoutPlanningVersionInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutPlanningVersionNestedInput = {
    create?: XOR<ProposalCreateWithoutPlanningVersionInput, ProposalUncheckedCreateWithoutPlanningVersionInput> | ProposalCreateWithoutPlanningVersionInput[] | ProposalUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPlanningVersionInput | ProposalCreateOrConnectWithoutPlanningVersionInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutPlanningVersionInput | ProposalUpsertWithWhereUniqueWithoutPlanningVersionInput[]
    createMany?: ProposalCreateManyPlanningVersionInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutPlanningVersionInput | ProposalUpdateWithWhereUniqueWithoutPlanningVersionInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutPlanningVersionInput | ProposalUpdateManyWithWhereWithoutPlanningVersionInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type PlanningDetailUncheckedUpdateManyWithoutPlanningVersionNestedInput = {
    create?: XOR<PlanningDetailCreateWithoutPlanningVersionInput, PlanningDetailUncheckedCreateWithoutPlanningVersionInput> | PlanningDetailCreateWithoutPlanningVersionInput[] | PlanningDetailUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: PlanningDetailCreateOrConnectWithoutPlanningVersionInput | PlanningDetailCreateOrConnectWithoutPlanningVersionInput[]
    upsert?: PlanningDetailUpsertWithWhereUniqueWithoutPlanningVersionInput | PlanningDetailUpsertWithWhereUniqueWithoutPlanningVersionInput[]
    createMany?: PlanningDetailCreateManyPlanningVersionInputEnvelope
    set?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    disconnect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    delete?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    connect?: PlanningDetailWhereUniqueInput | PlanningDetailWhereUniqueInput[]
    update?: PlanningDetailUpdateWithWhereUniqueWithoutPlanningVersionInput | PlanningDetailUpdateWithWhereUniqueWithoutPlanningVersionInput[]
    updateMany?: PlanningDetailUpdateManyWithWhereWithoutPlanningVersionInput | PlanningDetailUpdateManyWithWhereWithoutPlanningVersionInput[]
    deleteMany?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutPlanningVersionNestedInput = {
    create?: XOR<ProposalCreateWithoutPlanningVersionInput, ProposalUncheckedCreateWithoutPlanningVersionInput> | ProposalCreateWithoutPlanningVersionInput[] | ProposalUncheckedCreateWithoutPlanningVersionInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutPlanningVersionInput | ProposalCreateOrConnectWithoutPlanningVersionInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutPlanningVersionInput | ProposalUpsertWithWhereUniqueWithoutPlanningVersionInput[]
    createMany?: ProposalCreateManyPlanningVersionInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutPlanningVersionInput | ProposalUpdateWithWhereUniqueWithoutPlanningVersionInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutPlanningVersionInput | ProposalUpdateManyWithWhereWithoutPlanningVersionInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type PlanningVersionCreateNestedOneWithoutDetailsInput = {
    create?: XOR<PlanningVersionCreateWithoutDetailsInput, PlanningVersionUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutDetailsInput
    connect?: PlanningVersionWhereUniqueInput
  }

  export type CollectionCreateNestedOneWithoutPlanningDetailsInput = {
    create?: XOR<CollectionCreateWithoutPlanningDetailsInput, CollectionUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutPlanningDetailsInput
    connect?: CollectionWhereUniqueInput
  }

  export type GenderCreateNestedOneWithoutPlanningDetailsInput = {
    create?: XOR<GenderCreateWithoutPlanningDetailsInput, GenderUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: GenderCreateOrConnectWithoutPlanningDetailsInput
    connect?: GenderWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPlanningDetailsInput = {
    create?: XOR<CategoryCreateWithoutPlanningDetailsInput, CategoryUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPlanningDetailsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SubCategoryCreateNestedOneWithoutPlanningDetailsInput = {
    create?: XOR<SubCategoryCreateWithoutPlanningDetailsInput, SubCategoryUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutPlanningDetailsInput
    connect?: SubCategoryWhereUniqueInput
  }

  export type PlanningVersionUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<PlanningVersionCreateWithoutDetailsInput, PlanningVersionUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutDetailsInput
    upsert?: PlanningVersionUpsertWithoutDetailsInput
    connect?: PlanningVersionWhereUniqueInput
    update?: XOR<XOR<PlanningVersionUpdateToOneWithWhereWithoutDetailsInput, PlanningVersionUpdateWithoutDetailsInput>, PlanningVersionUncheckedUpdateWithoutDetailsInput>
  }

  export type CollectionUpdateOneWithoutPlanningDetailsNestedInput = {
    create?: XOR<CollectionCreateWithoutPlanningDetailsInput, CollectionUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutPlanningDetailsInput
    upsert?: CollectionUpsertWithoutPlanningDetailsInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutPlanningDetailsInput, CollectionUpdateWithoutPlanningDetailsInput>, CollectionUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type GenderUpdateOneWithoutPlanningDetailsNestedInput = {
    create?: XOR<GenderCreateWithoutPlanningDetailsInput, GenderUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: GenderCreateOrConnectWithoutPlanningDetailsInput
    upsert?: GenderUpsertWithoutPlanningDetailsInput
    disconnect?: GenderWhereInput | boolean
    delete?: GenderWhereInput | boolean
    connect?: GenderWhereUniqueInput
    update?: XOR<XOR<GenderUpdateToOneWithWhereWithoutPlanningDetailsInput, GenderUpdateWithoutPlanningDetailsInput>, GenderUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type CategoryUpdateOneWithoutPlanningDetailsNestedInput = {
    create?: XOR<CategoryCreateWithoutPlanningDetailsInput, CategoryUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPlanningDetailsInput
    upsert?: CategoryUpsertWithoutPlanningDetailsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPlanningDetailsInput, CategoryUpdateWithoutPlanningDetailsInput>, CategoryUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type SubCategoryUpdateOneWithoutPlanningDetailsNestedInput = {
    create?: XOR<SubCategoryCreateWithoutPlanningDetailsInput, SubCategoryUncheckedCreateWithoutPlanningDetailsInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutPlanningDetailsInput
    upsert?: SubCategoryUpsertWithoutPlanningDetailsInput
    disconnect?: SubCategoryWhereInput | boolean
    delete?: SubCategoryWhereInput | boolean
    connect?: SubCategoryWhereUniqueInput
    update?: XOR<XOR<SubCategoryUpdateToOneWithWhereWithoutPlanningDetailsInput, SubCategoryUpdateWithoutPlanningDetailsInput>, SubCategoryUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type BudgetCreateNestedOneWithoutProposalsInput = {
    create?: XOR<BudgetCreateWithoutProposalsInput, BudgetUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutProposalsInput
    connect?: BudgetWhereUniqueInput
  }

  export type PlanningVersionCreateNestedOneWithoutProposalsInput = {
    create?: XOR<PlanningVersionCreateWithoutProposalsInput, PlanningVersionUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutProposalsInput
    connect?: PlanningVersionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedProposalsInput = {
    create?: XOR<UserCreateWithoutCreatedProposalsInput, UserUncheckedCreateWithoutCreatedProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProposalsInput
    connect?: UserWhereUniqueInput
  }

  export type ProposalProductCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalProductCreateWithoutProposalInput, ProposalProductUncheckedCreateWithoutProposalInput> | ProposalProductCreateWithoutProposalInput[] | ProposalProductUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutProposalInput | ProposalProductCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalProductCreateManyProposalInputEnvelope
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
  }

  export type ProposalProductUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalProductCreateWithoutProposalInput, ProposalProductUncheckedCreateWithoutProposalInput> | ProposalProductCreateWithoutProposalInput[] | ProposalProductUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutProposalInput | ProposalProductCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalProductCreateManyProposalInputEnvelope
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
  }

  export type EnumProposalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProposalStatus
  }

  export type BudgetUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<BudgetCreateWithoutProposalsInput, BudgetUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutProposalsInput
    upsert?: BudgetUpsertWithoutProposalsInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutProposalsInput, BudgetUpdateWithoutProposalsInput>, BudgetUncheckedUpdateWithoutProposalsInput>
  }

  export type PlanningVersionUpdateOneWithoutProposalsNestedInput = {
    create?: XOR<PlanningVersionCreateWithoutProposalsInput, PlanningVersionUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: PlanningVersionCreateOrConnectWithoutProposalsInput
    upsert?: PlanningVersionUpsertWithoutProposalsInput
    disconnect?: PlanningVersionWhereInput | boolean
    delete?: PlanningVersionWhereInput | boolean
    connect?: PlanningVersionWhereUniqueInput
    update?: XOR<XOR<PlanningVersionUpdateToOneWithWhereWithoutProposalsInput, PlanningVersionUpdateWithoutProposalsInput>, PlanningVersionUncheckedUpdateWithoutProposalsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedProposalsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedProposalsInput, UserUncheckedCreateWithoutCreatedProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedProposalsInput
    upsert?: UserUpsertWithoutCreatedProposalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedProposalsInput, UserUpdateWithoutCreatedProposalsInput>, UserUncheckedUpdateWithoutCreatedProposalsInput>
  }

  export type ProposalProductUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalProductCreateWithoutProposalInput, ProposalProductUncheckedCreateWithoutProposalInput> | ProposalProductCreateWithoutProposalInput[] | ProposalProductUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutProposalInput | ProposalProductCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalProductUpsertWithWhereUniqueWithoutProposalInput | ProposalProductUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalProductCreateManyProposalInputEnvelope
    set?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    disconnect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    delete?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    update?: ProposalProductUpdateWithWhereUniqueWithoutProposalInput | ProposalProductUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalProductUpdateManyWithWhereWithoutProposalInput | ProposalProductUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalProductScalarWhereInput | ProposalProductScalarWhereInput[]
  }

  export type ProposalProductUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalProductCreateWithoutProposalInput, ProposalProductUncheckedCreateWithoutProposalInput> | ProposalProductCreateWithoutProposalInput[] | ProposalProductUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalProductCreateOrConnectWithoutProposalInput | ProposalProductCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalProductUpsertWithWhereUniqueWithoutProposalInput | ProposalProductUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalProductCreateManyProposalInputEnvelope
    set?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    disconnect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    delete?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    connect?: ProposalProductWhereUniqueInput | ProposalProductWhereUniqueInput[]
    update?: ProposalProductUpdateWithWhereUniqueWithoutProposalInput | ProposalProductUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalProductUpdateManyWithWhereWithoutProposalInput | ProposalProductUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalProductScalarWhereInput | ProposalProductScalarWhereInput[]
  }

  export type ProposalCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProposalCreateWithoutProductsInput, ProposalUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutProductsInput
    connect?: ProposalWhereUniqueInput
  }

  export type SkuCatalogCreateNestedOneWithoutProductsInput = {
    create?: XOR<SkuCatalogCreateWithoutProductsInput, SkuCatalogUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutProductsInput
    connect?: SkuCatalogWhereUniqueInput
  }

  export type ProductAllocationCreateNestedManyWithoutProposalProductInput = {
    create?: XOR<ProductAllocationCreateWithoutProposalProductInput, ProductAllocationUncheckedCreateWithoutProposalProductInput> | ProductAllocationCreateWithoutProposalProductInput[] | ProductAllocationUncheckedCreateWithoutProposalProductInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutProposalProductInput | ProductAllocationCreateOrConnectWithoutProposalProductInput[]
    createMany?: ProductAllocationCreateManyProposalProductInputEnvelope
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
  }

  export type ProductAllocationUncheckedCreateNestedManyWithoutProposalProductInput = {
    create?: XOR<ProductAllocationCreateWithoutProposalProductInput, ProductAllocationUncheckedCreateWithoutProposalProductInput> | ProductAllocationCreateWithoutProposalProductInput[] | ProductAllocationUncheckedCreateWithoutProposalProductInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutProposalProductInput | ProductAllocationCreateOrConnectWithoutProposalProductInput[]
    createMany?: ProductAllocationCreateManyProposalProductInputEnvelope
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
  }

  export type ProposalUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProposalCreateWithoutProductsInput, ProposalUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProposalCreateOrConnectWithoutProductsInput
    upsert?: ProposalUpsertWithoutProductsInput
    connect?: ProposalWhereUniqueInput
    update?: XOR<XOR<ProposalUpdateToOneWithWhereWithoutProductsInput, ProposalUpdateWithoutProductsInput>, ProposalUncheckedUpdateWithoutProductsInput>
  }

  export type SkuCatalogUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SkuCatalogCreateWithoutProductsInput, SkuCatalogUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutProductsInput
    upsert?: SkuCatalogUpsertWithoutProductsInput
    connect?: SkuCatalogWhereUniqueInput
    update?: XOR<XOR<SkuCatalogUpdateToOneWithWhereWithoutProductsInput, SkuCatalogUpdateWithoutProductsInput>, SkuCatalogUncheckedUpdateWithoutProductsInput>
  }

  export type ProductAllocationUpdateManyWithoutProposalProductNestedInput = {
    create?: XOR<ProductAllocationCreateWithoutProposalProductInput, ProductAllocationUncheckedCreateWithoutProposalProductInput> | ProductAllocationCreateWithoutProposalProductInput[] | ProductAllocationUncheckedCreateWithoutProposalProductInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutProposalProductInput | ProductAllocationCreateOrConnectWithoutProposalProductInput[]
    upsert?: ProductAllocationUpsertWithWhereUniqueWithoutProposalProductInput | ProductAllocationUpsertWithWhereUniqueWithoutProposalProductInput[]
    createMany?: ProductAllocationCreateManyProposalProductInputEnvelope
    set?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    disconnect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    delete?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    update?: ProductAllocationUpdateWithWhereUniqueWithoutProposalProductInput | ProductAllocationUpdateWithWhereUniqueWithoutProposalProductInput[]
    updateMany?: ProductAllocationUpdateManyWithWhereWithoutProposalProductInput | ProductAllocationUpdateManyWithWhereWithoutProposalProductInput[]
    deleteMany?: ProductAllocationScalarWhereInput | ProductAllocationScalarWhereInput[]
  }

  export type ProductAllocationUncheckedUpdateManyWithoutProposalProductNestedInput = {
    create?: XOR<ProductAllocationCreateWithoutProposalProductInput, ProductAllocationUncheckedCreateWithoutProposalProductInput> | ProductAllocationCreateWithoutProposalProductInput[] | ProductAllocationUncheckedCreateWithoutProposalProductInput[]
    connectOrCreate?: ProductAllocationCreateOrConnectWithoutProposalProductInput | ProductAllocationCreateOrConnectWithoutProposalProductInput[]
    upsert?: ProductAllocationUpsertWithWhereUniqueWithoutProposalProductInput | ProductAllocationUpsertWithWhereUniqueWithoutProposalProductInput[]
    createMany?: ProductAllocationCreateManyProposalProductInputEnvelope
    set?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    disconnect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    delete?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    connect?: ProductAllocationWhereUniqueInput | ProductAllocationWhereUniqueInput[]
    update?: ProductAllocationUpdateWithWhereUniqueWithoutProposalProductInput | ProductAllocationUpdateWithWhereUniqueWithoutProposalProductInput[]
    updateMany?: ProductAllocationUpdateManyWithWhereWithoutProposalProductInput | ProductAllocationUpdateManyWithWhereWithoutProposalProductInput[]
    deleteMany?: ProductAllocationScalarWhereInput | ProductAllocationScalarWhereInput[]
  }

  export type ProposalProductCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<ProposalProductCreateWithoutAllocationsInput, ProposalProductUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: ProposalProductCreateOrConnectWithoutAllocationsInput
    connect?: ProposalProductWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutProductAllocationsInput = {
    create?: XOR<StoreCreateWithoutProductAllocationsInput, StoreUncheckedCreateWithoutProductAllocationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductAllocationsInput
    connect?: StoreWhereUniqueInput
  }

  export type ProposalProductUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<ProposalProductCreateWithoutAllocationsInput, ProposalProductUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: ProposalProductCreateOrConnectWithoutAllocationsInput
    upsert?: ProposalProductUpsertWithoutAllocationsInput
    connect?: ProposalProductWhereUniqueInput
    update?: XOR<XOR<ProposalProductUpdateToOneWithWhereWithoutAllocationsInput, ProposalProductUpdateWithoutAllocationsInput>, ProposalProductUncheckedUpdateWithoutAllocationsInput>
  }

  export type StoreUpdateOneRequiredWithoutProductAllocationsNestedInput = {
    create?: XOR<StoreCreateWithoutProductAllocationsInput, StoreUncheckedCreateWithoutProductAllocationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutProductAllocationsInput
    upsert?: StoreUpsertWithoutProductAllocationsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutProductAllocationsInput, StoreUpdateWithoutProductAllocationsInput>, StoreUncheckedUpdateWithoutProductAllocationsInput>
  }

  export type UserCreateNestedOneWithoutApprovalDecisionsInput = {
    create?: XOR<UserCreateWithoutApprovalDecisionsInput, UserUncheckedCreateWithoutApprovalDecisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalDecisionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalActionFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalAction
  }

  export type UserUpdateOneRequiredWithoutApprovalDecisionsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalDecisionsInput, UserUncheckedCreateWithoutApprovalDecisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalDecisionsInput
    upsert?: UserUpsertWithoutApprovalDecisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalDecisionsInput, UserUpdateWithoutApprovalDecisionsInput>, UserUncheckedUpdateWithoutApprovalDecisionsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type StoreCreateNestedOneWithoutSalesHistoryInput = {
    create?: XOR<StoreCreateWithoutSalesHistoryInput, StoreUncheckedCreateWithoutSalesHistoryInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesHistoryInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneRequiredWithoutSalesHistoryNestedInput = {
    create?: XOR<StoreCreateWithoutSalesHistoryInput, StoreUncheckedCreateWithoutSalesHistoryInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSalesHistoryInput
    upsert?: StoreUpsertWithoutSalesHistoryInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSalesHistoryInput, StoreUpdateWithoutSalesHistoryInput>, StoreUncheckedUpdateWithoutSalesHistoryInput>
  }

  export type SkuCatalogCreateNestedOneWithoutSizeCurveRecommendationsInput = {
    create?: XOR<SkuCatalogCreateWithoutSizeCurveRecommendationsInput, SkuCatalogUncheckedCreateWithoutSizeCurveRecommendationsInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutSizeCurveRecommendationsInput
    connect?: SkuCatalogWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutSizeCurveRecommendationsInput = {
    create?: XOR<StoreCreateWithoutSizeCurveRecommendationsInput, StoreUncheckedCreateWithoutSizeCurveRecommendationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSizeCurveRecommendationsInput
    connect?: StoreWhereUniqueInput
  }

  export type SkuCatalogUpdateOneRequiredWithoutSizeCurveRecommendationsNestedInput = {
    create?: XOR<SkuCatalogCreateWithoutSizeCurveRecommendationsInput, SkuCatalogUncheckedCreateWithoutSizeCurveRecommendationsInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutSizeCurveRecommendationsInput
    upsert?: SkuCatalogUpsertWithoutSizeCurveRecommendationsInput
    connect?: SkuCatalogWhereUniqueInput
    update?: XOR<XOR<SkuCatalogUpdateToOneWithWhereWithoutSizeCurveRecommendationsInput, SkuCatalogUpdateWithoutSizeCurveRecommendationsInput>, SkuCatalogUncheckedUpdateWithoutSizeCurveRecommendationsInput>
  }

  export type StoreUpdateOneRequiredWithoutSizeCurveRecommendationsNestedInput = {
    create?: XOR<StoreCreateWithoutSizeCurveRecommendationsInput, StoreUncheckedCreateWithoutSizeCurveRecommendationsInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSizeCurveRecommendationsInput
    upsert?: StoreUpsertWithoutSizeCurveRecommendationsInput
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSizeCurveRecommendationsInput, StoreUpdateWithoutSizeCurveRecommendationsInput>, StoreUncheckedUpdateWithoutSizeCurveRecommendationsInput>
  }

  export type BudgetCreateNestedOneWithoutBudgetAlertsInput = {
    create?: XOR<BudgetCreateWithoutBudgetAlertsInput, BudgetUncheckedCreateWithoutBudgetAlertsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutBudgetAlertsInput
    connect?: BudgetWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutBudgetAlertsNestedInput = {
    create?: XOR<BudgetCreateWithoutBudgetAlertsInput, BudgetUncheckedCreateWithoutBudgetAlertsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutBudgetAlertsInput
    upsert?: BudgetUpsertWithoutBudgetAlertsInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutBudgetAlertsInput, BudgetUpdateWithoutBudgetAlertsInput>, BudgetUncheckedUpdateWithoutBudgetAlertsInput>
  }

  export type BudgetCreateNestedOneWithoutBudgetSnapshotsInput = {
    create?: XOR<BudgetCreateWithoutBudgetSnapshotsInput, BudgetUncheckedCreateWithoutBudgetSnapshotsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutBudgetSnapshotsInput
    connect?: BudgetWhereUniqueInput
  }

  export type BudgetUpdateOneRequiredWithoutBudgetSnapshotsNestedInput = {
    create?: XOR<BudgetCreateWithoutBudgetSnapshotsInput, BudgetUncheckedCreateWithoutBudgetSnapshotsInput>
    connectOrCreate?: BudgetCreateOrConnectWithoutBudgetSnapshotsInput
    upsert?: BudgetUpsertWithoutBudgetSnapshotsInput
    connect?: BudgetWhereUniqueInput
    update?: XOR<XOR<BudgetUpdateToOneWithWhereWithoutBudgetSnapshotsInput, BudgetUpdateWithoutBudgetSnapshotsInput>, BudgetUncheckedUpdateWithoutBudgetSnapshotsInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetDetailCreateNestedOneWithoutAllocationRecommendationsInput = {
    create?: XOR<BudgetDetailCreateWithoutAllocationRecommendationsInput, BudgetDetailUncheckedCreateWithoutAllocationRecommendationsInput>
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutAllocationRecommendationsInput
    connect?: BudgetDetailWhereUniqueInput
  }

  export type BudgetDetailUpdateOneRequiredWithoutAllocationRecommendationsNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutAllocationRecommendationsInput, BudgetDetailUncheckedCreateWithoutAllocationRecommendationsInput>
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutAllocationRecommendationsInput
    upsert?: BudgetDetailUpsertWithoutAllocationRecommendationsInput
    connect?: BudgetDetailWhereUniqueInput
    update?: XOR<XOR<BudgetDetailUpdateToOneWithWhereWithoutAllocationRecommendationsInput, BudgetDetailUpdateWithoutAllocationRecommendationsInput>, BudgetDetailUncheckedUpdateWithoutAllocationRecommendationsInput>
  }

  export type SkuCatalogCreateNestedOneWithoutSkuPerformanceInput = {
    create?: XOR<SkuCatalogCreateWithoutSkuPerformanceInput, SkuCatalogUncheckedCreateWithoutSkuPerformanceInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutSkuPerformanceInput
    connect?: SkuCatalogWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutSkuPerformanceInput = {
    create?: XOR<StoreCreateWithoutSkuPerformanceInput, StoreUncheckedCreateWithoutSkuPerformanceInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSkuPerformanceInput
    connect?: StoreWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SkuCatalogUpdateOneRequiredWithoutSkuPerformanceNestedInput = {
    create?: XOR<SkuCatalogCreateWithoutSkuPerformanceInput, SkuCatalogUncheckedCreateWithoutSkuPerformanceInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutSkuPerformanceInput
    upsert?: SkuCatalogUpsertWithoutSkuPerformanceInput
    connect?: SkuCatalogWhereUniqueInput
    update?: XOR<XOR<SkuCatalogUpdateToOneWithWhereWithoutSkuPerformanceInput, SkuCatalogUpdateWithoutSkuPerformanceInput>, SkuCatalogUncheckedUpdateWithoutSkuPerformanceInput>
  }

  export type StoreUpdateOneWithoutSkuPerformanceNestedInput = {
    create?: XOR<StoreCreateWithoutSkuPerformanceInput, StoreUncheckedCreateWithoutSkuPerformanceInput>
    connectOrCreate?: StoreCreateOrConnectWithoutSkuPerformanceInput
    upsert?: StoreUpsertWithoutSkuPerformanceInput
    disconnect?: StoreWhereInput | boolean
    delete?: StoreWhereInput | boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<XOR<StoreUpdateToOneWithWhereWithoutSkuPerformanceInput, StoreUpdateWithoutSkuPerformanceInput>, StoreUncheckedUpdateWithoutSkuPerformanceInput>
  }

  export type BudgetDetailCreateNestedOneWithoutSkuRecommendationsInput = {
    create?: XOR<BudgetDetailCreateWithoutSkuRecommendationsInput, BudgetDetailUncheckedCreateWithoutSkuRecommendationsInput>
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutSkuRecommendationsInput
    connect?: BudgetDetailWhereUniqueInput
  }

  export type SkuCatalogCreateNestedOneWithoutSkuRecommendationsInput = {
    create?: XOR<SkuCatalogCreateWithoutSkuRecommendationsInput, SkuCatalogUncheckedCreateWithoutSkuRecommendationsInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutSkuRecommendationsInput
    connect?: SkuCatalogWhereUniqueInput
  }

  export type BudgetDetailUpdateOneRequiredWithoutSkuRecommendationsNestedInput = {
    create?: XOR<BudgetDetailCreateWithoutSkuRecommendationsInput, BudgetDetailUncheckedCreateWithoutSkuRecommendationsInput>
    connectOrCreate?: BudgetDetailCreateOrConnectWithoutSkuRecommendationsInput
    upsert?: BudgetDetailUpsertWithoutSkuRecommendationsInput
    connect?: BudgetDetailWhereUniqueInput
    update?: XOR<XOR<BudgetDetailUpdateToOneWithWhereWithoutSkuRecommendationsInput, BudgetDetailUpdateWithoutSkuRecommendationsInput>, BudgetDetailUncheckedUpdateWithoutSkuRecommendationsInput>
  }

  export type SkuCatalogUpdateOneRequiredWithoutSkuRecommendationsNestedInput = {
    create?: XOR<SkuCatalogCreateWithoutSkuRecommendationsInput, SkuCatalogUncheckedCreateWithoutSkuRecommendationsInput>
    connectOrCreate?: SkuCatalogCreateOrConnectWithoutSkuRecommendationsInput
    upsert?: SkuCatalogUpsertWithoutSkuRecommendationsInput
    connect?: SkuCatalogWhereUniqueInput
    update?: XOR<XOR<SkuCatalogUpdateToOneWithWhereWithoutSkuRecommendationsInput, SkuCatalogUpdateWithoutSkuRecommendationsInput>, SkuCatalogUncheckedUpdateWithoutSkuRecommendationsInput>
  }

  export type GroupBrandCreateNestedOneWithoutWorkflowStepsInput = {
    create?: XOR<GroupBrandCreateWithoutWorkflowStepsInput, GroupBrandUncheckedCreateWithoutWorkflowStepsInput>
    connectOrCreate?: GroupBrandCreateOrConnectWithoutWorkflowStepsInput
    connect?: GroupBrandWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkflowStepsInput = {
    create?: XOR<UserCreateWithoutWorkflowStepsInput, UserUncheckedCreateWithoutWorkflowStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowStepsInput
    connect?: UserWhereUniqueInput
  }

  export type GroupBrandUpdateOneRequiredWithoutWorkflowStepsNestedInput = {
    create?: XOR<GroupBrandCreateWithoutWorkflowStepsInput, GroupBrandUncheckedCreateWithoutWorkflowStepsInput>
    connectOrCreate?: GroupBrandCreateOrConnectWithoutWorkflowStepsInput
    upsert?: GroupBrandUpsertWithoutWorkflowStepsInput
    connect?: GroupBrandWhereUniqueInput
    update?: XOR<XOR<GroupBrandUpdateToOneWithWhereWithoutWorkflowStepsInput, GroupBrandUpdateWithoutWorkflowStepsInput>, GroupBrandUncheckedUpdateWithoutWorkflowStepsInput>
  }

  export type UserUpdateOneWithoutWorkflowStepsNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowStepsInput, UserUncheckedCreateWithoutWorkflowStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowStepsInput
    upsert?: UserUpsertWithoutWorkflowStepsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowStepsInput, UserUpdateWithoutWorkflowStepsInput>, UserUncheckedUpdateWithoutWorkflowStepsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBudgetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusFilter<$PrismaModel> | $Enums.BudgetStatus
  }

  export type NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetStatus | EnumBudgetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetStatus[] | ListEnumBudgetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetStatusWithAggregatesFilter<$PrismaModel> | $Enums.BudgetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetStatusFilter<$PrismaModel>
    _max?: NestedEnumBudgetStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanningStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanningStatus | EnumPlanningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanningStatusFilter<$PrismaModel> | $Enums.PlanningStatus
  }

  export type NestedEnumPlanningStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanningStatus | EnumPlanningStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanningStatus[] | ListEnumPlanningStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanningStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlanningStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanningStatusFilter<$PrismaModel>
    _max?: NestedEnumPlanningStatusFilter<$PrismaModel>
  }

  export type NestedEnumProposalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusFilter<$PrismaModel> | $Enums.ProposalStatus
  }

  export type NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProposalStatus | EnumProposalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProposalStatus[] | ListEnumProposalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProposalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProposalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProposalStatusFilter<$PrismaModel>
    _max?: NestedEnumProposalStatusFilter<$PrismaModel>
  }

  export type NestedEnumApprovalActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalAction | EnumApprovalActionFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalActionFilter<$PrismaModel> | $Enums.ApprovalAction
  }

  export type NestedEnumApprovalActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalAction | EnumApprovalActionFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalAction[] | ListEnumApprovalActionFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalActionWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalActionFilter<$PrismaModel>
    _max?: NestedEnumApprovalActionFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type BudgetCreateWithoutCreatedByInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupBrand: GroupBrandCreateNestedOneWithoutBudgetsInput
    details?: BudgetDetailCreateNestedManyWithoutBudgetInput
    proposals?: ProposalCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutCreatedByInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutCreatedByInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutCreatedByInput, BudgetUncheckedCreateWithoutCreatedByInput>
  }

  export type BudgetCreateManyCreatedByInputEnvelope = {
    data: BudgetCreateManyCreatedByInput | BudgetCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PlanningVersionCreateWithoutCreatedByInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutPlanningVersionsInput
    details?: PlanningDetailCreateNestedManyWithoutPlanningVersionInput
    proposals?: ProposalCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionUncheckedCreateWithoutCreatedByInput = {
    id?: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: PlanningDetailUncheckedCreateNestedManyWithoutPlanningVersionInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionCreateOrConnectWithoutCreatedByInput = {
    where: PlanningVersionWhereUniqueInput
    create: XOR<PlanningVersionCreateWithoutCreatedByInput, PlanningVersionUncheckedCreateWithoutCreatedByInput>
  }

  export type PlanningVersionCreateManyCreatedByInputEnvelope = {
    data: PlanningVersionCreateManyCreatedByInput | PlanningVersionCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutCreatedByInput = {
    id?: string
    ticketName: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutProposalsInput
    planningVersion?: PlanningVersionCreateNestedOneWithoutProposalsInput
    products?: ProposalProductCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutCreatedByInput = {
    id?: string
    ticketName: string
    budgetId: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProposalProductUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutCreatedByInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput>
  }

  export type ProposalCreateManyCreatedByInputEnvelope = {
    data: ProposalCreateManyCreatedByInput | ProposalCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutDeciderInput = {
    id?: string
    entityType: string
    entityId: string
    level: number
    action: $Enums.ApprovalAction
    comment?: string | null
    decidedAt?: Date | string
  }

  export type ApprovalUncheckedCreateWithoutDeciderInput = {
    id?: string
    entityType: string
    entityId: string
    level: number
    action: $Enums.ApprovalAction
    comment?: string | null
    decidedAt?: Date | string
  }

  export type ApprovalCreateOrConnectWithoutDeciderInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutDeciderInput, ApprovalUncheckedCreateWithoutDeciderInput>
  }

  export type ApprovalCreateManyDeciderInputEnvelope = {
    data: ApprovalCreateManyDeciderInput | ApprovalCreateManyDeciderInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalWorkflowStepCreateWithoutUserInput = {
    id?: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: GroupBrandCreateNestedOneWithoutWorkflowStepsInput
  }

  export type ApprovalWorkflowStepUncheckedCreateWithoutUserInput = {
    id?: string
    brandId: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowStepCreateOrConnectWithoutUserInput = {
    where: ApprovalWorkflowStepWhereUniqueInput
    create: XOR<ApprovalWorkflowStepCreateWithoutUserInput, ApprovalWorkflowStepUncheckedCreateWithoutUserInput>
  }

  export type ApprovalWorkflowStepCreateManyUserInputEnvelope = {
    data: ApprovalWorkflowStepCreateManyUserInput | ApprovalWorkflowStepCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
  }

  export type BudgetUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutCreatedByInput, BudgetUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BudgetCreateWithoutCreatedByInput, BudgetUncheckedCreateWithoutCreatedByInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutCreatedByInput, BudgetUncheckedUpdateWithoutCreatedByInput>
  }

  export type BudgetUpdateManyWithWhereWithoutCreatedByInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    budgetCode?: StringFilter<"Budget"> | string
    groupBrandId?: StringFilter<"Budget"> | string
    seasonGroupId?: StringFilter<"Budget"> | string
    seasonType?: StringFilter<"Budget"> | string
    fiscalYear?: IntFilter<"Budget"> | number
    totalBudget?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFilter<"Budget"> | $Enums.BudgetStatus
    comment?: StringNullableFilter<"Budget"> | string | null
    createdById?: StringFilter<"Budget"> | string
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    updatedAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type PlanningVersionUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PlanningVersionWhereUniqueInput
    update: XOR<PlanningVersionUpdateWithoutCreatedByInput, PlanningVersionUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PlanningVersionCreateWithoutCreatedByInput, PlanningVersionUncheckedCreateWithoutCreatedByInput>
  }

  export type PlanningVersionUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PlanningVersionWhereUniqueInput
    data: XOR<PlanningVersionUpdateWithoutCreatedByInput, PlanningVersionUncheckedUpdateWithoutCreatedByInput>
  }

  export type PlanningVersionUpdateManyWithWhereWithoutCreatedByInput = {
    where: PlanningVersionScalarWhereInput
    data: XOR<PlanningVersionUpdateManyMutationInput, PlanningVersionUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PlanningVersionScalarWhereInput = {
    AND?: PlanningVersionScalarWhereInput | PlanningVersionScalarWhereInput[]
    OR?: PlanningVersionScalarWhereInput[]
    NOT?: PlanningVersionScalarWhereInput | PlanningVersionScalarWhereInput[]
    id?: StringFilter<"PlanningVersion"> | string
    planningCode?: StringFilter<"PlanningVersion"> | string
    budgetDetailId?: StringFilter<"PlanningVersion"> | string
    versionNumber?: IntFilter<"PlanningVersion"> | number
    versionName?: StringNullableFilter<"PlanningVersion"> | string | null
    status?: EnumPlanningStatusFilter<"PlanningVersion"> | $Enums.PlanningStatus
    isFinal?: BoolFilter<"PlanningVersion"> | boolean
    snapshotData?: JsonNullableFilter<"PlanningVersion">
    createdById?: StringFilter<"PlanningVersion"> | string
    createdAt?: DateTimeFilter<"PlanningVersion"> | Date | string
    updatedAt?: DateTimeFilter<"PlanningVersion"> | Date | string
  }

  export type ProposalUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutCreatedByInput, ProposalUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutCreatedByInput, ProposalUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProposalUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    OR?: ProposalScalarWhereInput[]
    NOT?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    id?: StringFilter<"Proposal"> | string
    ticketName?: StringFilter<"Proposal"> | string
    budgetId?: StringFilter<"Proposal"> | string
    planningVersionId?: StringNullableFilter<"Proposal"> | string | null
    status?: EnumProposalStatusFilter<"Proposal"> | $Enums.ProposalStatus
    totalSkuCount?: IntFilter<"Proposal"> | number
    totalOrderQty?: IntFilter<"Proposal"> | number
    totalValue?: DecimalFilter<"Proposal"> | Decimal | DecimalJsLike | number | string
    createdById?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    updatedAt?: DateTimeFilter<"Proposal"> | Date | string
  }

  export type ApprovalUpsertWithWhereUniqueWithoutDeciderInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutDeciderInput, ApprovalUncheckedUpdateWithoutDeciderInput>
    create: XOR<ApprovalCreateWithoutDeciderInput, ApprovalUncheckedCreateWithoutDeciderInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutDeciderInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutDeciderInput, ApprovalUncheckedUpdateWithoutDeciderInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutDeciderInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutDeciderInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    OR?: ApprovalScalarWhereInput[]
    NOT?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    id?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    level?: IntFilter<"Approval"> | number
    deciderId?: StringFilter<"Approval"> | string
    action?: EnumApprovalActionFilter<"Approval"> | $Enums.ApprovalAction
    comment?: StringNullableFilter<"Approval"> | string | null
    decidedAt?: DateTimeFilter<"Approval"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ApprovalWorkflowStepUpsertWithWhereUniqueWithoutUserInput = {
    where: ApprovalWorkflowStepWhereUniqueInput
    update: XOR<ApprovalWorkflowStepUpdateWithoutUserInput, ApprovalWorkflowStepUncheckedUpdateWithoutUserInput>
    create: XOR<ApprovalWorkflowStepCreateWithoutUserInput, ApprovalWorkflowStepUncheckedCreateWithoutUserInput>
  }

  export type ApprovalWorkflowStepUpdateWithWhereUniqueWithoutUserInput = {
    where: ApprovalWorkflowStepWhereUniqueInput
    data: XOR<ApprovalWorkflowStepUpdateWithoutUserInput, ApprovalWorkflowStepUncheckedUpdateWithoutUserInput>
  }

  export type ApprovalWorkflowStepUpdateManyWithWhereWithoutUserInput = {
    where: ApprovalWorkflowStepScalarWhereInput
    data: XOR<ApprovalWorkflowStepUpdateManyMutationInput, ApprovalWorkflowStepUncheckedUpdateManyWithoutUserInput>
  }

  export type ApprovalWorkflowStepScalarWhereInput = {
    AND?: ApprovalWorkflowStepScalarWhereInput | ApprovalWorkflowStepScalarWhereInput[]
    OR?: ApprovalWorkflowStepScalarWhereInput[]
    NOT?: ApprovalWorkflowStepScalarWhereInput | ApprovalWorkflowStepScalarWhereInput[]
    id?: StringFilter<"ApprovalWorkflowStep"> | string
    brandId?: StringFilter<"ApprovalWorkflowStep"> | string
    stepNumber?: IntFilter<"ApprovalWorkflowStep"> | number
    roleName?: StringFilter<"ApprovalWorkflowStep"> | string
    roleCode?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    userId?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    description?: StringNullableFilter<"ApprovalWorkflowStep"> | string | null
    isActive?: BoolFilter<"ApprovalWorkflowStep"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflowStep"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflowStep"> | Date | string
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    roleId?: StringFilter<"User"> | string
    storeAccess?: StringNullableListFilter<"User">
    brandAccess?: StringNullableListFilter<"User">
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type BudgetCreateWithoutGroupBrandInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedBudgetsInput
    details?: BudgetDetailCreateNestedManyWithoutBudgetInput
    proposals?: ProposalCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutGroupBrandInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutGroupBrandInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutGroupBrandInput, BudgetUncheckedCreateWithoutGroupBrandInput>
  }

  export type BudgetCreateManyGroupBrandInputEnvelope = {
    data: BudgetCreateManyGroupBrandInput | BudgetCreateManyGroupBrandInput[]
    skipDuplicates?: boolean
  }

  export type SkuCatalogCreateWithoutBrandInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    products?: ProposalProductCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUncheckedCreateWithoutBrandInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    products?: ProposalProductUncheckedCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogCreateOrConnectWithoutBrandInput = {
    where: SkuCatalogWhereUniqueInput
    create: XOR<SkuCatalogCreateWithoutBrandInput, SkuCatalogUncheckedCreateWithoutBrandInput>
  }

  export type SkuCatalogCreateManyBrandInputEnvelope = {
    data: SkuCatalogCreateManyBrandInput | SkuCatalogCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalWorkflowStepCreateWithoutBrandInput = {
    id?: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutWorkflowStepsInput
  }

  export type ApprovalWorkflowStepUncheckedCreateWithoutBrandInput = {
    id?: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    userId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowStepCreateOrConnectWithoutBrandInput = {
    where: ApprovalWorkflowStepWhereUniqueInput
    create: XOR<ApprovalWorkflowStepCreateWithoutBrandInput, ApprovalWorkflowStepUncheckedCreateWithoutBrandInput>
  }

  export type ApprovalWorkflowStepCreateManyBrandInputEnvelope = {
    data: ApprovalWorkflowStepCreateManyBrandInput | ApprovalWorkflowStepCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type BudgetUpsertWithWhereUniqueWithoutGroupBrandInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutGroupBrandInput, BudgetUncheckedUpdateWithoutGroupBrandInput>
    create: XOR<BudgetCreateWithoutGroupBrandInput, BudgetUncheckedCreateWithoutGroupBrandInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutGroupBrandInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutGroupBrandInput, BudgetUncheckedUpdateWithoutGroupBrandInput>
  }

  export type BudgetUpdateManyWithWhereWithoutGroupBrandInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutGroupBrandInput>
  }

  export type SkuCatalogUpsertWithWhereUniqueWithoutBrandInput = {
    where: SkuCatalogWhereUniqueInput
    update: XOR<SkuCatalogUpdateWithoutBrandInput, SkuCatalogUncheckedUpdateWithoutBrandInput>
    create: XOR<SkuCatalogCreateWithoutBrandInput, SkuCatalogUncheckedCreateWithoutBrandInput>
  }

  export type SkuCatalogUpdateWithWhereUniqueWithoutBrandInput = {
    where: SkuCatalogWhereUniqueInput
    data: XOR<SkuCatalogUpdateWithoutBrandInput, SkuCatalogUncheckedUpdateWithoutBrandInput>
  }

  export type SkuCatalogUpdateManyWithWhereWithoutBrandInput = {
    where: SkuCatalogScalarWhereInput
    data: XOR<SkuCatalogUpdateManyMutationInput, SkuCatalogUncheckedUpdateManyWithoutBrandInput>
  }

  export type SkuCatalogScalarWhereInput = {
    AND?: SkuCatalogScalarWhereInput | SkuCatalogScalarWhereInput[]
    OR?: SkuCatalogScalarWhereInput[]
    NOT?: SkuCatalogScalarWhereInput | SkuCatalogScalarWhereInput[]
    id?: StringFilter<"SkuCatalog"> | string
    skuCode?: StringFilter<"SkuCatalog"> | string
    productName?: StringFilter<"SkuCatalog"> | string
    productType?: StringFilter<"SkuCatalog"> | string
    theme?: StringNullableFilter<"SkuCatalog"> | string | null
    color?: StringNullableFilter<"SkuCatalog"> | string | null
    composition?: StringNullableFilter<"SkuCatalog"> | string | null
    srp?: DecimalFilter<"SkuCatalog"> | Decimal | DecimalJsLike | number | string
    brandId?: StringNullableFilter<"SkuCatalog"> | string | null
    seasonGroupId?: StringNullableFilter<"SkuCatalog"> | string | null
    imageUrl?: StringNullableFilter<"SkuCatalog"> | string | null
    isActive?: BoolFilter<"SkuCatalog"> | boolean
  }

  export type ApprovalWorkflowStepUpsertWithWhereUniqueWithoutBrandInput = {
    where: ApprovalWorkflowStepWhereUniqueInput
    update: XOR<ApprovalWorkflowStepUpdateWithoutBrandInput, ApprovalWorkflowStepUncheckedUpdateWithoutBrandInput>
    create: XOR<ApprovalWorkflowStepCreateWithoutBrandInput, ApprovalWorkflowStepUncheckedCreateWithoutBrandInput>
  }

  export type ApprovalWorkflowStepUpdateWithWhereUniqueWithoutBrandInput = {
    where: ApprovalWorkflowStepWhereUniqueInput
    data: XOR<ApprovalWorkflowStepUpdateWithoutBrandInput, ApprovalWorkflowStepUncheckedUpdateWithoutBrandInput>
  }

  export type ApprovalWorkflowStepUpdateManyWithWhereWithoutBrandInput = {
    where: ApprovalWorkflowStepScalarWhereInput
    data: XOR<ApprovalWorkflowStepUpdateManyMutationInput, ApprovalWorkflowStepUncheckedUpdateManyWithoutBrandInput>
  }

  export type BudgetDetailCreateWithoutStoreInput = {
    id?: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    budget: BudgetCreateNestedOneWithoutDetailsInput
    planningVersions?: PlanningVersionCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUncheckedCreateWithoutStoreInput = {
    id?: string
    budgetId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailCreateOrConnectWithoutStoreInput = {
    where: BudgetDetailWhereUniqueInput
    create: XOR<BudgetDetailCreateWithoutStoreInput, BudgetDetailUncheckedCreateWithoutStoreInput>
  }

  export type BudgetDetailCreateManyStoreInputEnvelope = {
    data: BudgetDetailCreateManyStoreInput | BudgetDetailCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type ProductAllocationCreateWithoutStoreInput = {
    id?: string
    quantity?: number
    proposalProduct: ProposalProductCreateNestedOneWithoutAllocationsInput
  }

  export type ProductAllocationUncheckedCreateWithoutStoreInput = {
    id?: string
    proposalProductId: string
    quantity?: number
  }

  export type ProductAllocationCreateOrConnectWithoutStoreInput = {
    where: ProductAllocationWhereUniqueInput
    create: XOR<ProductAllocationCreateWithoutStoreInput, ProductAllocationUncheckedCreateWithoutStoreInput>
  }

  export type ProductAllocationCreateManyStoreInputEnvelope = {
    data: ProductAllocationCreateManyStoreInput | ProductAllocationCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SalesHistoryCreateWithoutStoreInput = {
    id?: string
    skuCode: string
    sizeCode: string
    season: string
    quantitySold?: number
    quantityBought?: number
    sellThroughPct?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalesHistoryUncheckedCreateWithoutStoreInput = {
    id?: string
    skuCode: string
    sizeCode: string
    season: string
    quantitySold?: number
    quantityBought?: number
    sellThroughPct?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SalesHistoryCreateOrConnectWithoutStoreInput = {
    where: SalesHistoryWhereUniqueInput
    create: XOR<SalesHistoryCreateWithoutStoreInput, SalesHistoryUncheckedCreateWithoutStoreInput>
  }

  export type SalesHistoryCreateManyStoreInputEnvelope = {
    data: SalesHistoryCreateManyStoreInput | SalesHistoryCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SizeCurveRecommendationCreateWithoutStoreInput = {
    id?: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
    sku: SkuCatalogCreateNestedOneWithoutSizeCurveRecommendationsInput
  }

  export type SizeCurveRecommendationUncheckedCreateWithoutStoreInput = {
    id?: string
    skuId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
  }

  export type SizeCurveRecommendationCreateOrConnectWithoutStoreInput = {
    where: SizeCurveRecommendationWhereUniqueInput
    create: XOR<SizeCurveRecommendationCreateWithoutStoreInput, SizeCurveRecommendationUncheckedCreateWithoutStoreInput>
  }

  export type SizeCurveRecommendationCreateManyStoreInputEnvelope = {
    data: SizeCurveRecommendationCreateManyStoreInput | SizeCurveRecommendationCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type SkuPerformanceCreateWithoutStoreInput = {
    id?: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
    sku: SkuCatalogCreateNestedOneWithoutSkuPerformanceInput
  }

  export type SkuPerformanceUncheckedCreateWithoutStoreInput = {
    id?: string
    skuId: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
  }

  export type SkuPerformanceCreateOrConnectWithoutStoreInput = {
    where: SkuPerformanceWhereUniqueInput
    create: XOR<SkuPerformanceCreateWithoutStoreInput, SkuPerformanceUncheckedCreateWithoutStoreInput>
  }

  export type SkuPerformanceCreateManyStoreInputEnvelope = {
    data: SkuPerformanceCreateManyStoreInput | SkuPerformanceCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type BudgetDetailUpsertWithWhereUniqueWithoutStoreInput = {
    where: BudgetDetailWhereUniqueInput
    update: XOR<BudgetDetailUpdateWithoutStoreInput, BudgetDetailUncheckedUpdateWithoutStoreInput>
    create: XOR<BudgetDetailCreateWithoutStoreInput, BudgetDetailUncheckedCreateWithoutStoreInput>
  }

  export type BudgetDetailUpdateWithWhereUniqueWithoutStoreInput = {
    where: BudgetDetailWhereUniqueInput
    data: XOR<BudgetDetailUpdateWithoutStoreInput, BudgetDetailUncheckedUpdateWithoutStoreInput>
  }

  export type BudgetDetailUpdateManyWithWhereWithoutStoreInput = {
    where: BudgetDetailScalarWhereInput
    data: XOR<BudgetDetailUpdateManyMutationInput, BudgetDetailUncheckedUpdateManyWithoutStoreInput>
  }

  export type BudgetDetailScalarWhereInput = {
    AND?: BudgetDetailScalarWhereInput | BudgetDetailScalarWhereInput[]
    OR?: BudgetDetailScalarWhereInput[]
    NOT?: BudgetDetailScalarWhereInput | BudgetDetailScalarWhereInput[]
    id?: StringFilter<"BudgetDetail"> | string
    budgetId?: StringFilter<"BudgetDetail"> | string
    storeId?: StringFilter<"BudgetDetail"> | string
    budgetAmount?: DecimalFilter<"BudgetDetail"> | Decimal | DecimalJsLike | number | string
  }

  export type ProductAllocationUpsertWithWhereUniqueWithoutStoreInput = {
    where: ProductAllocationWhereUniqueInput
    update: XOR<ProductAllocationUpdateWithoutStoreInput, ProductAllocationUncheckedUpdateWithoutStoreInput>
    create: XOR<ProductAllocationCreateWithoutStoreInput, ProductAllocationUncheckedCreateWithoutStoreInput>
  }

  export type ProductAllocationUpdateWithWhereUniqueWithoutStoreInput = {
    where: ProductAllocationWhereUniqueInput
    data: XOR<ProductAllocationUpdateWithoutStoreInput, ProductAllocationUncheckedUpdateWithoutStoreInput>
  }

  export type ProductAllocationUpdateManyWithWhereWithoutStoreInput = {
    where: ProductAllocationScalarWhereInput
    data: XOR<ProductAllocationUpdateManyMutationInput, ProductAllocationUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductAllocationScalarWhereInput = {
    AND?: ProductAllocationScalarWhereInput | ProductAllocationScalarWhereInput[]
    OR?: ProductAllocationScalarWhereInput[]
    NOT?: ProductAllocationScalarWhereInput | ProductAllocationScalarWhereInput[]
    id?: StringFilter<"ProductAllocation"> | string
    proposalProductId?: StringFilter<"ProductAllocation"> | string
    storeId?: StringFilter<"ProductAllocation"> | string
    quantity?: IntFilter<"ProductAllocation"> | number
  }

  export type SalesHistoryUpsertWithWhereUniqueWithoutStoreInput = {
    where: SalesHistoryWhereUniqueInput
    update: XOR<SalesHistoryUpdateWithoutStoreInput, SalesHistoryUncheckedUpdateWithoutStoreInput>
    create: XOR<SalesHistoryCreateWithoutStoreInput, SalesHistoryUncheckedCreateWithoutStoreInput>
  }

  export type SalesHistoryUpdateWithWhereUniqueWithoutStoreInput = {
    where: SalesHistoryWhereUniqueInput
    data: XOR<SalesHistoryUpdateWithoutStoreInput, SalesHistoryUncheckedUpdateWithoutStoreInput>
  }

  export type SalesHistoryUpdateManyWithWhereWithoutStoreInput = {
    where: SalesHistoryScalarWhereInput
    data: XOR<SalesHistoryUpdateManyMutationInput, SalesHistoryUncheckedUpdateManyWithoutStoreInput>
  }

  export type SalesHistoryScalarWhereInput = {
    AND?: SalesHistoryScalarWhereInput | SalesHistoryScalarWhereInput[]
    OR?: SalesHistoryScalarWhereInput[]
    NOT?: SalesHistoryScalarWhereInput | SalesHistoryScalarWhereInput[]
    id?: StringFilter<"SalesHistory"> | string
    skuCode?: StringFilter<"SalesHistory"> | string
    storeId?: StringFilter<"SalesHistory"> | string
    sizeCode?: StringFilter<"SalesHistory"> | string
    season?: StringFilter<"SalesHistory"> | string
    quantitySold?: IntFilter<"SalesHistory"> | number
    quantityBought?: IntFilter<"SalesHistory"> | number
    sellThroughPct?: DecimalFilter<"SalesHistory"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SalesHistory"> | Date | string
  }

  export type SizeCurveRecommendationUpsertWithWhereUniqueWithoutStoreInput = {
    where: SizeCurveRecommendationWhereUniqueInput
    update: XOR<SizeCurveRecommendationUpdateWithoutStoreInput, SizeCurveRecommendationUncheckedUpdateWithoutStoreInput>
    create: XOR<SizeCurveRecommendationCreateWithoutStoreInput, SizeCurveRecommendationUncheckedCreateWithoutStoreInput>
  }

  export type SizeCurveRecommendationUpdateWithWhereUniqueWithoutStoreInput = {
    where: SizeCurveRecommendationWhereUniqueInput
    data: XOR<SizeCurveRecommendationUpdateWithoutStoreInput, SizeCurveRecommendationUncheckedUpdateWithoutStoreInput>
  }

  export type SizeCurveRecommendationUpdateManyWithWhereWithoutStoreInput = {
    where: SizeCurveRecommendationScalarWhereInput
    data: XOR<SizeCurveRecommendationUpdateManyMutationInput, SizeCurveRecommendationUncheckedUpdateManyWithoutStoreInput>
  }

  export type SizeCurveRecommendationScalarWhereInput = {
    AND?: SizeCurveRecommendationScalarWhereInput | SizeCurveRecommendationScalarWhereInput[]
    OR?: SizeCurveRecommendationScalarWhereInput[]
    NOT?: SizeCurveRecommendationScalarWhereInput | SizeCurveRecommendationScalarWhereInput[]
    id?: StringFilter<"SizeCurveRecommendation"> | string
    skuId?: StringFilter<"SizeCurveRecommendation"> | string
    storeId?: StringFilter<"SizeCurveRecommendation"> | string
    category?: StringFilter<"SizeCurveRecommendation"> | string
    sizeCode?: StringFilter<"SizeCurveRecommendation"> | string
    recommendedPct?: DecimalFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"SizeCurveRecommendation"> | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFilter<"SizeCurveRecommendation"> | number
    reasoning?: StringNullableFilter<"SizeCurveRecommendation"> | string | null
    createdAt?: DateTimeFilter<"SizeCurveRecommendation"> | Date | string
  }

  export type SkuPerformanceUpsertWithWhereUniqueWithoutStoreInput = {
    where: SkuPerformanceWhereUniqueInput
    update: XOR<SkuPerformanceUpdateWithoutStoreInput, SkuPerformanceUncheckedUpdateWithoutStoreInput>
    create: XOR<SkuPerformanceCreateWithoutStoreInput, SkuPerformanceUncheckedCreateWithoutStoreInput>
  }

  export type SkuPerformanceUpdateWithWhereUniqueWithoutStoreInput = {
    where: SkuPerformanceWhereUniqueInput
    data: XOR<SkuPerformanceUpdateWithoutStoreInput, SkuPerformanceUncheckedUpdateWithoutStoreInput>
  }

  export type SkuPerformanceUpdateManyWithWhereWithoutStoreInput = {
    where: SkuPerformanceScalarWhereInput
    data: XOR<SkuPerformanceUpdateManyMutationInput, SkuPerformanceUncheckedUpdateManyWithoutStoreInput>
  }

  export type SkuPerformanceScalarWhereInput = {
    AND?: SkuPerformanceScalarWhereInput | SkuPerformanceScalarWhereInput[]
    OR?: SkuPerformanceScalarWhereInput[]
    NOT?: SkuPerformanceScalarWhereInput | SkuPerformanceScalarWhereInput[]
    id?: StringFilter<"SkuPerformance"> | string
    skuId?: StringFilter<"SkuPerformance"> | string
    skuCode?: StringFilter<"SkuPerformance"> | string
    seasonGroup?: StringFilter<"SkuPerformance"> | string
    fiscalYear?: IntFilter<"SkuPerformance"> | number
    storeId?: StringNullableFilter<"SkuPerformance"> | string | null
    quantityBought?: IntFilter<"SkuPerformance"> | number
    quantitySold?: IntFilter<"SkuPerformance"> | number
    sellThroughPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFilter<"SkuPerformance"> | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: IntNullableFilter<"SkuPerformance"> | number | null
    performanceScore?: IntFilter<"SkuPerformance"> | number
    velocityScore?: IntFilter<"SkuPerformance"> | number
    marginScore?: IntFilter<"SkuPerformance"> | number
    createdAt?: DateTimeFilter<"SkuPerformance"> | Date | string
  }

  export type PlanningDetailCreateWithoutCollectionInput = {
    id?: string
    dimensionType: string
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
    planningVersion: PlanningVersionCreateNestedOneWithoutDetailsInput
    gender?: GenderCreateNestedOneWithoutPlanningDetailsInput
    category?: CategoryCreateNestedOneWithoutPlanningDetailsInput
    subCategory?: SubCategoryCreateNestedOneWithoutPlanningDetailsInput
  }

  export type PlanningDetailUncheckedCreateWithoutCollectionInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    genderId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailCreateOrConnectWithoutCollectionInput = {
    where: PlanningDetailWhereUniqueInput
    create: XOR<PlanningDetailCreateWithoutCollectionInput, PlanningDetailUncheckedCreateWithoutCollectionInput>
  }

  export type PlanningDetailCreateManyCollectionInputEnvelope = {
    data: PlanningDetailCreateManyCollectionInput | PlanningDetailCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type PlanningDetailUpsertWithWhereUniqueWithoutCollectionInput = {
    where: PlanningDetailWhereUniqueInput
    update: XOR<PlanningDetailUpdateWithoutCollectionInput, PlanningDetailUncheckedUpdateWithoutCollectionInput>
    create: XOR<PlanningDetailCreateWithoutCollectionInput, PlanningDetailUncheckedCreateWithoutCollectionInput>
  }

  export type PlanningDetailUpdateWithWhereUniqueWithoutCollectionInput = {
    where: PlanningDetailWhereUniqueInput
    data: XOR<PlanningDetailUpdateWithoutCollectionInput, PlanningDetailUncheckedUpdateWithoutCollectionInput>
  }

  export type PlanningDetailUpdateManyWithWhereWithoutCollectionInput = {
    where: PlanningDetailScalarWhereInput
    data: XOR<PlanningDetailUpdateManyMutationInput, PlanningDetailUncheckedUpdateManyWithoutCollectionInput>
  }

  export type PlanningDetailScalarWhereInput = {
    AND?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
    OR?: PlanningDetailScalarWhereInput[]
    NOT?: PlanningDetailScalarWhereInput | PlanningDetailScalarWhereInput[]
    id?: StringFilter<"PlanningDetail"> | string
    planningVersionId?: StringFilter<"PlanningDetail"> | string
    dimensionType?: StringFilter<"PlanningDetail"> | string
    collectionId?: StringNullableFilter<"PlanningDetail"> | string | null
    genderId?: StringNullableFilter<"PlanningDetail"> | string | null
    categoryId?: StringNullableFilter<"PlanningDetail"> | string | null
    subCategoryId?: StringNullableFilter<"PlanningDetail"> | string | null
    lastSeasonSales?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFilter<"PlanningDetail"> | Decimal | DecimalJsLike | number | string
    userComment?: StringNullableFilter<"PlanningDetail"> | string | null
  }

  export type CategoryCreateWithoutGenderInput = {
    id?: string
    name: string
    isActive?: boolean
    subCategories?: SubCategoryCreateNestedManyWithoutCategoryInput
    planningDetails?: PlanningDetailCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutGenderInput = {
    id?: string
    name: string
    isActive?: boolean
    subCategories?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutGenderInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutGenderInput, CategoryUncheckedCreateWithoutGenderInput>
  }

  export type CategoryCreateManyGenderInputEnvelope = {
    data: CategoryCreateManyGenderInput | CategoryCreateManyGenderInput[]
    skipDuplicates?: boolean
  }

  export type PlanningDetailCreateWithoutGenderInput = {
    id?: string
    dimensionType: string
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
    planningVersion: PlanningVersionCreateNestedOneWithoutDetailsInput
    collection?: CollectionCreateNestedOneWithoutPlanningDetailsInput
    category?: CategoryCreateNestedOneWithoutPlanningDetailsInput
    subCategory?: SubCategoryCreateNestedOneWithoutPlanningDetailsInput
  }

  export type PlanningDetailUncheckedCreateWithoutGenderInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailCreateOrConnectWithoutGenderInput = {
    where: PlanningDetailWhereUniqueInput
    create: XOR<PlanningDetailCreateWithoutGenderInput, PlanningDetailUncheckedCreateWithoutGenderInput>
  }

  export type PlanningDetailCreateManyGenderInputEnvelope = {
    data: PlanningDetailCreateManyGenderInput | PlanningDetailCreateManyGenderInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutGenderInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutGenderInput, CategoryUncheckedUpdateWithoutGenderInput>
    create: XOR<CategoryCreateWithoutGenderInput, CategoryUncheckedCreateWithoutGenderInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutGenderInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutGenderInput, CategoryUncheckedUpdateWithoutGenderInput>
  }

  export type CategoryUpdateManyWithWhereWithoutGenderInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutGenderInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    genderId?: StringFilter<"Category"> | string
    isActive?: BoolFilter<"Category"> | boolean
  }

  export type PlanningDetailUpsertWithWhereUniqueWithoutGenderInput = {
    where: PlanningDetailWhereUniqueInput
    update: XOR<PlanningDetailUpdateWithoutGenderInput, PlanningDetailUncheckedUpdateWithoutGenderInput>
    create: XOR<PlanningDetailCreateWithoutGenderInput, PlanningDetailUncheckedCreateWithoutGenderInput>
  }

  export type PlanningDetailUpdateWithWhereUniqueWithoutGenderInput = {
    where: PlanningDetailWhereUniqueInput
    data: XOR<PlanningDetailUpdateWithoutGenderInput, PlanningDetailUncheckedUpdateWithoutGenderInput>
  }

  export type PlanningDetailUpdateManyWithWhereWithoutGenderInput = {
    where: PlanningDetailScalarWhereInput
    data: XOR<PlanningDetailUpdateManyMutationInput, PlanningDetailUncheckedUpdateManyWithoutGenderInput>
  }

  export type GenderCreateWithoutCategoriesInput = {
    id?: string
    name: string
    isActive?: boolean
    planningDetails?: PlanningDetailCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    isActive?: boolean
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderCreateOrConnectWithoutCategoriesInput = {
    where: GenderWhereUniqueInput
    create: XOR<GenderCreateWithoutCategoriesInput, GenderUncheckedCreateWithoutCategoriesInput>
  }

  export type SubCategoryCreateWithoutCategoryInput = {
    id?: string
    name: string
    isActive?: boolean
    planningDetails?: PlanningDetailCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    isActive?: boolean
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryCreateOrConnectWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryCreateManyCategoryInputEnvelope = {
    data: SubCategoryCreateManyCategoryInput | SubCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PlanningDetailCreateWithoutCategoryInput = {
    id?: string
    dimensionType: string
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
    planningVersion: PlanningVersionCreateNestedOneWithoutDetailsInput
    collection?: CollectionCreateNestedOneWithoutPlanningDetailsInput
    gender?: GenderCreateNestedOneWithoutPlanningDetailsInput
    subCategory?: SubCategoryCreateNestedOneWithoutPlanningDetailsInput
  }

  export type PlanningDetailUncheckedCreateWithoutCategoryInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailCreateOrConnectWithoutCategoryInput = {
    where: PlanningDetailWhereUniqueInput
    create: XOR<PlanningDetailCreateWithoutCategoryInput, PlanningDetailUncheckedCreateWithoutCategoryInput>
  }

  export type PlanningDetailCreateManyCategoryInputEnvelope = {
    data: PlanningDetailCreateManyCategoryInput | PlanningDetailCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type GenderUpsertWithoutCategoriesInput = {
    update: XOR<GenderUpdateWithoutCategoriesInput, GenderUncheckedUpdateWithoutCategoriesInput>
    create: XOR<GenderCreateWithoutCategoriesInput, GenderUncheckedCreateWithoutCategoriesInput>
    where?: GenderWhereInput
  }

  export type GenderUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: GenderWhereInput
    data: XOR<GenderUpdateWithoutCategoriesInput, GenderUncheckedUpdateWithoutCategoriesInput>
  }

  export type GenderUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubCategoryScalarWhereInput = {
    AND?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    OR?: SubCategoryScalarWhereInput[]
    NOT?: SubCategoryScalarWhereInput | SubCategoryScalarWhereInput[]
    id?: StringFilter<"SubCategory"> | string
    name?: StringFilter<"SubCategory"> | string
    categoryId?: StringFilter<"SubCategory"> | string
    isActive?: BoolFilter<"SubCategory"> | boolean
  }

  export type PlanningDetailUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PlanningDetailWhereUniqueInput
    update: XOR<PlanningDetailUpdateWithoutCategoryInput, PlanningDetailUncheckedUpdateWithoutCategoryInput>
    create: XOR<PlanningDetailCreateWithoutCategoryInput, PlanningDetailUncheckedCreateWithoutCategoryInput>
  }

  export type PlanningDetailUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PlanningDetailWhereUniqueInput
    data: XOR<PlanningDetailUpdateWithoutCategoryInput, PlanningDetailUncheckedUpdateWithoutCategoryInput>
  }

  export type PlanningDetailUpdateManyWithWhereWithoutCategoryInput = {
    where: PlanningDetailScalarWhereInput
    data: XOR<PlanningDetailUpdateManyMutationInput, PlanningDetailUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryCreateWithoutSubCategoriesInput = {
    id?: string
    name: string
    isActive?: boolean
    gender: GenderCreateNestedOneWithoutCategoriesInput
    planningDetails?: PlanningDetailCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubCategoriesInput = {
    id?: string
    name: string
    genderId: string
    isActive?: boolean
    planningDetails?: PlanningDetailUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubCategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
  }

  export type PlanningDetailCreateWithoutSubCategoryInput = {
    id?: string
    dimensionType: string
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
    planningVersion: PlanningVersionCreateNestedOneWithoutDetailsInput
    collection?: CollectionCreateNestedOneWithoutPlanningDetailsInput
    gender?: GenderCreateNestedOneWithoutPlanningDetailsInput
    category?: CategoryCreateNestedOneWithoutPlanningDetailsInput
  }

  export type PlanningDetailUncheckedCreateWithoutSubCategoryInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    categoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailCreateOrConnectWithoutSubCategoryInput = {
    where: PlanningDetailWhereUniqueInput
    create: XOR<PlanningDetailCreateWithoutSubCategoryInput, PlanningDetailUncheckedCreateWithoutSubCategoryInput>
  }

  export type PlanningDetailCreateManySubCategoryInputEnvelope = {
    data: PlanningDetailCreateManySubCategoryInput | PlanningDetailCreateManySubCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutSubCategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
    create: XOR<CategoryCreateWithoutSubCategoriesInput, CategoryUncheckedCreateWithoutSubCategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubCategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubCategoriesInput, CategoryUncheckedUpdateWithoutSubCategoriesInput>
  }

  export type CategoryUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    gender?: GenderUpdateOneRequiredWithoutCategoriesNestedInput
    planningDetails?: PlanningDetailUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genderId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PlanningDetailUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: PlanningDetailWhereUniqueInput
    update: XOR<PlanningDetailUpdateWithoutSubCategoryInput, PlanningDetailUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<PlanningDetailCreateWithoutSubCategoryInput, PlanningDetailUncheckedCreateWithoutSubCategoryInput>
  }

  export type PlanningDetailUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: PlanningDetailWhereUniqueInput
    data: XOR<PlanningDetailUpdateWithoutSubCategoryInput, PlanningDetailUncheckedUpdateWithoutSubCategoryInput>
  }

  export type PlanningDetailUpdateManyWithWhereWithoutSubCategoryInput = {
    where: PlanningDetailScalarWhereInput
    data: XOR<PlanningDetailUpdateManyMutationInput, PlanningDetailUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type GroupBrandCreateWithoutSkuCatalogInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    budgets?: BudgetCreateNestedManyWithoutGroupBrandInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandUncheckedCreateWithoutSkuCatalogInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    budgets?: BudgetUncheckedCreateNestedManyWithoutGroupBrandInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandCreateOrConnectWithoutSkuCatalogInput = {
    where: GroupBrandWhereUniqueInput
    create: XOR<GroupBrandCreateWithoutSkuCatalogInput, GroupBrandUncheckedCreateWithoutSkuCatalogInput>
  }

  export type ProposalProductCreateWithoutSkuInput = {
    id?: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    proposal: ProposalCreateNestedOneWithoutProductsInput
    allocations?: ProductAllocationCreateNestedManyWithoutProposalProductInput
  }

  export type ProposalProductUncheckedCreateWithoutSkuInput = {
    id?: string
    proposalId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    allocations?: ProductAllocationUncheckedCreateNestedManyWithoutProposalProductInput
  }

  export type ProposalProductCreateOrConnectWithoutSkuInput = {
    where: ProposalProductWhereUniqueInput
    create: XOR<ProposalProductCreateWithoutSkuInput, ProposalProductUncheckedCreateWithoutSkuInput>
  }

  export type ProposalProductCreateManySkuInputEnvelope = {
    data: ProposalProductCreateManySkuInput | ProposalProductCreateManySkuInput[]
    skipDuplicates?: boolean
  }

  export type SizeCurveRecommendationCreateWithoutSkuInput = {
    id?: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
    store: StoreCreateNestedOneWithoutSizeCurveRecommendationsInput
  }

  export type SizeCurveRecommendationUncheckedCreateWithoutSkuInput = {
    id?: string
    storeId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
  }

  export type SizeCurveRecommendationCreateOrConnectWithoutSkuInput = {
    where: SizeCurveRecommendationWhereUniqueInput
    create: XOR<SizeCurveRecommendationCreateWithoutSkuInput, SizeCurveRecommendationUncheckedCreateWithoutSkuInput>
  }

  export type SizeCurveRecommendationCreateManySkuInputEnvelope = {
    data: SizeCurveRecommendationCreateManySkuInput | SizeCurveRecommendationCreateManySkuInput[]
    skipDuplicates?: boolean
  }

  export type SkuPerformanceCreateWithoutSkuInput = {
    id?: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
    store?: StoreCreateNestedOneWithoutSkuPerformanceInput
  }

  export type SkuPerformanceUncheckedCreateWithoutSkuInput = {
    id?: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    storeId?: string | null
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
  }

  export type SkuPerformanceCreateOrConnectWithoutSkuInput = {
    where: SkuPerformanceWhereUniqueInput
    create: XOR<SkuPerformanceCreateWithoutSkuInput, SkuPerformanceUncheckedCreateWithoutSkuInput>
  }

  export type SkuPerformanceCreateManySkuInputEnvelope = {
    data: SkuPerformanceCreateManySkuInput | SkuPerformanceCreateManySkuInput[]
    skipDuplicates?: boolean
  }

  export type SkuRecommendationCreateWithoutSkuInput = {
    id?: string
    category: string
    subCategory?: string | null
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutSkuRecommendationsInput
  }

  export type SkuRecommendationUncheckedCreateWithoutSkuInput = {
    id?: string
    budgetDetailId: string
    category: string
    subCategory?: string | null
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
  }

  export type SkuRecommendationCreateOrConnectWithoutSkuInput = {
    where: SkuRecommendationWhereUniqueInput
    create: XOR<SkuRecommendationCreateWithoutSkuInput, SkuRecommendationUncheckedCreateWithoutSkuInput>
  }

  export type SkuRecommendationCreateManySkuInputEnvelope = {
    data: SkuRecommendationCreateManySkuInput | SkuRecommendationCreateManySkuInput[]
    skipDuplicates?: boolean
  }

  export type GroupBrandUpsertWithoutSkuCatalogInput = {
    update: XOR<GroupBrandUpdateWithoutSkuCatalogInput, GroupBrandUncheckedUpdateWithoutSkuCatalogInput>
    create: XOR<GroupBrandCreateWithoutSkuCatalogInput, GroupBrandUncheckedCreateWithoutSkuCatalogInput>
    where?: GroupBrandWhereInput
  }

  export type GroupBrandUpdateToOneWithWhereWithoutSkuCatalogInput = {
    where?: GroupBrandWhereInput
    data: XOR<GroupBrandUpdateWithoutSkuCatalogInput, GroupBrandUncheckedUpdateWithoutSkuCatalogInput>
  }

  export type GroupBrandUpdateWithoutSkuCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    budgets?: BudgetUpdateManyWithoutGroupBrandNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutBrandNestedInput
  }

  export type GroupBrandUncheckedUpdateWithoutSkuCatalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    budgets?: BudgetUncheckedUpdateManyWithoutGroupBrandNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ProposalProductUpsertWithWhereUniqueWithoutSkuInput = {
    where: ProposalProductWhereUniqueInput
    update: XOR<ProposalProductUpdateWithoutSkuInput, ProposalProductUncheckedUpdateWithoutSkuInput>
    create: XOR<ProposalProductCreateWithoutSkuInput, ProposalProductUncheckedCreateWithoutSkuInput>
  }

  export type ProposalProductUpdateWithWhereUniqueWithoutSkuInput = {
    where: ProposalProductWhereUniqueInput
    data: XOR<ProposalProductUpdateWithoutSkuInput, ProposalProductUncheckedUpdateWithoutSkuInput>
  }

  export type ProposalProductUpdateManyWithWhereWithoutSkuInput = {
    where: ProposalProductScalarWhereInput
    data: XOR<ProposalProductUpdateManyMutationInput, ProposalProductUncheckedUpdateManyWithoutSkuInput>
  }

  export type ProposalProductScalarWhereInput = {
    AND?: ProposalProductScalarWhereInput | ProposalProductScalarWhereInput[]
    OR?: ProposalProductScalarWhereInput[]
    NOT?: ProposalProductScalarWhereInput | ProposalProductScalarWhereInput[]
    id?: StringFilter<"ProposalProduct"> | string
    proposalId?: StringFilter<"ProposalProduct"> | string
    skuId?: StringFilter<"ProposalProduct"> | string
    skuCode?: StringFilter<"ProposalProduct"> | string
    productName?: StringFilter<"ProposalProduct"> | string
    collection?: StringNullableFilter<"ProposalProduct"> | string | null
    gender?: StringNullableFilter<"ProposalProduct"> | string | null
    category?: StringNullableFilter<"ProposalProduct"> | string | null
    subCategory?: StringNullableFilter<"ProposalProduct"> | string | null
    theme?: StringNullableFilter<"ProposalProduct"> | string | null
    color?: StringNullableFilter<"ProposalProduct"> | string | null
    composition?: StringNullableFilter<"ProposalProduct"> | string | null
    unitCost?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    srp?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    orderQty?: IntFilter<"ProposalProduct"> | number
    totalValue?: DecimalFilter<"ProposalProduct"> | Decimal | DecimalJsLike | number | string
    customerTarget?: StringNullableFilter<"ProposalProduct"> | string | null
    imageUrl?: StringNullableFilter<"ProposalProduct"> | string | null
    sortOrder?: IntFilter<"ProposalProduct"> | number
  }

  export type SizeCurveRecommendationUpsertWithWhereUniqueWithoutSkuInput = {
    where: SizeCurveRecommendationWhereUniqueInput
    update: XOR<SizeCurveRecommendationUpdateWithoutSkuInput, SizeCurveRecommendationUncheckedUpdateWithoutSkuInput>
    create: XOR<SizeCurveRecommendationCreateWithoutSkuInput, SizeCurveRecommendationUncheckedCreateWithoutSkuInput>
  }

  export type SizeCurveRecommendationUpdateWithWhereUniqueWithoutSkuInput = {
    where: SizeCurveRecommendationWhereUniqueInput
    data: XOR<SizeCurveRecommendationUpdateWithoutSkuInput, SizeCurveRecommendationUncheckedUpdateWithoutSkuInput>
  }

  export type SizeCurveRecommendationUpdateManyWithWhereWithoutSkuInput = {
    where: SizeCurveRecommendationScalarWhereInput
    data: XOR<SizeCurveRecommendationUpdateManyMutationInput, SizeCurveRecommendationUncheckedUpdateManyWithoutSkuInput>
  }

  export type SkuPerformanceUpsertWithWhereUniqueWithoutSkuInput = {
    where: SkuPerformanceWhereUniqueInput
    update: XOR<SkuPerformanceUpdateWithoutSkuInput, SkuPerformanceUncheckedUpdateWithoutSkuInput>
    create: XOR<SkuPerformanceCreateWithoutSkuInput, SkuPerformanceUncheckedCreateWithoutSkuInput>
  }

  export type SkuPerformanceUpdateWithWhereUniqueWithoutSkuInput = {
    where: SkuPerformanceWhereUniqueInput
    data: XOR<SkuPerformanceUpdateWithoutSkuInput, SkuPerformanceUncheckedUpdateWithoutSkuInput>
  }

  export type SkuPerformanceUpdateManyWithWhereWithoutSkuInput = {
    where: SkuPerformanceScalarWhereInput
    data: XOR<SkuPerformanceUpdateManyMutationInput, SkuPerformanceUncheckedUpdateManyWithoutSkuInput>
  }

  export type SkuRecommendationUpsertWithWhereUniqueWithoutSkuInput = {
    where: SkuRecommendationWhereUniqueInput
    update: XOR<SkuRecommendationUpdateWithoutSkuInput, SkuRecommendationUncheckedUpdateWithoutSkuInput>
    create: XOR<SkuRecommendationCreateWithoutSkuInput, SkuRecommendationUncheckedCreateWithoutSkuInput>
  }

  export type SkuRecommendationUpdateWithWhereUniqueWithoutSkuInput = {
    where: SkuRecommendationWhereUniqueInput
    data: XOR<SkuRecommendationUpdateWithoutSkuInput, SkuRecommendationUncheckedUpdateWithoutSkuInput>
  }

  export type SkuRecommendationUpdateManyWithWhereWithoutSkuInput = {
    where: SkuRecommendationScalarWhereInput
    data: XOR<SkuRecommendationUpdateManyMutationInput, SkuRecommendationUncheckedUpdateManyWithoutSkuInput>
  }

  export type SkuRecommendationScalarWhereInput = {
    AND?: SkuRecommendationScalarWhereInput | SkuRecommendationScalarWhereInput[]
    OR?: SkuRecommendationScalarWhereInput[]
    NOT?: SkuRecommendationScalarWhereInput | SkuRecommendationScalarWhereInput[]
    id?: StringFilter<"SkuRecommendation"> | string
    budgetDetailId?: StringFilter<"SkuRecommendation"> | string
    category?: StringFilter<"SkuRecommendation"> | string
    subCategory?: StringNullableFilter<"SkuRecommendation"> | string | null
    skuId?: StringFilter<"SkuRecommendation"> | string
    skuCode?: StringFilter<"SkuRecommendation"> | string
    productName?: StringFilter<"SkuRecommendation"> | string
    recommendedQty?: IntFilter<"SkuRecommendation"> | number
    recommendedValue?: DecimalFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"SkuRecommendation"> | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFilter<"SkuRecommendation"> | number
    trendScore?: IntFilter<"SkuRecommendation"> | number
    assortmentScore?: IntFilter<"SkuRecommendation"> | number
    priceScore?: IntFilter<"SkuRecommendation"> | number
    overallScore?: IntFilter<"SkuRecommendation"> | number
    riskLevel?: StringFilter<"SkuRecommendation"> | string
    reasoning?: StringNullableFilter<"SkuRecommendation"> | string | null
    isSelected?: BoolFilter<"SkuRecommendation"> | boolean
    isRejected?: BoolFilter<"SkuRecommendation"> | boolean
    createdAt?: DateTimeFilter<"SkuRecommendation"> | Date | string
  }

  export type GroupBrandCreateWithoutBudgetsInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    skuCatalog?: SkuCatalogCreateNestedManyWithoutBrandInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandUncheckedCreateWithoutBudgetsInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    skuCatalog?: SkuCatalogUncheckedCreateNestedManyWithoutBrandInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandCreateOrConnectWithoutBudgetsInput = {
    where: GroupBrandWhereUniqueInput
    create: XOR<GroupBrandCreateWithoutBudgetsInput, GroupBrandUncheckedCreateWithoutBudgetsInput>
  }

  export type UserCreateWithoutCreatedBudgetsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedBudgetsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedBudgetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBudgetsInput, UserUncheckedCreateWithoutCreatedBudgetsInput>
  }

  export type BudgetDetailCreateWithoutBudgetInput = {
    id?: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    store: StoreCreateNestedOneWithoutBudgetDetailsInput
    planningVersions?: PlanningVersionCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUncheckedCreateWithoutBudgetInput = {
    id?: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailCreateOrConnectWithoutBudgetInput = {
    where: BudgetDetailWhereUniqueInput
    create: XOR<BudgetDetailCreateWithoutBudgetInput, BudgetDetailUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetDetailCreateManyBudgetInputEnvelope = {
    data: BudgetDetailCreateManyBudgetInput | BudgetDetailCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutBudgetInput = {
    id?: string
    ticketName: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    planningVersion?: PlanningVersionCreateNestedOneWithoutProposalsInput
    createdBy: UserCreateNestedOneWithoutCreatedProposalsInput
    products?: ProposalProductCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutBudgetInput = {
    id?: string
    ticketName: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProposalProductUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutBudgetInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutBudgetInput, ProposalUncheckedCreateWithoutBudgetInput>
  }

  export type ProposalCreateManyBudgetInputEnvelope = {
    data: ProposalCreateManyBudgetInput | ProposalCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type BudgetAlertCreateWithoutBudgetInput = {
    id?: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    category?: string | null
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: Date | string
  }

  export type BudgetAlertUncheckedCreateWithoutBudgetInput = {
    id?: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    category?: string | null
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: Date | string
  }

  export type BudgetAlertCreateOrConnectWithoutBudgetInput = {
    where: BudgetAlertWhereUniqueInput
    create: XOR<BudgetAlertCreateWithoutBudgetInput, BudgetAlertUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetAlertCreateManyBudgetInputEnvelope = {
    data: BudgetAlertCreateManyBudgetInput | BudgetAlertCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type BudgetSnapshotCreateWithoutBudgetInput = {
    id?: string
    snapshotDate: Date | string
    totalCommitted?: Decimal | DecimalJsLike | number | string
    totalPlanned?: Decimal | DecimalJsLike | number | string
    utilizationPct?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotUncheckedCreateWithoutBudgetInput = {
    id?: string
    snapshotDate: Date | string
    totalCommitted?: Decimal | DecimalJsLike | number | string
    totalPlanned?: Decimal | DecimalJsLike | number | string
    utilizationPct?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotCreateOrConnectWithoutBudgetInput = {
    where: BudgetSnapshotWhereUniqueInput
    create: XOR<BudgetSnapshotCreateWithoutBudgetInput, BudgetSnapshotUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetSnapshotCreateManyBudgetInputEnvelope = {
    data: BudgetSnapshotCreateManyBudgetInput | BudgetSnapshotCreateManyBudgetInput[]
    skipDuplicates?: boolean
  }

  export type GroupBrandUpsertWithoutBudgetsInput = {
    update: XOR<GroupBrandUpdateWithoutBudgetsInput, GroupBrandUncheckedUpdateWithoutBudgetsInput>
    create: XOR<GroupBrandCreateWithoutBudgetsInput, GroupBrandUncheckedCreateWithoutBudgetsInput>
    where?: GroupBrandWhereInput
  }

  export type GroupBrandUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: GroupBrandWhereInput
    data: XOR<GroupBrandUpdateWithoutBudgetsInput, GroupBrandUncheckedUpdateWithoutBudgetsInput>
  }

  export type GroupBrandUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    skuCatalog?: SkuCatalogUpdateManyWithoutBrandNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutBrandNestedInput
  }

  export type GroupBrandUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    skuCatalog?: SkuCatalogUncheckedUpdateManyWithoutBrandNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type UserUpsertWithoutCreatedBudgetsInput = {
    update: XOR<UserUpdateWithoutCreatedBudgetsInput, UserUncheckedUpdateWithoutCreatedBudgetsInput>
    create: XOR<UserCreateWithoutCreatedBudgetsInput, UserUncheckedCreateWithoutCreatedBudgetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBudgetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBudgetsInput, UserUncheckedUpdateWithoutCreatedBudgetsInput>
  }

  export type UserUpdateWithoutCreatedBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BudgetDetailUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetDetailWhereUniqueInput
    update: XOR<BudgetDetailUpdateWithoutBudgetInput, BudgetDetailUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetDetailCreateWithoutBudgetInput, BudgetDetailUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetDetailUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetDetailWhereUniqueInput
    data: XOR<BudgetDetailUpdateWithoutBudgetInput, BudgetDetailUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetDetailUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetDetailScalarWhereInput
    data: XOR<BudgetDetailUpdateManyMutationInput, BudgetDetailUncheckedUpdateManyWithoutBudgetInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutBudgetInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutBudgetInput, ProposalUncheckedUpdateWithoutBudgetInput>
    create: XOR<ProposalCreateWithoutBudgetInput, ProposalUncheckedCreateWithoutBudgetInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutBudgetInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutBudgetInput, ProposalUncheckedUpdateWithoutBudgetInput>
  }

  export type ProposalUpdateManyWithWhereWithoutBudgetInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetAlertUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetAlertWhereUniqueInput
    update: XOR<BudgetAlertUpdateWithoutBudgetInput, BudgetAlertUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetAlertCreateWithoutBudgetInput, BudgetAlertUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetAlertUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetAlertWhereUniqueInput
    data: XOR<BudgetAlertUpdateWithoutBudgetInput, BudgetAlertUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetAlertUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetAlertScalarWhereInput
    data: XOR<BudgetAlertUpdateManyMutationInput, BudgetAlertUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetAlertScalarWhereInput = {
    AND?: BudgetAlertScalarWhereInput | BudgetAlertScalarWhereInput[]
    OR?: BudgetAlertScalarWhereInput[]
    NOT?: BudgetAlertScalarWhereInput | BudgetAlertScalarWhereInput[]
    id?: StringFilter<"BudgetAlert"> | string
    budgetId?: StringFilter<"BudgetAlert"> | string
    alertType?: StringFilter<"BudgetAlert"> | string
    severity?: StringFilter<"BudgetAlert"> | string
    title?: StringFilter<"BudgetAlert"> | string
    message?: StringFilter<"BudgetAlert"> | string
    metricValue?: DecimalFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFilter<"BudgetAlert"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableFilter<"BudgetAlert"> | string | null
    isRead?: BoolFilter<"BudgetAlert"> | boolean
    isDismissed?: BoolFilter<"BudgetAlert"> | boolean
    createdAt?: DateTimeFilter<"BudgetAlert"> | Date | string
  }

  export type BudgetSnapshotUpsertWithWhereUniqueWithoutBudgetInput = {
    where: BudgetSnapshotWhereUniqueInput
    update: XOR<BudgetSnapshotUpdateWithoutBudgetInput, BudgetSnapshotUncheckedUpdateWithoutBudgetInput>
    create: XOR<BudgetSnapshotCreateWithoutBudgetInput, BudgetSnapshotUncheckedCreateWithoutBudgetInput>
  }

  export type BudgetSnapshotUpdateWithWhereUniqueWithoutBudgetInput = {
    where: BudgetSnapshotWhereUniqueInput
    data: XOR<BudgetSnapshotUpdateWithoutBudgetInput, BudgetSnapshotUncheckedUpdateWithoutBudgetInput>
  }

  export type BudgetSnapshotUpdateManyWithWhereWithoutBudgetInput = {
    where: BudgetSnapshotScalarWhereInput
    data: XOR<BudgetSnapshotUpdateManyMutationInput, BudgetSnapshotUncheckedUpdateManyWithoutBudgetInput>
  }

  export type BudgetSnapshotScalarWhereInput = {
    AND?: BudgetSnapshotScalarWhereInput | BudgetSnapshotScalarWhereInput[]
    OR?: BudgetSnapshotScalarWhereInput[]
    NOT?: BudgetSnapshotScalarWhereInput | BudgetSnapshotScalarWhereInput[]
    id?: StringFilter<"BudgetSnapshot"> | string
    budgetId?: StringFilter<"BudgetSnapshot"> | string
    snapshotDate?: DateTimeFilter<"BudgetSnapshot"> | Date | string
    totalCommitted?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFilter<"BudgetSnapshot"> | Decimal | DecimalJsLike | number | string
  }

  export type BudgetCreateWithoutDetailsInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupBrand: GroupBrandCreateNestedOneWithoutBudgetsInput
    createdBy: UserCreateNestedOneWithoutCreatedBudgetsInput
    proposals?: ProposalCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutDetailsInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposals?: ProposalUncheckedCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutDetailsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutDetailsInput, BudgetUncheckedCreateWithoutDetailsInput>
  }

  export type StoreCreateWithoutBudgetDetailsInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    productAllocations?: ProductAllocationCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutBudgetDetailsInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    productAllocations?: ProductAllocationUncheckedCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryUncheckedCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutBudgetDetailsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutBudgetDetailsInput, StoreUncheckedCreateWithoutBudgetDetailsInput>
  }

  export type PlanningVersionCreateWithoutBudgetDetailInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedPlanningsInput
    details?: PlanningDetailCreateNestedManyWithoutPlanningVersionInput
    proposals?: ProposalCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionUncheckedCreateWithoutBudgetDetailInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: PlanningDetailUncheckedCreateNestedManyWithoutPlanningVersionInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionCreateOrConnectWithoutBudgetDetailInput = {
    where: PlanningVersionWhereUniqueInput
    create: XOR<PlanningVersionCreateWithoutBudgetDetailInput, PlanningVersionUncheckedCreateWithoutBudgetDetailInput>
  }

  export type PlanningVersionCreateManyBudgetDetailInputEnvelope = {
    data: PlanningVersionCreateManyBudgetDetailInput | PlanningVersionCreateManyBudgetDetailInput[]
    skipDuplicates?: boolean
  }

  export type AllocationRecommendationCreateWithoutBudgetDetailInput = {
    id?: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    recommendedAmt: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    reasoning?: string | null
    basedOnSeasons: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: boolean
    createdAt?: Date | string
  }

  export type AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput = {
    id?: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    recommendedAmt: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    reasoning?: string | null
    basedOnSeasons: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: boolean
    createdAt?: Date | string
  }

  export type AllocationRecommendationCreateOrConnectWithoutBudgetDetailInput = {
    where: AllocationRecommendationWhereUniqueInput
    create: XOR<AllocationRecommendationCreateWithoutBudgetDetailInput, AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput>
  }

  export type AllocationRecommendationCreateManyBudgetDetailInputEnvelope = {
    data: AllocationRecommendationCreateManyBudgetDetailInput | AllocationRecommendationCreateManyBudgetDetailInput[]
    skipDuplicates?: boolean
  }

  export type SkuRecommendationCreateWithoutBudgetDetailInput = {
    id?: string
    category: string
    subCategory?: string | null
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
    sku: SkuCatalogCreateNestedOneWithoutSkuRecommendationsInput
  }

  export type SkuRecommendationUncheckedCreateWithoutBudgetDetailInput = {
    id?: string
    category: string
    subCategory?: string | null
    skuId: string
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
  }

  export type SkuRecommendationCreateOrConnectWithoutBudgetDetailInput = {
    where: SkuRecommendationWhereUniqueInput
    create: XOR<SkuRecommendationCreateWithoutBudgetDetailInput, SkuRecommendationUncheckedCreateWithoutBudgetDetailInput>
  }

  export type SkuRecommendationCreateManyBudgetDetailInputEnvelope = {
    data: SkuRecommendationCreateManyBudgetDetailInput | SkuRecommendationCreateManyBudgetDetailInput[]
    skipDuplicates?: boolean
  }

  export type BudgetUpsertWithoutDetailsInput = {
    update: XOR<BudgetUpdateWithoutDetailsInput, BudgetUncheckedUpdateWithoutDetailsInput>
    create: XOR<BudgetCreateWithoutDetailsInput, BudgetUncheckedCreateWithoutDetailsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutDetailsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutDetailsInput, BudgetUncheckedUpdateWithoutDetailsInput>
  }

  export type BudgetUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupBrand?: GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput
    proposals?: ProposalUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUncheckedUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type StoreUpsertWithoutBudgetDetailsInput = {
    update: XOR<StoreUpdateWithoutBudgetDetailsInput, StoreUncheckedUpdateWithoutBudgetDetailsInput>
    create: XOR<StoreCreateWithoutBudgetDetailsInput, StoreUncheckedCreateWithoutBudgetDetailsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutBudgetDetailsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutBudgetDetailsInput, StoreUncheckedUpdateWithoutBudgetDetailsInput>
  }

  export type StoreUpdateWithoutBudgetDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    productAllocations?: ProductAllocationUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutBudgetDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    productAllocations?: ProductAllocationUncheckedUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUncheckedUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type PlanningVersionUpsertWithWhereUniqueWithoutBudgetDetailInput = {
    where: PlanningVersionWhereUniqueInput
    update: XOR<PlanningVersionUpdateWithoutBudgetDetailInput, PlanningVersionUncheckedUpdateWithoutBudgetDetailInput>
    create: XOR<PlanningVersionCreateWithoutBudgetDetailInput, PlanningVersionUncheckedCreateWithoutBudgetDetailInput>
  }

  export type PlanningVersionUpdateWithWhereUniqueWithoutBudgetDetailInput = {
    where: PlanningVersionWhereUniqueInput
    data: XOR<PlanningVersionUpdateWithoutBudgetDetailInput, PlanningVersionUncheckedUpdateWithoutBudgetDetailInput>
  }

  export type PlanningVersionUpdateManyWithWhereWithoutBudgetDetailInput = {
    where: PlanningVersionScalarWhereInput
    data: XOR<PlanningVersionUpdateManyMutationInput, PlanningVersionUncheckedUpdateManyWithoutBudgetDetailInput>
  }

  export type AllocationRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput = {
    where: AllocationRecommendationWhereUniqueInput
    update: XOR<AllocationRecommendationUpdateWithoutBudgetDetailInput, AllocationRecommendationUncheckedUpdateWithoutBudgetDetailInput>
    create: XOR<AllocationRecommendationCreateWithoutBudgetDetailInput, AllocationRecommendationUncheckedCreateWithoutBudgetDetailInput>
  }

  export type AllocationRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput = {
    where: AllocationRecommendationWhereUniqueInput
    data: XOR<AllocationRecommendationUpdateWithoutBudgetDetailInput, AllocationRecommendationUncheckedUpdateWithoutBudgetDetailInput>
  }

  export type AllocationRecommendationUpdateManyWithWhereWithoutBudgetDetailInput = {
    where: AllocationRecommendationScalarWhereInput
    data: XOR<AllocationRecommendationUpdateManyMutationInput, AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailInput>
  }

  export type AllocationRecommendationScalarWhereInput = {
    AND?: AllocationRecommendationScalarWhereInput | AllocationRecommendationScalarWhereInput[]
    OR?: AllocationRecommendationScalarWhereInput[]
    NOT?: AllocationRecommendationScalarWhereInput | AllocationRecommendationScalarWhereInput[]
    id?: StringFilter<"AllocationRecommendation"> | string
    budgetDetailId?: StringFilter<"AllocationRecommendation"> | string
    dimensionType?: StringFilter<"AllocationRecommendation"> | string
    dimensionValue?: StringFilter<"AllocationRecommendation"> | string
    recommendedPct?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFilter<"AllocationRecommendation"> | Decimal | DecimalJsLike | number | string
    reasoning?: StringNullableFilter<"AllocationRecommendation"> | string | null
    basedOnSeasons?: IntFilter<"AllocationRecommendation"> | number
    factors?: JsonNullableFilter<"AllocationRecommendation">
    isApplied?: BoolFilter<"AllocationRecommendation"> | boolean
    createdAt?: DateTimeFilter<"AllocationRecommendation"> | Date | string
  }

  export type SkuRecommendationUpsertWithWhereUniqueWithoutBudgetDetailInput = {
    where: SkuRecommendationWhereUniqueInput
    update: XOR<SkuRecommendationUpdateWithoutBudgetDetailInput, SkuRecommendationUncheckedUpdateWithoutBudgetDetailInput>
    create: XOR<SkuRecommendationCreateWithoutBudgetDetailInput, SkuRecommendationUncheckedCreateWithoutBudgetDetailInput>
  }

  export type SkuRecommendationUpdateWithWhereUniqueWithoutBudgetDetailInput = {
    where: SkuRecommendationWhereUniqueInput
    data: XOR<SkuRecommendationUpdateWithoutBudgetDetailInput, SkuRecommendationUncheckedUpdateWithoutBudgetDetailInput>
  }

  export type SkuRecommendationUpdateManyWithWhereWithoutBudgetDetailInput = {
    where: SkuRecommendationScalarWhereInput
    data: XOR<SkuRecommendationUpdateManyMutationInput, SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailInput>
  }

  export type BudgetDetailCreateWithoutPlanningVersionsInput = {
    id?: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    budget: BudgetCreateNestedOneWithoutDetailsInput
    store: StoreCreateNestedOneWithoutBudgetDetailsInput
    allocationRecommendations?: AllocationRecommendationCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUncheckedCreateWithoutPlanningVersionsInput = {
    id?: string
    budgetId: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    allocationRecommendations?: AllocationRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailCreateOrConnectWithoutPlanningVersionsInput = {
    where: BudgetDetailWhereUniqueInput
    create: XOR<BudgetDetailCreateWithoutPlanningVersionsInput, BudgetDetailUncheckedCreateWithoutPlanningVersionsInput>
  }

  export type UserCreateWithoutCreatedPlanningsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedPlanningsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedPlanningsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPlanningsInput, UserUncheckedCreateWithoutCreatedPlanningsInput>
  }

  export type PlanningDetailCreateWithoutPlanningVersionInput = {
    id?: string
    dimensionType: string
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
    collection?: CollectionCreateNestedOneWithoutPlanningDetailsInput
    gender?: GenderCreateNestedOneWithoutPlanningDetailsInput
    category?: CategoryCreateNestedOneWithoutPlanningDetailsInput
    subCategory?: SubCategoryCreateNestedOneWithoutPlanningDetailsInput
  }

  export type PlanningDetailUncheckedCreateWithoutPlanningVersionInput = {
    id?: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailCreateOrConnectWithoutPlanningVersionInput = {
    where: PlanningDetailWhereUniqueInput
    create: XOR<PlanningDetailCreateWithoutPlanningVersionInput, PlanningDetailUncheckedCreateWithoutPlanningVersionInput>
  }

  export type PlanningDetailCreateManyPlanningVersionInputEnvelope = {
    data: PlanningDetailCreateManyPlanningVersionInput | PlanningDetailCreateManyPlanningVersionInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutPlanningVersionInput = {
    id?: string
    ticketName: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutProposalsInput
    createdBy: UserCreateNestedOneWithoutCreatedProposalsInput
    products?: ProposalProductCreateNestedManyWithoutProposalInput
  }

  export type ProposalUncheckedCreateWithoutPlanningVersionInput = {
    id?: string
    ticketName: string
    budgetId: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProposalProductUncheckedCreateNestedManyWithoutProposalInput
  }

  export type ProposalCreateOrConnectWithoutPlanningVersionInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutPlanningVersionInput, ProposalUncheckedCreateWithoutPlanningVersionInput>
  }

  export type ProposalCreateManyPlanningVersionInputEnvelope = {
    data: ProposalCreateManyPlanningVersionInput | ProposalCreateManyPlanningVersionInput[]
    skipDuplicates?: boolean
  }

  export type BudgetDetailUpsertWithoutPlanningVersionsInput = {
    update: XOR<BudgetDetailUpdateWithoutPlanningVersionsInput, BudgetDetailUncheckedUpdateWithoutPlanningVersionsInput>
    create: XOR<BudgetDetailCreateWithoutPlanningVersionsInput, BudgetDetailUncheckedCreateWithoutPlanningVersionsInput>
    where?: BudgetDetailWhereInput
  }

  export type BudgetDetailUpdateToOneWithWhereWithoutPlanningVersionsInput = {
    where?: BudgetDetailWhereInput
    data: XOR<BudgetDetailUpdateWithoutPlanningVersionsInput, BudgetDetailUncheckedUpdateWithoutPlanningVersionsInput>
  }

  export type BudgetDetailUpdateWithoutPlanningVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    budget?: BudgetUpdateOneRequiredWithoutDetailsNestedInput
    store?: StoreUpdateOneRequiredWithoutBudgetDetailsNestedInput
    allocationRecommendations?: AllocationRecommendationUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateWithoutPlanningVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    allocationRecommendations?: AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
  }

  export type UserUpsertWithoutCreatedPlanningsInput = {
    update: XOR<UserUpdateWithoutCreatedPlanningsInput, UserUncheckedUpdateWithoutCreatedPlanningsInput>
    create: XOR<UserCreateWithoutCreatedPlanningsInput, UserUncheckedCreateWithoutCreatedPlanningsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPlanningsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPlanningsInput, UserUncheckedUpdateWithoutCreatedPlanningsInput>
  }

  export type UserUpdateWithoutCreatedPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlanningDetailUpsertWithWhereUniqueWithoutPlanningVersionInput = {
    where: PlanningDetailWhereUniqueInput
    update: XOR<PlanningDetailUpdateWithoutPlanningVersionInput, PlanningDetailUncheckedUpdateWithoutPlanningVersionInput>
    create: XOR<PlanningDetailCreateWithoutPlanningVersionInput, PlanningDetailUncheckedCreateWithoutPlanningVersionInput>
  }

  export type PlanningDetailUpdateWithWhereUniqueWithoutPlanningVersionInput = {
    where: PlanningDetailWhereUniqueInput
    data: XOR<PlanningDetailUpdateWithoutPlanningVersionInput, PlanningDetailUncheckedUpdateWithoutPlanningVersionInput>
  }

  export type PlanningDetailUpdateManyWithWhereWithoutPlanningVersionInput = {
    where: PlanningDetailScalarWhereInput
    data: XOR<PlanningDetailUpdateManyMutationInput, PlanningDetailUncheckedUpdateManyWithoutPlanningVersionInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutPlanningVersionInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutPlanningVersionInput, ProposalUncheckedUpdateWithoutPlanningVersionInput>
    create: XOR<ProposalCreateWithoutPlanningVersionInput, ProposalUncheckedCreateWithoutPlanningVersionInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutPlanningVersionInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutPlanningVersionInput, ProposalUncheckedUpdateWithoutPlanningVersionInput>
  }

  export type ProposalUpdateManyWithWhereWithoutPlanningVersionInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutPlanningVersionInput>
  }

  export type PlanningVersionCreateWithoutDetailsInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutPlanningVersionsInput
    createdBy: UserCreateNestedOneWithoutCreatedPlanningsInput
    proposals?: ProposalCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionUncheckedCreateWithoutDetailsInput = {
    id?: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    proposals?: ProposalUncheckedCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionCreateOrConnectWithoutDetailsInput = {
    where: PlanningVersionWhereUniqueInput
    create: XOR<PlanningVersionCreateWithoutDetailsInput, PlanningVersionUncheckedCreateWithoutDetailsInput>
  }

  export type CollectionCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type CollectionUncheckedCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type CollectionCreateOrConnectWithoutPlanningDetailsInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutPlanningDetailsInput, CollectionUncheckedCreateWithoutPlanningDetailsInput>
  }

  export type GenderCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    isActive?: boolean
    categories?: CategoryCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    isActive?: boolean
    categories?: CategoryUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderCreateOrConnectWithoutPlanningDetailsInput = {
    where: GenderWhereUniqueInput
    create: XOR<GenderCreateWithoutPlanningDetailsInput, GenderUncheckedCreateWithoutPlanningDetailsInput>
  }

  export type CategoryCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    isActive?: boolean
    gender: GenderCreateNestedOneWithoutCategoriesInput
    subCategories?: SubCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    genderId: string
    isActive?: boolean
    subCategories?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPlanningDetailsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPlanningDetailsInput, CategoryUncheckedCreateWithoutPlanningDetailsInput>
  }

  export type SubCategoryCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    isActive?: boolean
    category: CategoryCreateNestedOneWithoutSubCategoriesInput
  }

  export type SubCategoryUncheckedCreateWithoutPlanningDetailsInput = {
    id?: string
    name: string
    categoryId: string
    isActive?: boolean
  }

  export type SubCategoryCreateOrConnectWithoutPlanningDetailsInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutPlanningDetailsInput, SubCategoryUncheckedCreateWithoutPlanningDetailsInput>
  }

  export type PlanningVersionUpsertWithoutDetailsInput = {
    update: XOR<PlanningVersionUpdateWithoutDetailsInput, PlanningVersionUncheckedUpdateWithoutDetailsInput>
    create: XOR<PlanningVersionCreateWithoutDetailsInput, PlanningVersionUncheckedCreateWithoutDetailsInput>
    where?: PlanningVersionWhereInput
  }

  export type PlanningVersionUpdateToOneWithWhereWithoutDetailsInput = {
    where?: PlanningVersionWhereInput
    data: XOR<PlanningVersionUpdateWithoutDetailsInput, PlanningVersionUncheckedUpdateWithoutDetailsInput>
  }

  export type PlanningVersionUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutPlanningVersionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPlanningsNestedInput
    proposals?: ProposalUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateWithoutDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proposals?: ProposalUncheckedUpdateManyWithoutPlanningVersionNestedInput
  }

  export type CollectionUpsertWithoutPlanningDetailsInput = {
    update: XOR<CollectionUpdateWithoutPlanningDetailsInput, CollectionUncheckedUpdateWithoutPlanningDetailsInput>
    create: XOR<CollectionCreateWithoutPlanningDetailsInput, CollectionUncheckedCreateWithoutPlanningDetailsInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutPlanningDetailsInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutPlanningDetailsInput, CollectionUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type CollectionUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CollectionUncheckedUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GenderUpsertWithoutPlanningDetailsInput = {
    update: XOR<GenderUpdateWithoutPlanningDetailsInput, GenderUncheckedUpdateWithoutPlanningDetailsInput>
    create: XOR<GenderCreateWithoutPlanningDetailsInput, GenderUncheckedCreateWithoutPlanningDetailsInput>
    where?: GenderWhereInput
  }

  export type GenderUpdateToOneWithWhereWithoutPlanningDetailsInput = {
    where?: GenderWhereInput
    data: XOR<GenderUpdateWithoutPlanningDetailsInput, GenderUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type GenderUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categories?: CategoryUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categories?: CategoryUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type CategoryUpsertWithoutPlanningDetailsInput = {
    update: XOR<CategoryUpdateWithoutPlanningDetailsInput, CategoryUncheckedUpdateWithoutPlanningDetailsInput>
    create: XOR<CategoryCreateWithoutPlanningDetailsInput, CategoryUncheckedCreateWithoutPlanningDetailsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPlanningDetailsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPlanningDetailsInput, CategoryUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type CategoryUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    gender?: GenderUpdateOneRequiredWithoutCategoriesNestedInput
    subCategories?: SubCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genderId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategories?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SubCategoryUpsertWithoutPlanningDetailsInput = {
    update: XOR<SubCategoryUpdateWithoutPlanningDetailsInput, SubCategoryUncheckedUpdateWithoutPlanningDetailsInput>
    create: XOR<SubCategoryCreateWithoutPlanningDetailsInput, SubCategoryUncheckedCreateWithoutPlanningDetailsInput>
    where?: SubCategoryWhereInput
  }

  export type SubCategoryUpdateToOneWithWhereWithoutPlanningDetailsInput = {
    where?: SubCategoryWhereInput
    data: XOR<SubCategoryUpdateWithoutPlanningDetailsInput, SubCategoryUncheckedUpdateWithoutPlanningDetailsInput>
  }

  export type SubCategoryUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutSubCategoriesNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutPlanningDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BudgetCreateWithoutProposalsInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupBrand: GroupBrandCreateNestedOneWithoutBudgetsInput
    createdBy: UserCreateNestedOneWithoutCreatedBudgetsInput
    details?: BudgetDetailCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutProposalsInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutProposalsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutProposalsInput, BudgetUncheckedCreateWithoutProposalsInput>
  }

  export type PlanningVersionCreateWithoutProposalsInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    budgetDetail: BudgetDetailCreateNestedOneWithoutPlanningVersionsInput
    createdBy: UserCreateNestedOneWithoutCreatedPlanningsInput
    details?: PlanningDetailCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionUncheckedCreateWithoutProposalsInput = {
    id?: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: PlanningDetailUncheckedCreateNestedManyWithoutPlanningVersionInput
  }

  export type PlanningVersionCreateOrConnectWithoutProposalsInput = {
    where: PlanningVersionWhereUniqueInput
    create: XOR<PlanningVersionCreateWithoutProposalsInput, PlanningVersionUncheckedCreateWithoutProposalsInput>
  }

  export type UserCreateWithoutCreatedProposalsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedProposalsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedProposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedProposalsInput, UserUncheckedCreateWithoutCreatedProposalsInput>
  }

  export type ProposalProductCreateWithoutProposalInput = {
    id?: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    sku: SkuCatalogCreateNestedOneWithoutProductsInput
    allocations?: ProductAllocationCreateNestedManyWithoutProposalProductInput
  }

  export type ProposalProductUncheckedCreateWithoutProposalInput = {
    id?: string
    skuId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    allocations?: ProductAllocationUncheckedCreateNestedManyWithoutProposalProductInput
  }

  export type ProposalProductCreateOrConnectWithoutProposalInput = {
    where: ProposalProductWhereUniqueInput
    create: XOR<ProposalProductCreateWithoutProposalInput, ProposalProductUncheckedCreateWithoutProposalInput>
  }

  export type ProposalProductCreateManyProposalInputEnvelope = {
    data: ProposalProductCreateManyProposalInput | ProposalProductCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type BudgetUpsertWithoutProposalsInput = {
    update: XOR<BudgetUpdateWithoutProposalsInput, BudgetUncheckedUpdateWithoutProposalsInput>
    create: XOR<BudgetCreateWithoutProposalsInput, BudgetUncheckedCreateWithoutProposalsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutProposalsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutProposalsInput, BudgetUncheckedUpdateWithoutProposalsInput>
  }

  export type BudgetUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupBrand?: GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput
    details?: BudgetDetailUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type PlanningVersionUpsertWithoutProposalsInput = {
    update: XOR<PlanningVersionUpdateWithoutProposalsInput, PlanningVersionUncheckedUpdateWithoutProposalsInput>
    create: XOR<PlanningVersionCreateWithoutProposalsInput, PlanningVersionUncheckedCreateWithoutProposalsInput>
    where?: PlanningVersionWhereInput
  }

  export type PlanningVersionUpdateToOneWithWhereWithoutProposalsInput = {
    where?: PlanningVersionWhereInput
    data: XOR<PlanningVersionUpdateWithoutProposalsInput, PlanningVersionUncheckedUpdateWithoutProposalsInput>
  }

  export type PlanningVersionUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutPlanningVersionsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPlanningsNestedInput
    details?: PlanningDetailUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: PlanningDetailUncheckedUpdateManyWithoutPlanningVersionNestedInput
  }

  export type UserUpsertWithoutCreatedProposalsInput = {
    update: XOR<UserUpdateWithoutCreatedProposalsInput, UserUncheckedUpdateWithoutCreatedProposalsInput>
    create: XOR<UserCreateWithoutCreatedProposalsInput, UserUncheckedCreateWithoutCreatedProposalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedProposalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedProposalsInput, UserUncheckedUpdateWithoutCreatedProposalsInput>
  }

  export type UserUpdateWithoutCreatedProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProposalProductUpsertWithWhereUniqueWithoutProposalInput = {
    where: ProposalProductWhereUniqueInput
    update: XOR<ProposalProductUpdateWithoutProposalInput, ProposalProductUncheckedUpdateWithoutProposalInput>
    create: XOR<ProposalProductCreateWithoutProposalInput, ProposalProductUncheckedCreateWithoutProposalInput>
  }

  export type ProposalProductUpdateWithWhereUniqueWithoutProposalInput = {
    where: ProposalProductWhereUniqueInput
    data: XOR<ProposalProductUpdateWithoutProposalInput, ProposalProductUncheckedUpdateWithoutProposalInput>
  }

  export type ProposalProductUpdateManyWithWhereWithoutProposalInput = {
    where: ProposalProductScalarWhereInput
    data: XOR<ProposalProductUpdateManyMutationInput, ProposalProductUncheckedUpdateManyWithoutProposalInput>
  }

  export type ProposalCreateWithoutProductsInput = {
    id?: string
    ticketName: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    budget: BudgetCreateNestedOneWithoutProposalsInput
    planningVersion?: PlanningVersionCreateNestedOneWithoutProposalsInput
    createdBy: UserCreateNestedOneWithoutCreatedProposalsInput
  }

  export type ProposalUncheckedCreateWithoutProductsInput = {
    id?: string
    ticketName: string
    budgetId: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateOrConnectWithoutProductsInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutProductsInput, ProposalUncheckedCreateWithoutProductsInput>
  }

  export type SkuCatalogCreateWithoutProductsInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    brand?: GroupBrandCreateNestedOneWithoutSkuCatalogInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUncheckedCreateWithoutProductsInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    brandId?: string | null
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogCreateOrConnectWithoutProductsInput = {
    where: SkuCatalogWhereUniqueInput
    create: XOR<SkuCatalogCreateWithoutProductsInput, SkuCatalogUncheckedCreateWithoutProductsInput>
  }

  export type ProductAllocationCreateWithoutProposalProductInput = {
    id?: string
    quantity?: number
    store: StoreCreateNestedOneWithoutProductAllocationsInput
  }

  export type ProductAllocationUncheckedCreateWithoutProposalProductInput = {
    id?: string
    storeId: string
    quantity?: number
  }

  export type ProductAllocationCreateOrConnectWithoutProposalProductInput = {
    where: ProductAllocationWhereUniqueInput
    create: XOR<ProductAllocationCreateWithoutProposalProductInput, ProductAllocationUncheckedCreateWithoutProposalProductInput>
  }

  export type ProductAllocationCreateManyProposalProductInputEnvelope = {
    data: ProductAllocationCreateManyProposalProductInput | ProductAllocationCreateManyProposalProductInput[]
    skipDuplicates?: boolean
  }

  export type ProposalUpsertWithoutProductsInput = {
    update: XOR<ProposalUpdateWithoutProductsInput, ProposalUncheckedUpdateWithoutProductsInput>
    create: XOR<ProposalCreateWithoutProductsInput, ProposalUncheckedCreateWithoutProductsInput>
    where?: ProposalWhereInput
  }

  export type ProposalUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProposalWhereInput
    data: XOR<ProposalUpdateWithoutProductsInput, ProposalUncheckedUpdateWithoutProductsInput>
  }

  export type ProposalUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutProposalsNestedInput
    planningVersion?: PlanningVersionUpdateOneWithoutProposalsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProposalsNestedInput
  }

  export type ProposalUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuCatalogUpsertWithoutProductsInput = {
    update: XOR<SkuCatalogUpdateWithoutProductsInput, SkuCatalogUncheckedUpdateWithoutProductsInput>
    create: XOR<SkuCatalogCreateWithoutProductsInput, SkuCatalogUncheckedCreateWithoutProductsInput>
    where?: SkuCatalogWhereInput
  }

  export type SkuCatalogUpdateToOneWithWhereWithoutProductsInput = {
    where?: SkuCatalogWhereInput
    data: XOR<SkuCatalogUpdateWithoutProductsInput, SkuCatalogUncheckedUpdateWithoutProductsInput>
  }

  export type SkuCatalogUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    brand?: GroupBrandUpdateOneWithoutSkuCatalogNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type ProductAllocationUpsertWithWhereUniqueWithoutProposalProductInput = {
    where: ProductAllocationWhereUniqueInput
    update: XOR<ProductAllocationUpdateWithoutProposalProductInput, ProductAllocationUncheckedUpdateWithoutProposalProductInput>
    create: XOR<ProductAllocationCreateWithoutProposalProductInput, ProductAllocationUncheckedCreateWithoutProposalProductInput>
  }

  export type ProductAllocationUpdateWithWhereUniqueWithoutProposalProductInput = {
    where: ProductAllocationWhereUniqueInput
    data: XOR<ProductAllocationUpdateWithoutProposalProductInput, ProductAllocationUncheckedUpdateWithoutProposalProductInput>
  }

  export type ProductAllocationUpdateManyWithWhereWithoutProposalProductInput = {
    where: ProductAllocationScalarWhereInput
    data: XOR<ProductAllocationUpdateManyMutationInput, ProductAllocationUncheckedUpdateManyWithoutProposalProductInput>
  }

  export type ProposalProductCreateWithoutAllocationsInput = {
    id?: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
    proposal: ProposalCreateNestedOneWithoutProductsInput
    sku: SkuCatalogCreateNestedOneWithoutProductsInput
  }

  export type ProposalProductUncheckedCreateWithoutAllocationsInput = {
    id?: string
    proposalId: string
    skuId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
  }

  export type ProposalProductCreateOrConnectWithoutAllocationsInput = {
    where: ProposalProductWhereUniqueInput
    create: XOR<ProposalProductCreateWithoutAllocationsInput, ProposalProductUncheckedCreateWithoutAllocationsInput>
  }

  export type StoreCreateWithoutProductAllocationsInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutProductAllocationsInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailUncheckedCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryUncheckedCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutProductAllocationsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutProductAllocationsInput, StoreUncheckedCreateWithoutProductAllocationsInput>
  }

  export type ProposalProductUpsertWithoutAllocationsInput = {
    update: XOR<ProposalProductUpdateWithoutAllocationsInput, ProposalProductUncheckedUpdateWithoutAllocationsInput>
    create: XOR<ProposalProductCreateWithoutAllocationsInput, ProposalProductUncheckedCreateWithoutAllocationsInput>
    where?: ProposalProductWhereInput
  }

  export type ProposalProductUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: ProposalProductWhereInput
    data: XOR<ProposalProductUpdateWithoutAllocationsInput, ProposalProductUncheckedUpdateWithoutAllocationsInput>
  }

  export type ProposalProductUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    proposal?: ProposalUpdateOneRequiredWithoutProductsNestedInput
    sku?: SkuCatalogUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProposalProductUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type StoreUpsertWithoutProductAllocationsInput = {
    update: XOR<StoreUpdateWithoutProductAllocationsInput, StoreUncheckedUpdateWithoutProductAllocationsInput>
    create: XOR<StoreCreateWithoutProductAllocationsInput, StoreUncheckedCreateWithoutProductAllocationsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutProductAllocationsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutProductAllocationsInput, StoreUncheckedUpdateWithoutProductAllocationsInput>
  }

  export type StoreUpdateWithoutProductAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutProductAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUncheckedUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUncheckedUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type UserCreateWithoutApprovalDecisionsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovalDecisionsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovalDecisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalDecisionsInput, UserUncheckedCreateWithoutApprovalDecisionsInput>
  }

  export type UserUpsertWithoutApprovalDecisionsInput = {
    update: XOR<UserUpdateWithoutApprovalDecisionsInput, UserUncheckedUpdateWithoutApprovalDecisionsInput>
    create: XOR<UserCreateWithoutApprovalDecisionsInput, UserUncheckedCreateWithoutApprovalDecisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalDecisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalDecisionsInput, UserUncheckedUpdateWithoutApprovalDecisionsInput>
  }

  export type UserUpdateWithoutApprovalDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalDecisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    workflowSteps?: ApprovalWorkflowStepCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    workflowSteps?: ApprovalWorkflowStepUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StoreCreateWithoutSalesHistoryInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSalesHistoryInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailUncheckedCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationUncheckedCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSalesHistoryInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSalesHistoryInput, StoreUncheckedCreateWithoutSalesHistoryInput>
  }

  export type StoreUpsertWithoutSalesHistoryInput = {
    update: XOR<StoreUpdateWithoutSalesHistoryInput, StoreUncheckedUpdateWithoutSalesHistoryInput>
    create: XOR<StoreCreateWithoutSalesHistoryInput, StoreUncheckedCreateWithoutSalesHistoryInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSalesHistoryInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSalesHistoryInput, StoreUncheckedUpdateWithoutSalesHistoryInput>
  }

  export type StoreUpdateWithoutSalesHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSalesHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUncheckedUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUncheckedUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type SkuCatalogCreateWithoutSizeCurveRecommendationsInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    brand?: GroupBrandCreateNestedOneWithoutSkuCatalogInput
    products?: ProposalProductCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUncheckedCreateWithoutSizeCurveRecommendationsInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    brandId?: string | null
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    products?: ProposalProductUncheckedCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogCreateOrConnectWithoutSizeCurveRecommendationsInput = {
    where: SkuCatalogWhereUniqueInput
    create: XOR<SkuCatalogCreateWithoutSizeCurveRecommendationsInput, SkuCatalogUncheckedCreateWithoutSizeCurveRecommendationsInput>
  }

  export type StoreCreateWithoutSizeCurveRecommendationsInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSizeCurveRecommendationsInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailUncheckedCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationUncheckedCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryUncheckedCreateNestedManyWithoutStoreInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSizeCurveRecommendationsInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSizeCurveRecommendationsInput, StoreUncheckedCreateWithoutSizeCurveRecommendationsInput>
  }

  export type SkuCatalogUpsertWithoutSizeCurveRecommendationsInput = {
    update: XOR<SkuCatalogUpdateWithoutSizeCurveRecommendationsInput, SkuCatalogUncheckedUpdateWithoutSizeCurveRecommendationsInput>
    create: XOR<SkuCatalogCreateWithoutSizeCurveRecommendationsInput, SkuCatalogUncheckedCreateWithoutSizeCurveRecommendationsInput>
    where?: SkuCatalogWhereInput
  }

  export type SkuCatalogUpdateToOneWithWhereWithoutSizeCurveRecommendationsInput = {
    where?: SkuCatalogWhereInput
    data: XOR<SkuCatalogUpdateWithoutSizeCurveRecommendationsInput, SkuCatalogUncheckedUpdateWithoutSizeCurveRecommendationsInput>
  }

  export type SkuCatalogUpdateWithoutSizeCurveRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    brand?: GroupBrandUpdateOneWithoutSkuCatalogNestedInput
    products?: ProposalProductUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateWithoutSizeCurveRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: ProposalProductUncheckedUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type StoreUpsertWithoutSizeCurveRecommendationsInput = {
    update: XOR<StoreUpdateWithoutSizeCurveRecommendationsInput, StoreUncheckedUpdateWithoutSizeCurveRecommendationsInput>
    create: XOR<StoreCreateWithoutSizeCurveRecommendationsInput, StoreUncheckedCreateWithoutSizeCurveRecommendationsInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSizeCurveRecommendationsInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSizeCurveRecommendationsInput, StoreUncheckedUpdateWithoutSizeCurveRecommendationsInput>
  }

  export type StoreUpdateWithoutSizeCurveRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSizeCurveRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUncheckedUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUncheckedUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUncheckedUpdateManyWithoutStoreNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type BudgetCreateWithoutBudgetAlertsInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupBrand: GroupBrandCreateNestedOneWithoutBudgetsInput
    createdBy: UserCreateNestedOneWithoutCreatedBudgetsInput
    details?: BudgetDetailCreateNestedManyWithoutBudgetInput
    proposals?: ProposalCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutBudgetAlertsInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutBudgetInput
    budgetSnapshots?: BudgetSnapshotUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutBudgetAlertsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutBudgetAlertsInput, BudgetUncheckedCreateWithoutBudgetAlertsInput>
  }

  export type BudgetUpsertWithoutBudgetAlertsInput = {
    update: XOR<BudgetUpdateWithoutBudgetAlertsInput, BudgetUncheckedUpdateWithoutBudgetAlertsInput>
    create: XOR<BudgetCreateWithoutBudgetAlertsInput, BudgetUncheckedCreateWithoutBudgetAlertsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutBudgetAlertsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutBudgetAlertsInput, BudgetUncheckedUpdateWithoutBudgetAlertsInput>
  }

  export type BudgetUpdateWithoutBudgetAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupBrand?: GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput
    details?: BudgetDetailUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutBudgetAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetCreateWithoutBudgetSnapshotsInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    groupBrand: GroupBrandCreateNestedOneWithoutBudgetsInput
    createdBy: UserCreateNestedOneWithoutCreatedBudgetsInput
    details?: BudgetDetailCreateNestedManyWithoutBudgetInput
    proposals?: ProposalCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertCreateNestedManyWithoutBudgetInput
  }

  export type BudgetUncheckedCreateWithoutBudgetSnapshotsInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: BudgetDetailUncheckedCreateNestedManyWithoutBudgetInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutBudgetInput
    budgetAlerts?: BudgetAlertUncheckedCreateNestedManyWithoutBudgetInput
  }

  export type BudgetCreateOrConnectWithoutBudgetSnapshotsInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutBudgetSnapshotsInput, BudgetUncheckedCreateWithoutBudgetSnapshotsInput>
  }

  export type BudgetUpsertWithoutBudgetSnapshotsInput = {
    update: XOR<BudgetUpdateWithoutBudgetSnapshotsInput, BudgetUncheckedUpdateWithoutBudgetSnapshotsInput>
    create: XOR<BudgetCreateWithoutBudgetSnapshotsInput, BudgetUncheckedCreateWithoutBudgetSnapshotsInput>
    where?: BudgetWhereInput
  }

  export type BudgetUpdateToOneWithWhereWithoutBudgetSnapshotsInput = {
    where?: BudgetWhereInput
    data: XOR<BudgetUpdateWithoutBudgetSnapshotsInput, BudgetUncheckedUpdateWithoutBudgetSnapshotsInput>
  }

  export type BudgetUpdateWithoutBudgetSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupBrand?: GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput
    details?: BudgetDetailUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutBudgetSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetDetailCreateWithoutAllocationRecommendationsInput = {
    id?: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    budget: BudgetCreateNestedOneWithoutDetailsInput
    store: StoreCreateNestedOneWithoutBudgetDetailsInput
    planningVersions?: PlanningVersionCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUncheckedCreateWithoutAllocationRecommendationsInput = {
    id?: string
    budgetId: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedCreateNestedManyWithoutBudgetDetailInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailCreateOrConnectWithoutAllocationRecommendationsInput = {
    where: BudgetDetailWhereUniqueInput
    create: XOR<BudgetDetailCreateWithoutAllocationRecommendationsInput, BudgetDetailUncheckedCreateWithoutAllocationRecommendationsInput>
  }

  export type BudgetDetailUpsertWithoutAllocationRecommendationsInput = {
    update: XOR<BudgetDetailUpdateWithoutAllocationRecommendationsInput, BudgetDetailUncheckedUpdateWithoutAllocationRecommendationsInput>
    create: XOR<BudgetDetailCreateWithoutAllocationRecommendationsInput, BudgetDetailUncheckedCreateWithoutAllocationRecommendationsInput>
    where?: BudgetDetailWhereInput
  }

  export type BudgetDetailUpdateToOneWithWhereWithoutAllocationRecommendationsInput = {
    where?: BudgetDetailWhereInput
    data: XOR<BudgetDetailUpdateWithoutAllocationRecommendationsInput, BudgetDetailUncheckedUpdateWithoutAllocationRecommendationsInput>
  }

  export type BudgetDetailUpdateWithoutAllocationRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    budget?: BudgetUpdateOneRequiredWithoutDetailsNestedInput
    store?: StoreUpdateOneRequiredWithoutBudgetDetailsNestedInput
    planningVersions?: PlanningVersionUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateWithoutAllocationRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
  }

  export type SkuCatalogCreateWithoutSkuPerformanceInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    brand?: GroupBrandCreateNestedOneWithoutSkuCatalogInput
    products?: ProposalProductCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUncheckedCreateWithoutSkuPerformanceInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    brandId?: string | null
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    products?: ProposalProductUncheckedCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutSkuInput
    skuRecommendations?: SkuRecommendationUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogCreateOrConnectWithoutSkuPerformanceInput = {
    where: SkuCatalogWhereUniqueInput
    create: XOR<SkuCatalogCreateWithoutSkuPerformanceInput, SkuCatalogUncheckedCreateWithoutSkuPerformanceInput>
  }

  export type StoreCreateWithoutSkuPerformanceInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutSkuPerformanceInput = {
    id?: string
    code: string
    name: string
    region?: string | null
    isActive?: boolean
    budgetDetails?: BudgetDetailUncheckedCreateNestedManyWithoutStoreInput
    productAllocations?: ProductAllocationUncheckedCreateNestedManyWithoutStoreInput
    salesHistory?: SalesHistoryUncheckedCreateNestedManyWithoutStoreInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutSkuPerformanceInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutSkuPerformanceInput, StoreUncheckedCreateWithoutSkuPerformanceInput>
  }

  export type SkuCatalogUpsertWithoutSkuPerformanceInput = {
    update: XOR<SkuCatalogUpdateWithoutSkuPerformanceInput, SkuCatalogUncheckedUpdateWithoutSkuPerformanceInput>
    create: XOR<SkuCatalogCreateWithoutSkuPerformanceInput, SkuCatalogUncheckedCreateWithoutSkuPerformanceInput>
    where?: SkuCatalogWhereInput
  }

  export type SkuCatalogUpdateToOneWithWhereWithoutSkuPerformanceInput = {
    where?: SkuCatalogWhereInput
    data: XOR<SkuCatalogUpdateWithoutSkuPerformanceInput, SkuCatalogUncheckedUpdateWithoutSkuPerformanceInput>
  }

  export type SkuCatalogUpdateWithoutSkuPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    brand?: GroupBrandUpdateOneWithoutSkuCatalogNestedInput
    products?: ProposalProductUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateWithoutSkuPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: ProposalProductUncheckedUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type StoreUpsertWithoutSkuPerformanceInput = {
    update: XOR<StoreUpdateWithoutSkuPerformanceInput, StoreUncheckedUpdateWithoutSkuPerformanceInput>
    create: XOR<StoreCreateWithoutSkuPerformanceInput, StoreUncheckedCreateWithoutSkuPerformanceInput>
    where?: StoreWhereInput
  }

  export type StoreUpdateToOneWithWhereWithoutSkuPerformanceInput = {
    where?: StoreWhereInput
    data: XOR<StoreUpdateWithoutSkuPerformanceInput, StoreUncheckedUpdateWithoutSkuPerformanceInput>
  }

  export type StoreUpdateWithoutSkuPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutSkuPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    budgetDetails?: BudgetDetailUncheckedUpdateManyWithoutStoreNestedInput
    productAllocations?: ProductAllocationUncheckedUpdateManyWithoutStoreNestedInput
    salesHistory?: SalesHistoryUncheckedUpdateManyWithoutStoreNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type BudgetDetailCreateWithoutSkuRecommendationsInput = {
    id?: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    budget: BudgetCreateNestedOneWithoutDetailsInput
    store: StoreCreateNestedOneWithoutBudgetDetailsInput
    planningVersions?: PlanningVersionCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailUncheckedCreateWithoutSkuRecommendationsInput = {
    id?: string
    budgetId: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedCreateNestedManyWithoutBudgetDetailInput
    allocationRecommendations?: AllocationRecommendationUncheckedCreateNestedManyWithoutBudgetDetailInput
  }

  export type BudgetDetailCreateOrConnectWithoutSkuRecommendationsInput = {
    where: BudgetDetailWhereUniqueInput
    create: XOR<BudgetDetailCreateWithoutSkuRecommendationsInput, BudgetDetailUncheckedCreateWithoutSkuRecommendationsInput>
  }

  export type SkuCatalogCreateWithoutSkuRecommendationsInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    brand?: GroupBrandCreateNestedOneWithoutSkuCatalogInput
    products?: ProposalProductCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogUncheckedCreateWithoutSkuRecommendationsInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    brandId?: string | null
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
    products?: ProposalProductUncheckedCreateNestedManyWithoutSkuInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedCreateNestedManyWithoutSkuInput
    skuPerformance?: SkuPerformanceUncheckedCreateNestedManyWithoutSkuInput
  }

  export type SkuCatalogCreateOrConnectWithoutSkuRecommendationsInput = {
    where: SkuCatalogWhereUniqueInput
    create: XOR<SkuCatalogCreateWithoutSkuRecommendationsInput, SkuCatalogUncheckedCreateWithoutSkuRecommendationsInput>
  }

  export type BudgetDetailUpsertWithoutSkuRecommendationsInput = {
    update: XOR<BudgetDetailUpdateWithoutSkuRecommendationsInput, BudgetDetailUncheckedUpdateWithoutSkuRecommendationsInput>
    create: XOR<BudgetDetailCreateWithoutSkuRecommendationsInput, BudgetDetailUncheckedCreateWithoutSkuRecommendationsInput>
    where?: BudgetDetailWhereInput
  }

  export type BudgetDetailUpdateToOneWithWhereWithoutSkuRecommendationsInput = {
    where?: BudgetDetailWhereInput
    data: XOR<BudgetDetailUpdateWithoutSkuRecommendationsInput, BudgetDetailUncheckedUpdateWithoutSkuRecommendationsInput>
  }

  export type BudgetDetailUpdateWithoutSkuRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    budget?: BudgetUpdateOneRequiredWithoutDetailsNestedInput
    store?: StoreUpdateOneRequiredWithoutBudgetDetailsNestedInput
    planningVersions?: PlanningVersionUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateWithoutSkuRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
  }

  export type SkuCatalogUpsertWithoutSkuRecommendationsInput = {
    update: XOR<SkuCatalogUpdateWithoutSkuRecommendationsInput, SkuCatalogUncheckedUpdateWithoutSkuRecommendationsInput>
    create: XOR<SkuCatalogCreateWithoutSkuRecommendationsInput, SkuCatalogUncheckedCreateWithoutSkuRecommendationsInput>
    where?: SkuCatalogWhereInput
  }

  export type SkuCatalogUpdateToOneWithWhereWithoutSkuRecommendationsInput = {
    where?: SkuCatalogWhereInput
    data: XOR<SkuCatalogUpdateWithoutSkuRecommendationsInput, SkuCatalogUncheckedUpdateWithoutSkuRecommendationsInput>
  }

  export type SkuCatalogUpdateWithoutSkuRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    brand?: GroupBrandUpdateOneWithoutSkuCatalogNestedInput
    products?: ProposalProductUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateWithoutSkuRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: ProposalProductUncheckedUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type GroupBrandCreateWithoutWorkflowStepsInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    budgets?: BudgetCreateNestedManyWithoutGroupBrandInput
    skuCatalog?: SkuCatalogCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandUncheckedCreateWithoutWorkflowStepsInput = {
    id?: string
    code: string
    name: string
    groupId: string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    sortOrder?: number
    budgets?: BudgetUncheckedCreateNestedManyWithoutGroupBrandInput
    skuCatalog?: SkuCatalogUncheckedCreateNestedManyWithoutBrandInput
  }

  export type GroupBrandCreateOrConnectWithoutWorkflowStepsInput = {
    where: GroupBrandWhereUniqueInput
    create: XOR<GroupBrandCreateWithoutWorkflowStepsInput, GroupBrandUncheckedCreateWithoutWorkflowStepsInput>
  }

  export type UserCreateWithoutWorkflowStepsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    createdBudgets?: BudgetCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowStepsInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    roleId: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBudgets?: BudgetUncheckedCreateNestedManyWithoutCreatedByInput
    createdPlannings?: PlanningVersionUncheckedCreateNestedManyWithoutCreatedByInput
    createdProposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
    approvalDecisions?: ApprovalUncheckedCreateNestedManyWithoutDeciderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowStepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowStepsInput, UserUncheckedCreateWithoutWorkflowStepsInput>
  }

  export type GroupBrandUpsertWithoutWorkflowStepsInput = {
    update: XOR<GroupBrandUpdateWithoutWorkflowStepsInput, GroupBrandUncheckedUpdateWithoutWorkflowStepsInput>
    create: XOR<GroupBrandCreateWithoutWorkflowStepsInput, GroupBrandUncheckedCreateWithoutWorkflowStepsInput>
    where?: GroupBrandWhereInput
  }

  export type GroupBrandUpdateToOneWithWhereWithoutWorkflowStepsInput = {
    where?: GroupBrandWhereInput
    data: XOR<GroupBrandUpdateWithoutWorkflowStepsInput, GroupBrandUncheckedUpdateWithoutWorkflowStepsInput>
  }

  export type GroupBrandUpdateWithoutWorkflowStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    budgets?: BudgetUpdateManyWithoutGroupBrandNestedInput
    skuCatalog?: SkuCatalogUpdateManyWithoutBrandNestedInput
  }

  export type GroupBrandUncheckedUpdateWithoutWorkflowStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    colorConfig?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    budgets?: BudgetUncheckedUpdateManyWithoutGroupBrandNestedInput
    skuCatalog?: SkuCatalogUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type UserUpsertWithoutWorkflowStepsInput = {
    update: XOR<UserUpdateWithoutWorkflowStepsInput, UserUncheckedUpdateWithoutWorkflowStepsInput>
    create: XOR<UserCreateWithoutWorkflowStepsInput, UserUncheckedCreateWithoutWorkflowStepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowStepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowStepsInput, UserUncheckedUpdateWithoutWorkflowStepsInput>
  }

  export type UserUpdateWithoutWorkflowStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BudgetCreateManyCreatedByInput = {
    id?: string
    budgetCode: string
    groupBrandId: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanningVersionCreateManyCreatedByInput = {
    id?: string
    planningCode: string
    budgetDetailId: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProposalCreateManyCreatedByInput = {
    id?: string
    ticketName: string
    budgetId: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateManyDeciderInput = {
    id?: string
    entityType: string
    entityId: string
    level: number
    action: $Enums.ApprovalAction
    comment?: string | null
    decidedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    entityType: string
    entityId: string
    action: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ApprovalWorkflowStepCreateManyUserInput = {
    id?: string
    brandId: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupBrand?: GroupBrandUpdateOneRequiredWithoutBudgetsNestedInput
    details?: BudgetDetailUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    groupBrandId?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningVersionUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutPlanningVersionsNestedInput
    details?: PlanningDetailUpdateManyWithoutPlanningVersionNestedInput
    proposals?: ProposalUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: PlanningDetailUncheckedUpdateManyWithoutPlanningVersionNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutProposalsNestedInput
    planningVersion?: PlanningVersionUpdateOneWithoutProposalsNestedInput
    products?: ProposalProductUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProposalProductUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutDeciderInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateWithoutDeciderInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyWithoutDeciderInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    action?: EnumApprovalActionFieldUpdateOperationsInput | $Enums.ApprovalAction
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowStepUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: GroupBrandUpdateOneRequiredWithoutWorkflowStepsNestedInput
  }

  export type ApprovalWorkflowStepUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowStepUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    name: string
    passwordHash: string
    storeAccess?: UserCreatestoreAccessInput | string[]
    brandAccess?: UserCreatebrandAccessInput | string[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBudgets?: BudgetUncheckedUpdateManyWithoutCreatedByNestedInput
    createdPlannings?: PlanningVersionUncheckedUpdateManyWithoutCreatedByNestedInput
    createdProposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
    approvalDecisions?: ApprovalUncheckedUpdateManyWithoutDeciderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    workflowSteps?: ApprovalWorkflowStepUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    storeAccess?: UserUpdatestoreAccessInput | string[]
    brandAccess?: UserUpdatebrandAccessInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateManyGroupBrandInput = {
    id?: string
    budgetCode: string
    seasonGroupId: string
    seasonType: string
    fiscalYear: number
    totalBudget?: Decimal | DecimalJsLike | number | string
    status?: $Enums.BudgetStatus
    comment?: string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SkuCatalogCreateManyBrandInput = {
    id?: string
    skuCode: string
    productName: string
    productType: string
    theme?: string | null
    color?: string | null
    composition?: string | null
    srp: Decimal | DecimalJsLike | number | string
    seasonGroupId?: string | null
    imageUrl?: string | null
    isActive?: boolean
  }

  export type ApprovalWorkflowStepCreateManyBrandInput = {
    id?: string
    stepNumber: number
    roleName: string
    roleCode?: string | null
    userId?: string | null
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetUpdateWithoutGroupBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedBudgetsNestedInput
    details?: BudgetDetailUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateWithoutGroupBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: BudgetDetailUncheckedUpdateManyWithoutBudgetNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutBudgetNestedInput
    budgetAlerts?: BudgetAlertUncheckedUpdateManyWithoutBudgetNestedInput
    budgetSnapshots?: BudgetSnapshotUncheckedUpdateManyWithoutBudgetNestedInput
  }

  export type BudgetUncheckedUpdateManyWithoutGroupBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetCode?: StringFieldUpdateOperationsInput | string
    seasonGroupId?: StringFieldUpdateOperationsInput | string
    seasonType?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    totalBudget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumBudgetStatusFieldUpdateOperationsInput | $Enums.BudgetStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuCatalogUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: ProposalProductUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    products?: ProposalProductUncheckedUpdateManyWithoutSkuNestedInput
    sizeCurveRecommendations?: SizeCurveRecommendationUncheckedUpdateManyWithoutSkuNestedInput
    skuPerformance?: SkuPerformanceUncheckedUpdateManyWithoutSkuNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutSkuNestedInput
  }

  export type SkuCatalogUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productType?: StringFieldUpdateOperationsInput | string
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    seasonGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApprovalWorkflowStepUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutWorkflowStepsNestedInput
  }

  export type ApprovalWorkflowStepUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowStepUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    roleCode?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetDetailCreateManyStoreInput = {
    id?: string
    budgetId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
  }

  export type ProductAllocationCreateManyStoreInput = {
    id?: string
    proposalProductId: string
    quantity?: number
  }

  export type SalesHistoryCreateManyStoreInput = {
    id?: string
    skuCode: string
    sizeCode: string
    season: string
    quantitySold?: number
    quantityBought?: number
    sellThroughPct?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type SizeCurveRecommendationCreateManyStoreInput = {
    id?: string
    skuId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
  }

  export type SkuPerformanceCreateManyStoreInput = {
    id?: string
    skuId: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
  }

  export type BudgetDetailUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    budget?: BudgetUpdateOneRequiredWithoutDetailsNestedInput
    planningVersions?: PlanningVersionUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProductAllocationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    proposalProduct?: ProposalProductUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type ProductAllocationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalProductId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductAllocationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalProductId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SalesHistoryUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesHistoryUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesHistoryUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    quantitySold?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeCurveRecommendationUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: SkuCatalogUpdateOneRequiredWithoutSizeCurveRecommendationsNestedInput
  }

  export type SizeCurveRecommendationUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeCurveRecommendationUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuPerformanceUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: SkuCatalogUpdateOneRequiredWithoutSkuPerformanceNestedInput
  }

  export type SkuPerformanceUncheckedUpdateWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuPerformanceUncheckedUpdateManyWithoutStoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningDetailCreateManyCollectionInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    genderId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
    planningVersion?: PlanningVersionUpdateOneRequiredWithoutDetailsNestedInput
    gender?: GenderUpdateOneWithoutPlanningDetailsNestedInput
    category?: CategoryUpdateOneWithoutPlanningDetailsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutPlanningDetailsNestedInput
  }

  export type PlanningDetailUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateManyGenderInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type PlanningDetailCreateManyGenderInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type CategoryUpdateWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategories?: SubCategoryUpdateManyWithoutCategoryNestedInput
    planningDetails?: PlanningDetailUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subCategories?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanningDetailUpdateWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
    planningVersion?: PlanningVersionUpdateOneRequiredWithoutDetailsNestedInput
    collection?: CollectionUpdateOneWithoutPlanningDetailsNestedInput
    category?: CategoryUpdateOneWithoutPlanningDetailsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutPlanningDetailsNestedInput
  }

  export type PlanningDetailUncheckedUpdateWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailUncheckedUpdateManyWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubCategoryCreateManyCategoryInput = {
    id?: string
    name: string
    isActive?: boolean
  }

  export type PlanningDetailCreateManyCategoryInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type SubCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    planningDetails?: PlanningDetailUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanningDetailUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
    planningVersion?: PlanningVersionUpdateOneRequiredWithoutDetailsNestedInput
    collection?: CollectionUpdateOneWithoutPlanningDetailsNestedInput
    gender?: GenderUpdateOneWithoutPlanningDetailsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutPlanningDetailsNestedInput
  }

  export type PlanningDetailUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailCreateManySubCategoryInput = {
    id?: string
    planningVersionId: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    categoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type PlanningDetailUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
    planningVersion?: PlanningVersionUpdateOneRequiredWithoutDetailsNestedInput
    collection?: CollectionUpdateOneWithoutPlanningDetailsNestedInput
    gender?: GenderUpdateOneWithoutPlanningDetailsNestedInput
    category?: CategoryUpdateOneWithoutPlanningDetailsNestedInput
  }

  export type PlanningDetailUncheckedUpdateWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailUncheckedUpdateManyWithoutSubCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningVersionId?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProposalProductCreateManySkuInput = {
    id?: string
    proposalId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
  }

  export type SizeCurveRecommendationCreateManySkuInput = {
    id?: string
    storeId: string
    category: string
    sizeCode: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    basedOnSeasons: number
    reasoning?: string | null
    createdAt?: Date | string
  }

  export type SkuPerformanceCreateManySkuInput = {
    id?: string
    skuCode: string
    seasonGroup: string
    fiscalYear: number
    storeId?: string | null
    quantityBought: number
    quantitySold: number
    sellThroughPct: Decimal | DecimalJsLike | number | string
    avgSellingPrice: Decimal | DecimalJsLike | number | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    grossMarginPct: Decimal | DecimalJsLike | number | string
    markdownPct: Decimal | DecimalJsLike | number | string
    weeksToSellThru?: number | null
    performanceScore: number
    velocityScore: number
    marginScore: number
    createdAt?: Date | string
  }

  export type SkuRecommendationCreateManySkuInput = {
    id?: string
    budgetDetailId: string
    category: string
    subCategory?: string | null
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
  }

  export type ProposalProductUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    proposal?: ProposalUpdateOneRequiredWithoutProductsNestedInput
    allocations?: ProductAllocationUpdateManyWithoutProposalProductNestedInput
  }

  export type ProposalProductUncheckedUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    allocations?: ProductAllocationUncheckedUpdateManyWithoutProposalProductNestedInput
  }

  export type ProposalProductUncheckedUpdateManyWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type SizeCurveRecommendationUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneRequiredWithoutSizeCurveRecommendationsNestedInput
  }

  export type SizeCurveRecommendationUncheckedUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SizeCurveRecommendationUncheckedUpdateManyWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    sizeCode?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuPerformanceUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoreUpdateOneWithoutSkuPerformanceNestedInput
  }

  export type SkuPerformanceUncheckedUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuPerformanceUncheckedUpdateManyWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    seasonGroup?: StringFieldUpdateOperationsInput | string
    fiscalYear?: IntFieldUpdateOperationsInput | number
    storeId?: NullableStringFieldUpdateOperationsInput | string | null
    quantityBought?: IntFieldUpdateOperationsInput | number
    quantitySold?: IntFieldUpdateOperationsInput | number
    sellThroughPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    avgSellingPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    grossMarginPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    markdownPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    weeksToSellThru?: NullableIntFieldUpdateOperationsInput | number | null
    performanceScore?: IntFieldUpdateOperationsInput | number
    velocityScore?: IntFieldUpdateOperationsInput | number
    marginScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgetDetail?: BudgetDetailUpdateOneRequiredWithoutSkuRecommendationsNestedInput
  }

  export type SkuRecommendationUncheckedUpdateWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationUncheckedUpdateManyWithoutSkuInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetDetailId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetDetailCreateManyBudgetInput = {
    id?: string
    storeId: string
    budgetAmount?: Decimal | DecimalJsLike | number | string
  }

  export type ProposalCreateManyBudgetInput = {
    id?: string
    ticketName: string
    planningVersionId?: string | null
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetAlertCreateManyBudgetInput = {
    id?: string
    alertType: string
    severity: string
    title: string
    message: string
    metricValue: Decimal | DecimalJsLike | number | string
    threshold: Decimal | DecimalJsLike | number | string
    category?: string | null
    isRead?: boolean
    isDismissed?: boolean
    createdAt?: Date | string
  }

  export type BudgetSnapshotCreateManyBudgetInput = {
    id?: string
    snapshotDate: Date | string
    totalCommitted?: Decimal | DecimalJsLike | number | string
    totalPlanned?: Decimal | DecimalJsLike | number | string
    utilizationPct?: Decimal | DecimalJsLike | number | string
  }

  export type BudgetDetailUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    store?: StoreUpdateOneRequiredWithoutBudgetDetailsNestedInput
    planningVersions?: PlanningVersionUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    planningVersions?: PlanningVersionUncheckedUpdateManyWithoutBudgetDetailNestedInput
    allocationRecommendations?: AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
    skuRecommendations?: SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailNestedInput
  }

  export type BudgetDetailUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    budgetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ProposalUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planningVersion?: PlanningVersionUpdateOneWithoutProposalsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProposalsNestedInput
    products?: ProposalProductUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProposalProductUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    planningVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetAlertUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetAlertUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetAlertUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    alertType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metricValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    threshold?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDismissed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetSnapshotUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotUncheckedUpdateWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BudgetSnapshotUncheckedUpdateManyWithoutBudgetInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCommitted?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPlanned?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    utilizationPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PlanningVersionCreateManyBudgetDetailInput = {
    id?: string
    planningCode: string
    versionNumber: number
    versionName?: string | null
    status?: $Enums.PlanningStatus
    isFinal?: boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AllocationRecommendationCreateManyBudgetDetailInput = {
    id?: string
    dimensionType: string
    dimensionValue: string
    recommendedPct: Decimal | DecimalJsLike | number | string
    recommendedAmt: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    reasoning?: string | null
    basedOnSeasons: number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: boolean
    createdAt?: Date | string
  }

  export type SkuRecommendationCreateManyBudgetDetailInput = {
    id?: string
    category: string
    subCategory?: string | null
    skuId: string
    skuCode: string
    productName: string
    recommendedQty: number
    recommendedValue: Decimal | DecimalJsLike | number | string
    confidence: Decimal | DecimalJsLike | number | string
    performanceScore: number
    trendScore: number
    assortmentScore: number
    priceScore: number
    overallScore: number
    riskLevel: string
    reasoning?: string | null
    isSelected?: boolean
    isRejected?: boolean
    createdAt?: Date | string
  }

  export type PlanningVersionUpdateWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedPlanningsNestedInput
    details?: PlanningDetailUpdateManyWithoutPlanningVersionNestedInput
    proposals?: ProposalUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: PlanningDetailUncheckedUpdateManyWithoutPlanningVersionNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutPlanningVersionNestedInput
  }

  export type PlanningVersionUncheckedUpdateManyWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    planningCode?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPlanningStatusFieldUpdateOperationsInput | $Enums.PlanningStatus
    isFinal?: BoolFieldUpdateOperationsInput | boolean
    snapshotData?: NullableJsonNullValueInput | InputJsonValue
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationRecommendationUpdateWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationRecommendationUncheckedUpdateWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllocationRecommendationUncheckedUpdateManyWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    dimensionValue?: StringFieldUpdateOperationsInput | string
    recommendedPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    recommendedAmt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    basedOnSeasons?: IntFieldUpdateOperationsInput | number
    factors?: NullableJsonNullValueInput | InputJsonValue
    isApplied?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationUpdateWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sku?: SkuCatalogUpdateOneRequiredWithoutSkuRecommendationsNestedInput
  }

  export type SkuRecommendationUncheckedUpdateWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkuRecommendationUncheckedUpdateManyWithoutBudgetDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    recommendedQty?: IntFieldUpdateOperationsInput | number
    recommendedValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceScore?: IntFieldUpdateOperationsInput | number
    trendScore?: IntFieldUpdateOperationsInput | number
    assortmentScore?: IntFieldUpdateOperationsInput | number
    priceScore?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    riskLevel?: StringFieldUpdateOperationsInput | string
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    isSelected?: BoolFieldUpdateOperationsInput | boolean
    isRejected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningDetailCreateManyPlanningVersionInput = {
    id?: string
    dimensionType: string
    collectionId?: string | null
    genderId?: string | null
    categoryId?: string | null
    subCategoryId?: string | null
    lastSeasonSales?: Decimal | DecimalJsLike | number | string
    lastSeasonPct?: Decimal | DecimalJsLike | number | string
    systemBuyPct?: Decimal | DecimalJsLike | number | string
    userBuyPct?: Decimal | DecimalJsLike | number | string
    otbValue?: Decimal | DecimalJsLike | number | string
    variancePct?: Decimal | DecimalJsLike | number | string
    userComment?: string | null
  }

  export type ProposalCreateManyPlanningVersionInput = {
    id?: string
    ticketName: string
    budgetId: string
    status?: $Enums.ProposalStatus
    totalSkuCount?: number
    totalOrderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanningDetailUpdateWithoutPlanningVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
    collection?: CollectionUpdateOneWithoutPlanningDetailsNestedInput
    gender?: GenderUpdateOneWithoutPlanningDetailsNestedInput
    category?: CategoryUpdateOneWithoutPlanningDetailsNestedInput
    subCategory?: SubCategoryUpdateOneWithoutPlanningDetailsNestedInput
  }

  export type PlanningDetailUncheckedUpdateWithoutPlanningVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanningDetailUncheckedUpdateManyWithoutPlanningVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dimensionType?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    genderId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeasonSales?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSeasonPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    systemBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userBuyPct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otbValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    variancePct?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    userComment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProposalUpdateWithoutPlanningVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budget?: BudgetUpdateOneRequiredWithoutProposalsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedProposalsNestedInput
    products?: ProposalProductUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateWithoutPlanningVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProposalProductUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type ProposalUncheckedUpdateManyWithoutPlanningVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketName?: StringFieldUpdateOperationsInput | string
    budgetId?: StringFieldUpdateOperationsInput | string
    status?: EnumProposalStatusFieldUpdateOperationsInput | $Enums.ProposalStatus
    totalSkuCount?: IntFieldUpdateOperationsInput | number
    totalOrderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalProductCreateManyProposalInput = {
    id?: string
    skuId: string
    skuCode: string
    productName: string
    collection?: string | null
    gender?: string | null
    category?: string | null
    subCategory?: string | null
    theme?: string | null
    color?: string | null
    composition?: string | null
    unitCost?: Decimal | DecimalJsLike | number | string
    srp?: Decimal | DecimalJsLike | number | string
    orderQty?: number
    totalValue?: Decimal | DecimalJsLike | number | string
    customerTarget?: string | null
    imageUrl?: string | null
    sortOrder?: number
  }

  export type ProposalProductUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    sku?: SkuCatalogUpdateOneRequiredWithoutProductsNestedInput
    allocations?: ProductAllocationUpdateManyWithoutProposalProductNestedInput
  }

  export type ProposalProductUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    allocations?: ProductAllocationUncheckedUpdateManyWithoutProposalProductNestedInput
  }

  export type ProposalProductUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    skuId?: StringFieldUpdateOperationsInput | string
    skuCode?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    collection?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subCategory?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    unitCost?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    srp?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderQty?: IntFieldUpdateOperationsInput | number
    totalValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customerTarget?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductAllocationCreateManyProposalProductInput = {
    id?: string
    storeId: string
    quantity?: number
  }

  export type ProductAllocationUpdateWithoutProposalProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    store?: StoreUpdateOneRequiredWithoutProductAllocationsNestedInput
  }

  export type ProductAllocationUncheckedUpdateWithoutProposalProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductAllocationUncheckedUpdateManyWithoutProposalProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupBrandCountOutputTypeDefaultArgs instead
     */
    export type GroupBrandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupBrandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreCountOutputTypeDefaultArgs instead
     */
    export type StoreCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollectionCountOutputTypeDefaultArgs instead
     */
    export type CollectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GenderCountOutputTypeDefaultArgs instead
     */
    export type GenderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GenderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoryCountOutputTypeDefaultArgs instead
     */
    export type SubCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkuCatalogCountOutputTypeDefaultArgs instead
     */
    export type SkuCatalogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkuCatalogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetCountOutputTypeDefaultArgs instead
     */
    export type BudgetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDetailCountOutputTypeDefaultArgs instead
     */
    export type BudgetDetailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDetailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanningVersionCountOutputTypeDefaultArgs instead
     */
    export type PlanningVersionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanningVersionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalCountOutputTypeDefaultArgs instead
     */
    export type ProposalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalProductCountOutputTypeDefaultArgs instead
     */
    export type ProposalProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupBrandDefaultArgs instead
     */
    export type GroupBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupBrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreDefaultArgs instead
     */
    export type StoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CollectionDefaultArgs instead
     */
    export type CollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CollectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GenderDefaultArgs instead
     */
    export type GenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GenderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubCategoryDefaultArgs instead
     */
    export type SubCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkuCatalogDefaultArgs instead
     */
    export type SkuCatalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkuCatalogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDefaultArgs instead
     */
    export type BudgetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetDetailDefaultArgs instead
     */
    export type BudgetDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanningVersionDefaultArgs instead
     */
    export type PlanningVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanningVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanningDetailDefaultArgs instead
     */
    export type PlanningDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanningDetailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalDefaultArgs instead
     */
    export type ProposalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProposalProductDefaultArgs instead
     */
    export type ProposalProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProposalProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductAllocationDefaultArgs instead
     */
    export type ProductAllocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductAllocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalDefaultArgs instead
     */
    export type ApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesHistoryDefaultArgs instead
     */
    export type SalesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SizeCurveRecommendationDefaultArgs instead
     */
    export type SizeCurveRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SizeCurveRecommendationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetAlertDefaultArgs instead
     */
    export type BudgetAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetAlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BudgetSnapshotDefaultArgs instead
     */
    export type BudgetSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BudgetSnapshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AllocationHistoryDefaultArgs instead
     */
    export type AllocationHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AllocationHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AllocationRecommendationDefaultArgs instead
     */
    export type AllocationRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AllocationRecommendationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskAssessmentDefaultArgs instead
     */
    export type RiskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskThresholdDefaultArgs instead
     */
    export type RiskThresholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskThresholdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkuPerformanceDefaultArgs instead
     */
    export type SkuPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkuPerformanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttributeTrendDefaultArgs instead
     */
    export type AttributeTrendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttributeTrendDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkuRecommendationDefaultArgs instead
     */
    export type SkuRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkuRecommendationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalWorkflowStepDefaultArgs instead
     */
    export type ApprovalWorkflowStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalWorkflowStepDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}